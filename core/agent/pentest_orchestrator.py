# core/agent/pentest_orchestrator.py
# DRAKBEN Pentest Orchestrator - State Machine & LLM Coordinator
# Author: @drak_ben
"""
This module implements a hybrid approach:
- CODE controls the flow (state machine)
- LLM provides intelligence (analysis, suggestions)
- Tool execution is deterministic
- Output analysis uses LLM

State Flow:
    IDLE → TARGET_SET → RECON → VULN_SCAN → EXPLOIT → POST_EXPLOIT → COMPLETE
"""

import logging
import platform
import subprocess
import threading
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any

logger = logging.getLogger(__name__)


class PentestPhase(Enum):
    """Pentest phases - deterministic state machine."""
    IDLE = auto()           # No target, chat mode
    TARGET_SET = auto()     # Target configured, ready to start
    RECON = auto()          # Reconnaissance phase
    VULN_SCAN = auto()      # Vulnerability scanning
    EXPLOIT = auto()        # Exploitation attempts
    POST_EXPLOIT = auto()   # Post-exploitation
    REPORTING = auto()      # Generating report
    COMPLETE = auto()       # Mission complete


@dataclass
class PentestContext:
    """Current pentest context - passed to LLM for analysis."""
    target: str | None = None
    phase: PentestPhase = PentestPhase.IDLE
    language: str = "tr"

    # Findings
    open_ports: list[dict] = field(default_factory=list)
    services: list[dict] = field(default_factory=list)
    vulnerabilities: list[dict] = field(default_factory=list)
    credentials: list[dict] = field(default_factory=list)

    # History
    executed_tools: list[str] = field(default_factory=list)
    tool_outputs: list[dict] = field(default_factory=list)
    llm_analyses: list[dict] = field(default_factory=list)

    # System info
    is_kali: bool = False
    os_name: str = ""
    available_tools: list[str] = field(default_factory=list)


# Compact LLM Prompts (focused, 15 lines max)
PROMPTS = {
    "analyze_output": """You are DRAKBEN, elite pentester. Analyze this tool output.
Target: {target} | Phase: {phase}

TOOL OUTPUT:
{output}

Respond in {lang}. JSON only:
{{"findings": ["finding1", "finding2"], "next_action": "suggested_tool or null", "severity": "info|low|medium|high|critical", "summary": "2-3 sentence analysis"}}""",

    "chat": """You are DRAKBEN, professional security expert.
Current target: {target} | Phase: {phase}
System: {os_name} (Kali: {is_kali})

Rules:
- Be professional, concise, technical
- No emojis
- Answer in {lang}
- If no target set and user asks to scan, tell them to set target first

User: {user_input}""",

    "suggest_next": """You are DRAKBEN pentester. Based on current findings, suggest next action.
Target: {target} | Phase: {phase}
Open ports: {ports}
Services: {services}
Vulnerabilities: {vulns}

Suggest ONE next action. JSON only:
{{"tool": "nmap|nikto|gobuster|sqlmap|hydra|manual", "command": "full command", "reason": "why this tool"}}""",
}


class PentestOrchestrator:
    """Main orchestrator - controls flow, delegates analysis to LLM."""

    def __init__(self, llm_client: Any = None) -> None:
        self.llm_client = llm_client
        self.context = PentestContext()
        self._tool_cache: dict[str, bool] = {}  # Cache for tool availability
        self._init_system_info()

        # Tool Registry integration
        from core.tools.tool_registry import get_registry
        self.tools = get_registry()

    def _init_system_info(self) -> None:
        """Detect system environment."""
        self.context.os_name = platform.system()
        self.context.is_kali = self._detect_kali()
        self.context.available_tools = self._detect_tools()

    def _detect_kali(self) -> bool:
        """Check if running on Kali Linux."""
        try:
            with open("/etc/os-release") as f:
                return "kali" in f.read().lower()
        except OSError:
            return False

    def _is_tool_available(self, tool: str) -> bool:
        """Check if tool is available (with caching)."""
        if tool in self._tool_cache:
            return self._tool_cache[tool]

        try:
            cmd = ["which", tool] if platform.system() != "Windows" else ["where", tool]
            result = subprocess.run(cmd, capture_output=True, timeout=2)
            available = result.returncode == 0
        except (OSError, subprocess.SubprocessError):
            available = False

        self._tool_cache[tool] = available
        return available

    def _detect_tools(self) -> list[str]:
        """Detect available pentest tools."""
        common_tools = ["nmap", "nikto", "gobuster", "sqlmap", "hydra", "metasploit"]
        return [tool for tool in common_tools if self._is_tool_available(tool)]

    # =========================================================================
    # STATE MANAGEMENT
    # =========================================================================

    def set_target(self, target: str) -> dict:
        """Set target and transition to TARGET_SET phase."""
        self.context.target = target
        self.context.phase = PentestPhase.TARGET_SET

        lang = self.context.language
        msg = f"Hedef ayarlandı: {target}" if lang == "tr" else f"Target set: {target}"

        return {
            "success": True,
            "message": msg,
            "phase": self.context.phase.name,
            "suggested_actions": self._get_phase_actions(),
        }

    def clear_target(self) -> dict:
        """Clear target and reset to IDLE."""
        self.context = PentestContext(
            language=self.context.language,
            is_kali=self.context.is_kali,
            os_name=self.context.os_name,
            available_tools=self.context.available_tools,
        )

        lang = self.context.language
        msg = "Hedef temizlendi." if lang == "tr" else "Target cleared."

        return {"success": True, "message": msg, "phase": "IDLE"}

    def advance_phase(self) -> PentestPhase:
        """Advance to next logical phase."""
        transitions = {
            PentestPhase.IDLE: PentestPhase.IDLE,  # Need target
            PentestPhase.TARGET_SET: PentestPhase.RECON,
            PentestPhase.RECON: PentestPhase.VULN_SCAN,
            PentestPhase.VULN_SCAN: PentestPhase.EXPLOIT,
            PentestPhase.EXPLOIT: PentestPhase.POST_EXPLOIT,
            PentestPhase.POST_EXPLOIT: PentestPhase.REPORTING,
            PentestPhase.REPORTING: PentestPhase.COMPLETE,
        }

        self.context.phase = transitions.get(self.context.phase, self.context.phase)
        return self.context.phase

    def _get_phase_actions(self) -> list[dict]:
        """Get suggested actions for current phase from ToolRegistry."""
        target = self.context.target or "<target>"

        # Map orchestrator phase to registry phase
        from core.tools.tool_registry import PentestPhase as RegistryPhase

        phase_map = {
            PentestPhase.TARGET_SET: RegistryPhase.RECON,
            PentestPhase.RECON: RegistryPhase.RECON,
            PentestPhase.VULN_SCAN: RegistryPhase.VULN_SCAN,
            PentestPhase.EXPLOIT: RegistryPhase.EXPLOIT,
            PentestPhase.POST_EXPLOIT: RegistryPhase.POST_EXPLOIT,
        }

        registry_phase = phase_map.get(self.context.phase)
        if not registry_phase:
            return []

        # Get tools for this phase
        tools = self.tools.list_tools(phase=registry_phase)

        actions = []
        for tool in tools[:3]:  # Limit to 3 suggestions
            if tool.command_template:
                cmd = tool.command_template.format(target=target)
            else:
                cmd = tool.name  # Python tool - just name

            actions.append({
                "tool": tool.name,
                "command": cmd,
                "description": tool.description,
            })

        return actions

    def list_available_tools(self) -> list[str]:
        """List all available tools from registry."""
        return self.tools.list_names()

    # =========================================================================
    # TOOL EXECUTION
    # =========================================================================

    def execute_tool(self, command: str, timeout: int = 300, live_output: bool = True, analyze: bool = True) -> dict:
        """Execute a tool with optional live output and LLM analysis.

        Args:
            command: Shell command OR registered tool name (e.g., "nmap", "passive_recon")
            timeout: Max execution time in seconds
            live_output: If True, show output in real-time
            analyze: If True, send output to LLM for analysis
        """
        # Check if this is a registered tool name (not a full command)
        tool_name = command.split()[0] if command else "unknown"
        registered_tool = self.tools.get(tool_name)

        # If it's a registered tool and no target in command, use context target
        if registered_tool and self.context.target and tool_name == command.strip():
            # Execute via registry
            result = self.tools.execute(tool_name, self.context.target, live_output=live_output)
        else:
            # Execute as raw shell command
            result = self._execute_raw_command(command, timeout, live_output)

        # Store in context
        self.context.executed_tools.append(tool_name)
        self.context.tool_outputs.append({
            "tool": tool_name,
            "command": command,
            "output": result.get("output", "")[:10000],
            "success": result.get("success", False),
            "timestamp": time.time(),
        })

        # LLM Analysis if enabled and output exists
        if analyze and result.get("success") and result.get("output"):
            analysis = self.analyze_output(result["output"])
            result["analysis"] = analysis.get("analysis", {})

            # Print analysis summary
            if analysis.get("success"):
                summary = analysis.get("analysis", {}).get("summary", "")
                if summary:
                    print(f"\n[Analysis] {summary}")

        return result

    @staticmethod
    def _validate_command(command: str) -> str | None:
        """Validate command against injection patterns. Returns error or None."""
        # C-2 FIX: Basic command injection guard for LLM-derived commands
        _INJECTION_PATTERNS = (
            "$(", "`",  # command substitution
            "; rm ", "; curl ", "; wget ",  # chained destructive
            ">/etc/", ">> /etc/",  # system file overwrites
            "| bash", "| sh", "| python",  # pipe to interpreter
        )
        cmd_lower = command.lower().strip()
        for pattern in _INJECTION_PATTERNS:
            if pattern.lower() in cmd_lower:
                return f"Blocked suspicious pattern: {pattern!r}"
        return None

    def _execute_raw_command(self, command: str, timeout: int, live_output: bool) -> dict:
        """Execute a raw shell command."""
        tool_name = command.split()[0] if command else "unknown"

        # C-2 FIX: Validate command before shell execution
        validation_error = self._validate_command(command)
        if validation_error:
            logger.warning("Command blocked: %s — %s", command, validation_error)
            return {"success": False, "error": validation_error, "tool": tool_name}

        logger.info("Executing: %s", command)

        try:
            if live_output:
                # Live output mode - user sees it in real-time
                process = subprocess.Popen(
                    command,
                    shell=True,  # nosec B602 - Pentest tool requires shell for pipes/redirects
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                )

                output_lines = []
                try:
                    for line in process.stdout:
                        print(line, end="", flush=True)  # Live print
                        output_lines.append(line)
                    process.wait(timeout=timeout)
                except subprocess.TimeoutExpired:
                    process.kill()
                    return {"success": False, "error": "Timeout", "tool": tool_name}

                output = "".join(output_lines)
                success = process.returncode == 0
                returncode = process.returncode
            else:
                # Silent mode - capture all then return
                result = subprocess.run(
                    command,
                    shell=True,  # nosec B602 - Pentest tool requires shell for pipes/redirects
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                )
                output = result.stdout + result.stderr
                success = result.returncode == 0
                returncode = result.returncode

            return {
                "success": success,
                "output": output,
                "tool": tool_name,
                "returncode": returncode,
            }

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Timeout", "tool": tool_name}
        except Exception as e:
            return {"success": False, "error": str(e), "tool": tool_name}

    # =========================================================================
    # LLM INTEGRATION
    # =========================================================================

    def analyze_output(self, tool_output: str) -> dict:
        """Use LLM to analyze tool output."""
        if not self.llm_client:
            return self._offline_analysis(tool_output)

        prompt = PROMPTS["analyze_output"].format(
            target=self.context.target or "N/A",
            phase=self.context.phase.name,
            output=tool_output[:8000],
            lang="Turkish" if self.context.language == "tr" else "English",
        )

        try:
            response = self.llm_client.query(prompt, timeout=30)

            # Try to parse JSON
            import json
            try:
                analysis = json.loads(response)
            except json.JSONDecodeError:
                analysis = {"summary": response, "findings": [], "next_action": None}

            # Store analysis
            self.context.llm_analyses.append(analysis)

            # Extract findings
            self._process_findings(analysis.get("findings", []))

            return {"success": True, "analysis": analysis}

        except Exception as e:
            logger.warning("LLM analysis failed: %s", e)
            return self._offline_analysis(tool_output)

    def _offline_analysis(self, output: str) -> dict:
        """Basic offline analysis without LLM."""
        findings = []

        # Simple pattern matching
        if "open" in output.lower():
            findings.append("Open ports detected")
        if "apache" in output.lower() or "nginx" in output.lower():
            findings.append("Web server detected")
        if "ssh" in output.lower():
            findings.append("SSH service detected")
        if "vulnerable" in output.lower() or "vuln" in output.lower():
            findings.append("Potential vulnerability mentioned")
        if "error" in output.lower():
            findings.append("Errors in output - review manually")

        return {
            "success": True,
            "analysis": {
                "summary": "Offline analysis - basic pattern matching",
                "findings": findings,
                "next_action": None,
                "severity": "info",
            },
        }

    def _process_findings(self, findings: list) -> None:
        """Process and store findings from analysis."""
        for finding in findings:
            if isinstance(finding, str):
                # Simple string finding
                if "port" in finding.lower() and "open" in finding.lower():
                    # Try to extract port info
                    pass
                elif "vuln" in finding.lower():
                    self.context.vulnerabilities.append({"description": finding})

    def chat(self, user_input: str) -> dict:
        """Handle chat/question from user."""
        # First, try to extract target from natural language
        extracted_target = self._extract_target_from_text(user_input)
        if extracted_target and not self.context.target:
            self.set_target(extracted_target)

        # Check if this is an action request
        is_action = self._is_action_request(user_input)

        # Handle action without target
        if is_action and not self.context.target:
            return self._no_target_response()

        # Handle action with target
        if is_action and self.context.target:
            return self._action_response()

        # Use LLM for chat if available
        return self._llm_chat(user_input)

    def _is_action_request(self, text: str) -> bool:
        """Check if text contains action keywords."""
        action_words = ["tara", "scan", "exploit", "saldır", "attack", "keşfet", "recon", "analiz"]
        return any(w in text.lower() for w in action_words)

    def _no_target_response(self) -> dict:
        """Return response when no target is set."""
        lang = self.context.language
        if lang == "tr":
            msg = "Hedef belirtmediniz. Ornek: 'example.com sitesini tara' veya /target example.com"
        else:
            msg = "No target specified. Example: 'scan example.com' or /target example.com"
        return {"success": True, "response": msg, "intent": "needs_target"}

    def _action_response(self) -> dict:
        """Return action response with suggestion."""
        lang = self.context.language
        suggestion = self._get_phase_actions()
        if suggestion:
            action = suggestion[0]
            if lang == "tr":
                msg = f"Hedef: {self.context.target}\nOnerilen: {action.get('tool', '?')} - {action.get('description', '')}"
            else:
                msg = f"Target: {self.context.target}\nSuggested: {action.get('tool', '?')} - {action.get('description', '')}"
            return {"success": True, "response": msg, "intent": "action", "suggestion": action}
        return {"success": True, "response": "No suggestions", "intent": "chat"}

    def _llm_chat(self, user_input: str) -> dict:
        """Process chat with LLM or offline fallback."""
        if self.llm_client:
            # Check if client actually has a valid API key
            if not getattr(self.llm_client, "api_key", None):
                return self._offline_chat(user_input)

            prompt = PROMPTS["chat"].format(
                target=self.context.target or "None",
                phase=self.context.phase.name,
                os_name=self.context.os_name,
                is_kali="Yes" if self.context.is_kali else "No",
                lang="Turkish" if self.context.language == "tr" else "English",
                user_input=user_input,
            )
            try:
                response = self.llm_client.query(prompt, timeout=20)
                # Detect error responses and fall back to offline
                if response.startswith("[") and any(
                    tag in response for tag in [
                        "[Auth Error]", "[Offline", "[Error]", "[Rate Limit",
                        "[Timeout]", "[Server Error]",
                    ]
                ):
                    logger.warning("LLM returned error: %s", response[:100])
                    return self._offline_chat(user_input)
                return {"success": True, "response": response, "intent": "chat"}
            except Exception as e:
                logger.warning("LLM chat failed: %s", e)
        return self._offline_chat(user_input)

    def _extract_target_from_text(self, text: str) -> str | None:
        """Extract target (IP or domain) from natural language text."""
        import re

        # Simple IP pattern (good enough for most cases)
        ip_pattern = r"\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\b"
        ip_match = re.search(ip_pattern, text)
        if ip_match:
            return ip_match.group(1)

        # Domain pattern (more flexible)
        domain_pattern = r"\b([a-zA-Z0-9][-a-zA-Z0-9]*\.)+[a-zA-Z]{2,}\b"
        domain_match = re.search(domain_pattern, text)
        if domain_match:
            return domain_match.group()

        # Turkish pattern: "X'i tara", "X'u tara", "X sitesini"
        tr_patterns = [
            r"([a-zA-Z0-9.-]+(?:\.[a-zA-Z]{2,}))'[iıuü] tara",
            r"([a-zA-Z0-9.-]+(?:\.[a-zA-Z]{2,})) sitesini",
            r"([a-zA-Z0-9.-]+(?:\.[a-zA-Z]{2,})) hedefini",
        ]
        for pattern in tr_patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1)

        return None

    def _offline_chat(self, user_input: str) -> dict:
        """Offline chat responses."""
        lang = self.context.language
        user_lower = user_input.lower()

        # Simple intent detection
        if any(w in user_lower for w in ["selam", "merhaba", "hello", "hi"]):
            msg = "Merhaba. Hedef belirleyip taramaya başlayabilirsiniz." if lang == "tr" else "Hello. Set a target to begin scanning."
        elif any(w in user_lower for w in ["yardım", "help"]):
            msg = "Komutlar: /target, /scan, /status, /report, /clear" if lang == "tr" else "Commands: /target, /scan, /status, /report, /clear"
        elif any(w in user_lower for w in ["durum", "status"]):
            msg = f"Faz: {self.context.phase.name}, Hedef: {self.context.target or 'Yok'}" if lang == "tr" else f"Phase: {self.context.phase.name}, Target: {self.context.target or 'None'}"
        else:
            msg = "LLM bağlantısı yok. Temel komutları kullanabilirsiniz." if lang == "tr" else "No LLM connection. Use basic commands."

        return {"success": True, "response": msg, "intent": "chat"}

    # =========================================================================
    # STATUS & REPORTING
    # =========================================================================

    def get_status(self) -> dict:
        """Get current pentest status."""
        return {
            "phase": self.context.phase.name,
            "target": self.context.target,
            "language": self.context.language,
            "system": {
                "os": self.context.os_name,
                "is_kali": self.context.is_kali,
                "available_tools": self.context.available_tools,
            },
            "findings": {
                "open_ports": len(self.context.open_ports),
                "services": len(self.context.services),
                "vulnerabilities": len(self.context.vulnerabilities),
                "credentials": len(self.context.credentials),
            },
            "history": {
                "tools_executed": len(self.context.executed_tools),
                "analyses": len(self.context.llm_analyses),
            },
        }

    def generate_report(self) -> dict:
        """Generate pentest report."""
        self.context.phase = PentestPhase.REPORTING

        report = {
            "target": self.context.target,
            "scan_date": time.strftime("%Y-%m-%d %H:%M:%S"),
            "executive_summary": self._generate_summary(),
            "open_ports": self.context.open_ports,
            "services": self.context.services,
            "vulnerabilities": self.context.vulnerabilities,
            "recommendations": self._generate_recommendations(),
            "tools_used": list(set(self.context.executed_tools)),
        }

        self.context.phase = PentestPhase.COMPLETE

        return {"success": True, "report": report}

    def _generate_summary(self) -> str:
        """Generate executive summary."""
        vuln_count = len(self.context.vulnerabilities)
        port_count = len(self.context.open_ports)

        lang = self.context.language
        if lang == "tr":
            return f"Hedef {self.context.target} üzerinde {port_count} açık port ve {vuln_count} potansiyel zafiyet tespit edildi."
        return f"Target {self.context.target}: {port_count} open ports and {vuln_count} potential vulnerabilities identified."

    def _generate_recommendations(self) -> list[str]:
        """Generate security recommendations."""
        recs = []
        lang = self.context.language

        if self.context.vulnerabilities:
            if lang == "tr":
                recs.append("Tespit edilen zafiyetler için yama uygulayın")
            else:
                recs.append("Apply patches for identified vulnerabilities")

        if any(p.get("port") in [21, 23, 25] for p in self.context.open_ports):
            if lang == "tr":
                recs.append("Güvenli olmayan servisleri kapatın (FTP, Telnet)")
            else:
                recs.append("Disable insecure services (FTP, Telnet)")

        return recs


# Singleton instance
_orchestrator: PentestOrchestrator | None = None
_orchestrator_lock = threading.Lock()


def get_orchestrator(llm_client: Any = None) -> PentestOrchestrator:
    """Get or create orchestrator singleton."""
    global _orchestrator

    if _orchestrator is None:
        with _orchestrator_lock:
            if _orchestrator is None:
                _orchestrator = PentestOrchestrator(llm_client)
    elif llm_client and _orchestrator.llm_client is None:
        _orchestrator.llm_client = llm_client

    return _orchestrator
