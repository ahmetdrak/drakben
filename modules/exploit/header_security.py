# modules/exploit/header_security.py
"""
DRAKBEN Header Security Module — HTTP Security Header Analysis & Exploitation.

Covers:
  - Security header presence/absence audit
  - CORS misconfiguration detection
  - CSP bypass analysis
  - Clickjacking detection
  - Cache poisoning via headers
  - Host header injection
"""

import logging
from typing import Any

import aiohttp

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════
# Security Header Audit
# ═══════════════════════════════════════════════════════════

# Expected security headers and their recommended values
_SECURITY_HEADERS: dict[str, dict[str, Any]] = {
    "Strict-Transport-Security": {
        "severity": "HIGH",
        "description": "HSTS not set — vulnerable to SSL stripping",
        "recommendation": "max-age=31536000; includeSubDomains; preload",
    },
    "Content-Security-Policy": {
        "severity": "HIGH",
        "description": "CSP not set — vulnerable to XSS",
        "recommendation": "default-src 'self'; script-src 'self'",
    },
    "X-Content-Type-Options": {
        "severity": "MEDIUM",
        "description": "X-Content-Type-Options not set — MIME sniffing possible",
        "recommendation": "nosniff",
    },
    "X-Frame-Options": {
        "severity": "MEDIUM",
        "description": "X-Frame-Options not set — clickjacking possible",
        "recommendation": "DENY",
    },
    "X-XSS-Protection": {
        "severity": "LOW",
        "description": "X-XSS-Protection not set (legacy but still useful)",
        "recommendation": "1; mode=block",
    },
    "Referrer-Policy": {
        "severity": "LOW",
        "description": "Referrer-Policy not set — URL leakage via Referer",
        "recommendation": "strict-origin-when-cross-origin",
    },
    "Permissions-Policy": {
        "severity": "LOW",
        "description": "Permissions-Policy not set — browser feature control missing",
        "recommendation": "camera=(), microphone=(), geolocation=()",
    },
    "Cache-Control": {
        "severity": "MEDIUM",
        "description": "Cache-Control not set — sensitive data may be cached",
        "recommendation": "no-store, no-cache, must-revalidate",
    },
}

# Dangerous headers that leak information
_INFO_LEAK_HEADERS = [
    "Server",
    "X-Powered-By",
    "X-AspNet-Version",
    "X-AspNetMvc-Version",
    "X-Generator",
    "X-Drupal-Cache",
    "X-Varnish",
    "Via",
]


async def audit_security_headers(
    target_url: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Comprehensive security header audit.

    Args:
        target_url: Target URL to audit.
        timeout: Request timeout.

    Returns:
        Dict with 'missing_headers', 'info_leak_headers', 'score', 'findings'.

    """
    try:
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=timeout),
            connector=aiohttp.TCPConnector(ssl=False),
        ) as session:
            async with session.get(target_url) as resp:
                headers = dict(resp.headers)
    except (aiohttp.ClientError, TimeoutError, OSError) as e:
        return {"error": str(e), "score": 0, "missing_headers": [], "info_leak_headers": []}

    missing: list[dict[str, str]] = []
    present: list[str] = []
    info_leaks: list[dict[str, str]] = []

    # Check expected security headers
    for header_name, meta in _SECURITY_HEADERS.items():
        if header_name not in headers:
            missing.append({
                "header": header_name,
                "severity": meta["severity"],
                "description": meta["description"],
                "recommendation": meta["recommendation"],
            })
        else:
            present.append(header_name)

    # Check info leak headers
    for header_name in _INFO_LEAK_HEADERS:
        if header_name in headers:
            info_leaks.append({
                "header": header_name,
                "value": headers[header_name],
                "risk": "Information disclosure",
            })

    # Calculate score (0-100)
    total = len(_SECURITY_HEADERS)
    score = int((len(present) / total) * 100) if total > 0 else 0

    return {
        "score": score,
        "missing_headers": missing,
        "present_headers": present,
        "info_leak_headers": info_leaks,
        "total_checked": total,
        "grade": _grade_from_score(score),
    }


def _grade_from_score(score: int) -> str:
    """Convert numeric score to letter grade."""
    if score >= 90:
        return "A"
    if score >= 75:
        return "B"
    if score >= 60:
        return "C"
    if score >= 40:
        return "D"
    return "F"


# ═══════════════════════════════════════════════════════════
# CORS Misconfiguration Detection
# ═══════════════════════════════════════════════════════════

_CORS_TEST_ORIGINS = [
    "https://evil.com",
    "https://attacker.com",
    "null",
    "https://target.com.evil.com",
    "https://evil-target.com",
]


async def test_cors_misconfiguration(
    target_url: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for CORS misconfiguration vulnerabilities.

    Args:
        target_url: Target URL to test.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'findings'.

    """
    findings: list[dict[str, Any]] = []

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for origin in _CORS_TEST_ORIGINS:
            try:
                headers = {"Origin": origin}
                async with session.get(target_url, headers=headers) as resp:
                    acao = resp.headers.get("Access-Control-Allow-Origin", "")
                    acac = resp.headers.get("Access-Control-Allow-Credentials", "")

                    if acao == "*":
                        findings.append({
                            "origin": origin,
                            "acao": acao,
                            "severity": "HIGH" if acac.lower() == "true" else "MEDIUM",
                            "issue": "Wildcard CORS origin",
                        })
                    elif acao == origin and origin != "null":
                        findings.append({
                            "origin": origin,
                            "acao": acao,
                            "severity": "CRITICAL" if acac.lower() == "true" else "HIGH",
                            "issue": "Arbitrary origin reflected",
                        })
                    elif acao == "null":
                        findings.append({
                            "origin": origin,
                            "acao": acao,
                            "severity": "HIGH",
                            "issue": "Null origin allowed",
                        })
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(findings) > 0,
        "findings": findings,
    }


# ═══════════════════════════════════════════════════════════
# CSP Analysis
# ═══════════════════════════════════════════════════════════

_CSP_DANGEROUS_DIRECTIVES = {
    "unsafe-inline": {"severity": "HIGH", "issue": "Allows inline script execution (XSS risk)"},
    "unsafe-eval": {"severity": "HIGH", "issue": "Allows eval() (code injection risk)"},
    "data:": {"severity": "MEDIUM", "issue": "Allows data: URI for script loading"},
    "*": {"severity": "HIGH", "issue": "Wildcard source allows any origin"},
    "blob:": {"severity": "MEDIUM", "issue": "Allows blob: URI for script loading"},
}


def analyze_csp(csp_header: str) -> dict[str, Any]:
    """Analyze Content-Security-Policy for weaknesses.

    Args:
        csp_header: CSP header value.

    Returns:
        Dict with 'weaknesses', 'directives', 'score'.

    """
    if not csp_header:
        return {"score": 0, "weaknesses": [{"issue": "No CSP header", "severity": "HIGH"}], "directives": {}}

    directives: dict[str, list[str]] = {}
    weaknesses: list[dict[str, str]] = []

    for directive in csp_header.split(";"):
        directive = directive.strip()
        if not directive:
            continue
        parts = directive.split()
        if parts:
            directives[parts[0]] = parts[1:] if len(parts) > 1 else []

    # Check for dangerous values
    for d_name, d_values in directives.items():
        for value in d_values:
            value_stripped = value.strip("'")
            if value_stripped in _CSP_DANGEROUS_DIRECTIVES:
                meta = _CSP_DANGEROUS_DIRECTIVES[value_stripped]
                weaknesses.append({
                    "directive": d_name,
                    "value": value,
                    "severity": meta["severity"],
                    "issue": meta["issue"],
                })

    # Check for missing critical directives
    critical = ["default-src", "script-src", "object-src", "base-uri"]
    for d in critical:
        if d not in directives and "default-src" not in directives:
            weaknesses.append({
                "directive": d,
                "severity": "MEDIUM",
                "issue": f"Missing {d} directive",
            })

    score = max(0, 100 - len(weaknesses) * 15)
    return {
        "score": score,
        "weaknesses": weaknesses,
        "directives": directives,
        "grade": _grade_from_score(score),
    }


# ═══════════════════════════════════════════════════════════
# Host Header Injection
# ═══════════════════════════════════════════════════════════

async def test_host_header_injection(
    target_url: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for host header injection vulnerabilities.

    Args:
        target_url: Target URL to test.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'findings'.

    """
    findings: list[dict[str, Any]] = []

    test_cases = [
        {"Host": "evil.com", "technique": "direct_override"},
        {"X-Forwarded-Host": "evil.com", "technique": "x_forwarded_host"},
        {"X-Host": "evil.com", "technique": "x_host"},
        {"X-Forwarded-Server": "evil.com", "technique": "x_forwarded_server"},
        {"Host": "target.com\r\nX-Injected: true", "technique": "crlf_in_host"},
    ]

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for test in test_cases:
            technique = test.pop("technique")
            try:
                async with session.get(target_url, headers=test) as resp:
                    text = await resp.text()
                    if "evil.com" in text:
                        findings.append({
                            "technique": technique,
                            "reflected": True,
                            "severity": "HIGH",
                        })
                        logger.warning("Host header injection found: %s", technique)
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(findings) > 0,
        "findings": findings,
    }


# ═══════════════════════════════════════════════════════════
# Clickjacking Detection
# ═══════════════════════════════════════════════════════════

async def test_clickjacking(
    target_url: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for clickjacking vulnerability.

    Args:
        target_url: Target URL to test.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'details'.

    """
    try:
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=timeout),
            connector=aiohttp.TCPConnector(ssl=False),
        ) as session:
            async with session.get(target_url) as resp:
                headers = dict(resp.headers)

                xfo = headers.get("X-Frame-Options", "")
                csp = headers.get("Content-Security-Policy", "")

                has_xfo = xfo.upper() in ("DENY", "SAMEORIGIN")
                has_csp_frame = "frame-ancestors" in csp

                return {
                    "vulnerable": not (has_xfo or has_csp_frame),
                    "x_frame_options": xfo or "MISSING",
                    "csp_frame_ancestors": "present" if has_csp_frame else "MISSING",
                    "details": (
                        "Protected" if (has_xfo or has_csp_frame)
                        else "Vulnerable to clickjacking — no framing protection"
                    ),
                }
    except (aiohttp.ClientError, TimeoutError, OSError) as e:
        return {"vulnerable": False, "error": str(e)}
