# tests/test_exploit.py
"""Tests for modules/exploit - Exploit module test suite."""

from unittest.mock import MagicMock, patch

import pytest

from modules.exploit import (
    AIEvasion,
    ExploitError,
    PolyglotEngine,
    RetryConfig,
    check_exploit_preconditions,
    retry_on_failure,
    suggest_exploit,
)

# =============================================================================
# RetryConfig Tests
# =============================================================================


class TestRetryConfig:
    """Test RetryConfig class."""

    def test_default_values(self):
        """Test default retry configuration values."""
        config = RetryConfig()
        assert config.max_retries == 3
        assert config.base_delay == pytest.approx(1.0)
        assert config.max_delay == pytest.approx(30.0)

    def test_custom_values(self):
        """Test custom retry configuration."""
        config = RetryConfig(max_retries=5, base_delay=2.0, max_delay=60.0)
        assert config.max_retries == 5
        assert config.base_delay == pytest.approx(2.0)
        assert config.max_delay == pytest.approx(60.0)


# =============================================================================
# ExploitError Tests
# =============================================================================


class TestExploitError:
    """Test ExploitError exception class."""

    def test_exception_message(self):
        """Test exception message."""
        with pytest.raises(ExploitError, match="Test error"):
            raise ExploitError("Test error")

    def test_exception_inheritance(self):
        """Test exception inherits from Exception."""
        assert issubclass(ExploitError, Exception)


# =============================================================================
# AIEvasion Tests
# =============================================================================


class TestAIEvasion:
    """Test AIEvasion class for payload mutation."""

    def test_mutate_xss_payload(self):
        """Test XSS payload mutation with unicode."""
        payload = "<script>alert(1)</script>"
        mutations = AIEvasion.mutate_payload(payload, strategy="semantic")

        assert len(mutations) > 0
        # Check for unicode mutation
        assert any("\uff1c" in m for m in mutations)  # Fullwidth less-than

    def test_mutate_sql_payload(self):
        """Test SQL injection payload mutation."""
        payload = "' OR 1=1 --"
        mutations = AIEvasion.mutate_payload(payload, strategy="semantic")

        assert len(mutations) > 0
        # Check for semantic SQL equivalents
        assert any("333=333" in m or "'x'='x'" in m or "|| true" in m for m in mutations)

    def test_mutate_combined_payload(self):
        """Test payload with multiple mutation opportunities."""
        payload = "<script>alert(1)</script>' OR 1=1 --"
        mutations = AIEvasion.mutate_payload(payload, strategy="semantic")

        # Should have mutations for both XSS and SQL
        assert len(mutations) >= 2

    def test_mutate_no_mutations_needed(self):
        """Test payload that doesn't need mutation."""
        payload = "simple text"
        mutations = AIEvasion.mutate_payload(payload, strategy="semantic")

        assert mutations == []


# =============================================================================
# PolyglotEngine Tests
# =============================================================================


class TestPolyglotEngine:
    """Test PolyglotEngine for polyglot payload generation."""

    def test_get_chimera_payloads(self):
        """Test polyglot payload generation."""
        payloads = PolyglotEngine.get_chimera_payloads()

        assert len(payloads) >= 4
        assert isinstance(payloads, list)
        assert all(isinstance(p, str) for p in payloads)

    def test_chimera_payloads_contain_sql(self):
        """Test that payloads contain SQL injection vectors."""
        payloads = PolyglotEngine.get_chimera_payloads()

        # At least one payload should have SQL injection pattern
        assert any("OR 1=1" in p or "OR" in p for p in payloads)

    def test_chimera_payloads_contain_xss(self):
        """Test that payloads contain XSS vectors."""
        payloads = PolyglotEngine.get_chimera_payloads()

        # At least one payload should have XSS pattern
        assert any("<" in p or "alert" in p or "onerror" in p for p in payloads)

    def test_chimera_payloads_contain_lfi(self):
        """Test that payloads contain LFI vectors."""
        payloads = PolyglotEngine.get_chimera_payloads()

        # At least one payload should have path traversal
        assert any("../" in p or "etc/passwd" in p for p in payloads)


# =============================================================================
# retry_on_failure Decorator Tests
# =============================================================================


class TestRetryOnFailure:
    """Test retry_on_failure decorator."""

    def test_success_no_retry(self):
        """Test successful function doesn't retry."""
        call_count = 0

        @retry_on_failure(RetryConfig(max_retries=3, base_delay=0.01))
        def success_func():
            nonlocal call_count
            call_count += 1
            return "success"

        result = success_func()
        assert result == "success"
        assert call_count == 1

    def test_retry_on_timeout(self):
        """Test retry on TimeoutError."""
        import subprocess

        call_count = 0

        @retry_on_failure(RetryConfig(max_retries=3, base_delay=0.01))
        def failing_func():
            nonlocal call_count
            call_count += 1
            if call_count < 3:
                raise subprocess.TimeoutExpired("cmd", 1)
            return "success"

        result = failing_func()
        assert result == "success"
        assert call_count == 3

    def test_retry_exhausted(self):
        """Test that exception is raised after retries exhausted."""
        import subprocess

        @retry_on_failure(RetryConfig(max_retries=2, base_delay=0.01))
        def always_fails():
            raise subprocess.TimeoutExpired("cmd", 1)

        with pytest.raises(subprocess.TimeoutExpired):
            always_fails()


# =============================================================================
# check_exploit_preconditions Tests
# =============================================================================


class TestCheckExploitPreconditions:
    """Test exploit precondition checking."""

    @pytest.fixture
    def mock_state(self):
        """Create a mock AgentState."""
        state = MagicMock()
        state.target = "http://example.com"
        state.phase = MagicMock()
        state.phase.value = "EXPLOIT"
        state.open_services = [80, 443]
        state.vulnerabilities = []
        state.validate.return_value = True
        return state

    def test_precondition_state_required(self):
        """Test precondition fails without state."""
        can_run, reason = check_exploit_preconditions(None, "http://target.com", "sqli")
        assert can_run is False
        assert "State" in reason or "required" in reason.lower()

    def test_precondition_invalid_state(self, mock_state):
        """Test precondition fails with invalid state."""
        mock_state.validate.return_value = False

        can_run, reason = check_exploit_preconditions(mock_state, "http://example.com", "sqli")
        assert can_run is False
        assert "invariant" in reason.lower()

    def test_precondition_no_target(self, mock_state):
        """Test precondition fails without target."""
        mock_state.target = None

        can_run, reason = check_exploit_preconditions(mock_state, "http://example.com", "sqli")
        assert can_run is False
        assert "target" in reason.lower()

    @patch("modules.exploit.STATE_AVAILABLE", True)
    @patch("modules.exploit.AttackPhase")
    def test_precondition_success(self, mock_attack_phase, mock_state):
        """Test precondition succeeds with valid state."""
        # Setup proper phase
        mock_attack_phase.EXPLOIT = mock_state.phase
        mock_attack_phase.FOOTHOLD = MagicMock()
        mock_attack_phase.POST_EXPLOIT = MagicMock()

        mock_state.phase = mock_attack_phase.EXPLOIT

        _can_run, _reason = check_exploit_preconditions(mock_state, "http://example.com:80", "sqli")
        # May fail due to phase check, but shouldn't fail on basic validation
        # This tests the flow rather than specific outcome


# =============================================================================
# suggest_exploit Tests
# =============================================================================


class TestSuggestExploit:
    """Test exploit suggestion function."""

    def test_suggest_sqli(self):
        """Test SQL injection suggestion."""
        result = suggest_exploit("sqli", "http://target.com/login")

        assert isinstance(result, dict)
        assert "tool" in result or "command" in result or "payloads" in result

    def test_suggest_xss(self):
        """Test XSS suggestion."""
        result = suggest_exploit("xss", "http://target.com/search")

        assert isinstance(result, dict)

    def test_suggest_lfi(self):
        """Test LFI suggestion."""
        result = suggest_exploit("lfi", "http://target.com/page")

        assert isinstance(result, dict)

    def test_suggest_auth_bypass(self):
        """Test auth bypass suggestion."""
        result = suggest_exploit("auth_bypass", "http://target.com/admin")

        assert isinstance(result, dict)

    def test_suggest_unknown_type(self):
        """Test unknown vulnerability type."""
        result = suggest_exploit("unknown_vuln_type")

        assert isinstance(result, dict)


# =============================================================================
# Integration Tests (with mocked network)
# =============================================================================


class TestExploitIntegration:
    """Integration tests for exploit functions."""

    @pytest.fixture
    def mock_state_full(self):
        """Create a fully configured mock state."""
        state = MagicMock()
        state.target = "http://testsite.local"
        state.phase = MagicMock()
        state.phase.value = "EXPLOIT"
        state.open_services = [80, 443, 8080]
        state.vulnerabilities = [MagicMock(vuln_id="sqli-001")]
        state.validate.return_value = True
        state.invariant_violations = []
        return state

    @pytest.mark.asyncio
    async def test_ai_exploit_advice_deprecated(self, mock_state_full):
        """Test that ai_exploit_advice shows deprecation warning."""
        from modules.exploit import ai_exploit_advice

        with pytest.warns(DeprecationWarning, match="deprecated"):
            result = await ai_exploit_advice(mock_state_full)

        assert "deprecated" in result or "message" in result

    @pytest.mark.asyncio
    async def test_ai_exploit_advice_no_state(self):
        """Test ai_exploit_advice without state."""
        from modules.exploit import ai_exploit_advice

        with pytest.warns(DeprecationWarning):
            result = await ai_exploit_advice(None)

        assert result.get("blocked") is True or "error" in result


# =============================================================================
# Edge Cases
# =============================================================================


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_empty_payload_mutation(self):
        """Test mutation with empty payload."""
        mutations = AIEvasion.mutate_payload("")
        assert mutations == []

    def test_polyglot_payloads_not_empty(self):
        """Ensure polyglot engine always returns payloads."""
        payloads = PolyglotEngine.get_chimera_payloads()
        assert len(payloads) > 0

    def test_retry_config_immutable_after_creation(self):
        """Test RetryConfig values can be modified (dataclass-like)."""
        config = RetryConfig()
        config.max_retries = 10
        assert config.max_retries == 10

    def test_exploit_error_can_be_caught(self):
        """Test ExploitError can be caught properly."""
        try:
            raise ExploitError("Test")
        except ExploitError as e:
            assert str(e) == "Test"
        except Exception:
            pytest.fail("ExploitError should be caught by ExploitError handler")
