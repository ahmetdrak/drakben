# core/intelligence/exploit_predictor.py
# DRAKBEN — Exploit Success Predictor
#
# Problem: Agent attempts exploits blindly without estimating success probability
# Solution: Bayesian-inspired scoring that combines:
#   - Service version match (exact CVE → version mapping)
#   - Historical success rate (from EvolutionMemory)
#   - Target profile richness (more intel → better prediction)
#   - Defense posture (WAF/IDS detected → lower probability)
#
# Output: probability 0-100% + confidence level + reasoning

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Any

logger = logging.getLogger(__name__)


@dataclass
class ExploitPrediction:
    """Prediction result for an exploit attempt."""

    exploit_name: str
    target: str
    service: str = ""
    probability: float = 0.0  # 0.0 - 1.0
    confidence: str = "low"  # low, medium, high
    factors: list[str] = field(default_factory=list)  # Reasoning trace
    risks: list[str] = field(default_factory=list)
    recommended: bool = False  # Should the agent attempt this?
    alternative_exploits: list[str] = field(default_factory=list)

    def to_compact_str(self) -> str:
        """Human-readable prediction."""
        pct = f"{self.probability:.0%}"
        rec = "✅ RECOMMENDED" if self.recommended else "⚠️ LOW PROBABILITY"
        lines = [
            f"Exploit: {self.exploit_name} → {self.target}:{self.service}",
            f"Success Probability: {pct} ({self.confidence} confidence) {rec}",
        ]
        if self.factors:
            lines.append("Factors:")
            for f in self.factors[:5]:
                lines.append(f"  + {f}")
        if self.risks:
            lines.append("Risks:")
            for r in self.risks[:3]:
                lines.append(f"  - {r}")
        if self.alternative_exploits:
            lines.append(f"Alternatives: {', '.join(self.alternative_exploits[:3])}")
        return "\n".join(lines)

    def to_dict(self) -> dict[str, Any]:
        """Serialize prediction."""
        return {
            "exploit_name": self.exploit_name,
            "target": self.target,
            "service": self.service,
            "probability": round(self.probability, 3),
            "confidence": self.confidence,
            "recommended": self.recommended,
            "factors": self.factors,
            "risks": self.risks,
            "alternatives": self.alternative_exploits,
        }


# ── Known CVE → Version mappings (high-confidence exploits) ──
_CVE_VERSION_MAP: dict[str, dict[str, Any]] = {
    "CVE-2021-41773": {
        "product": "apache",
        "versions": ["2.4.49"],
        "severity": "critical",
        "exploit_type": "path_traversal_rce",
        "base_probability": 0.90,
    },
    "CVE-2021-42013": {
        "product": "apache",
        "versions": ["2.4.49", "2.4.50"],
        "severity": "critical",
        "exploit_type": "path_traversal_rce",
        "base_probability": 0.88,
    },
    "CVE-2017-0144": {
        "product": "smb",
        "versions": [],  # Version-independent (EternalBlue)
        "severity": "critical",
        "exploit_type": "remote_code_execution",
        "base_probability": 0.75,
        "note": "Patched in MS17-010 — check patch level",
    },
    "CVE-2019-0708": {
        "product": "rdp",
        "versions": [],
        "severity": "critical",
        "exploit_type": "remote_code_execution",
        "base_probability": 0.70,
        "note": "BlueKeep — pre-auth RCE on unpatched Windows",
    },
    "CVE-2021-44228": {
        "product": "log4j",
        "versions": [],
        "severity": "critical",
        "exploit_type": "remote_code_execution",
        "base_probability": 0.80,
        "note": "Log4Shell — affects any Java app using Log4j 2.x < 2.15",
    },
    "CVE-2023-44487": {
        "product": "http2",
        "versions": [],
        "severity": "high",
        "exploit_type": "denial_of_service",
        "base_probability": 0.85,
        "note": "HTTP/2 Rapid Reset",
    },
    "CVE-2014-0160": {
        "product": "openssl",
        "versions": ["1.0.1", "1.0.1a", "1.0.1b", "1.0.1c", "1.0.1d", "1.0.1e", "1.0.1f"],
        "severity": "critical",
        "exploit_type": "information_disclosure",
        "base_probability": 0.95,
        "note": "Heartbleed",
    },
    "CVE-2021-3156": {
        "product": "sudo",
        "versions": [],
        "severity": "critical",
        "exploit_type": "privilege_escalation",
        "base_probability": 0.70,
        "note": "Baron Samedit — heap overflow in sudo",
    },
}

# ── Service → Common exploit mapping ──
_SERVICE_EXPLOIT_MAP: dict[str, list[dict[str, Any]]] = {
    "http": [
        {"exploit": "sqli", "base_prob": 0.30, "if_found": ["login", "form", "parameter"]},
        {"exploit": "xss", "base_prob": 0.40, "if_found": ["form", "input", "reflection"]},
        {"exploit": "lfi", "base_prob": 0.25, "if_found": ["php", "include", "file="]},
        {"exploit": "rfi", "base_prob": 0.15, "if_found": ["php", "include"]},
        {"exploit": "upload_shell", "base_prob": 0.20, "if_found": ["upload", "file"]},
    ],
    "ssh": [
        {"exploit": "brute_force", "base_prob": 0.15, "if_found": []},
        {"exploit": "key_based_auth_bypass", "base_prob": 0.05, "if_found": ["authorized_keys"]},
    ],
    "smb": [
        {"exploit": "eternalblue", "base_prob": 0.40, "if_found": ["windows", "smb"]},
        {"exploit": "null_session", "base_prob": 0.50, "if_found": ["null session"]},
        {"exploit": "smb_relay", "base_prob": 0.35, "if_found": ["smb_signing_disabled"]},
    ],
    "mysql": [
        {"exploit": "default_creds", "base_prob": 0.25, "if_found": []},
        {"exploit": "udf_exploit", "base_prob": 0.15, "if_found": ["file_priv"]},
    ],
    "ftp": [
        {"exploit": "anonymous_login", "base_prob": 0.30, "if_found": ["anonymous"]},
        {"exploit": "brute_force", "base_prob": 0.20, "if_found": []},
    ],
    "rdp": [
        {"exploit": "bluekeep", "base_prob": 0.25, "if_found": ["windows 7", "2008"]},
        {"exploit": "brute_force", "base_prob": 0.15, "if_found": []},
    ],
}


class ExploitPredictor:
    """Predicts exploit success probability before attempting.

    Uses a multi-factor scoring system:
    1. CVE-version match (known vulnerable versions)
    2. Historical success rate (from evolution memory)
    3. Target profile completeness
    4. Defense posture (WAF/IDS penalty)
    5. Service-specific heuristics

    Usage::

        predictor = ExploitPredictor(evolution_memory=evo)
        prediction = predictor.predict(
            exploit_name="sqli",
            target="10.0.0.1",
            service="http",
            target_profile=profile,
        )
        if prediction.recommended:
            # Proceed with exploit
        else:
            # Try alternatives

    """

    # Thresholds
    RECOMMEND_THRESHOLD = 0.35  # Recommend if probability > 35%
    HIGH_CONFIDENCE_THRESHOLD = 0.5

    def __init__(
        self,
        evolution_memory: Any = None,
        adversarial_adapter: Any = None,
    ) -> None:
        self._evolution = evolution_memory
        self._adversarial = adversarial_adapter
        self._history: list[dict[str, Any]] = []
        self._stats = {
            "predictions": 0,
            "correct_predictions": 0,
            "recommendations_followed": 0,
        }

    def predict(
        self,
        exploit_name: str,
        target: str,
        service: str = "",
        *,
        cve: str = "",
        product: str = "",
        version: str = "",
        target_profile: Any = None,
        findings: list[str] | None = None,
    ) -> ExploitPrediction:
        """Predict exploit success probability.

        Args:
            exploit_name: Name of the exploit to attempt.
            target: Target IP/domain.
            service: Target service (http, ssh, smb, etc.).
            cve: Specific CVE being exploited.
            product: Target product name (Apache, nginx, etc.).
            version: Target product version.
            target_profile: TargetProfile from CrossCorrelator.
            findings: List of findings from previous scans.

        Returns:
            ExploitPrediction with probability and reasoning.

        """
        self._stats["predictions"] += 1
        prediction = ExploitPrediction(
            exploit_name=exploit_name,
            target=target,
            service=service,
        )

        probability = 0.0
        factors: list[str] = []

        # ── Factor 1: CVE-Version Match (highest weight) ──
        cve_prob = self._check_cve_match(cve, product, version)
        if cve_prob > 0:
            probability += cve_prob * 0.40  # 40% weight
            factors.append(f"CVE match ({cve}): base probability {cve_prob:.0%}")

        # ── Factor 2: Historical Success Rate ──
        hist_prob = self._check_history(exploit_name, service, target)
        if hist_prob is not None:
            probability += hist_prob * 0.25  # 25% weight
            factors.append(f"Historical success rate: {hist_prob:.0%}")

        # ── Factor 3: Service Heuristics ──
        svc_prob = self._check_service_heuristics(
            exploit_name,
            service,
            findings or [],
        )
        if svc_prob > 0:
            probability += svc_prob * 0.20  # 20% weight
            factors.append(f"Service heuristic match: {svc_prob:.0%}")

        # ── Factor 4: Target Profile Richness ──
        profile_boost = self._check_profile(target_profile, service)
        probability += profile_boost * 0.10  # 10% weight
        if profile_boost > 0:
            factors.append(f"Profile completeness boost: +{profile_boost:.0%}")

        # ── Factor 5: Defense Penalty ──
        defense_penalty = self._check_defenses()
        if defense_penalty > 0:
            probability *= 1.0 - defense_penalty
            factors.append(f"Defense penalty: -{defense_penalty:.0%}")
            prediction.risks.append("Active defenses detected — reduced success probability")

        # ── Normalize and enrich ──
        probability = min(1.0, max(0.0, probability))

        # If no factors contributed, give a baseline
        if not factors:
            probability = 0.10
            factors.append("No specific intelligence — baseline estimate")

        prediction.probability = probability
        prediction.factors = factors
        prediction.confidence = self._calc_confidence(factors)
        prediction.recommended = probability >= self.RECOMMEND_THRESHOLD

        # Suggest alternatives if probability is low
        if not prediction.recommended:
            prediction.alternative_exploits = self._suggest_alternatives(
                service,
                exploit_name,
                findings or [],
            )

        # Record prediction for later accuracy tracking
        self._history.append(
            {
                "exploit": exploit_name,
                "target": target,
                "service": service,
                "predicted_prob": probability,
                "recommended": prediction.recommended,
            }
        )
        if len(self._history) > 200:
            self._history = self._history[-200:]

        return prediction

    def record_outcome(
        self,
        exploit_name: str,
        target: str,
        success: bool,
    ) -> None:
        """Record actual outcome to improve future predictions."""
        # Find matching prediction
        for entry in reversed(self._history):
            if entry["exploit"] == exploit_name and entry["target"] == target:
                entry["actual_success"] = success
                # Check if prediction was correct
                predicted_success = entry["predicted_prob"] >= self.RECOMMEND_THRESHOLD
                if predicted_success == success:
                    self._stats["correct_predictions"] += 1
                break

    def get_accuracy(self) -> float:
        """Calculate prediction accuracy."""
        evaluated = [e for e in self._history if "actual_success" in e]
        if not evaluated:
            return 0.0
        correct = sum(1 for e in evaluated if (e["predicted_prob"] >= self.RECOMMEND_THRESHOLD) == e["actual_success"])
        return correct / len(evaluated)

    def get_stats(self) -> dict[str, Any]:
        """Return predictor statistics."""
        return {
            **self._stats,
            "accuracy": self.get_accuracy(),
            "total_history": len(self._history),
        }

    # ─────────────────── Factor Methods ───────────────────

    def _check_cve_match(self, cve: str, product: str, version: str) -> float:
        """Check if CVE has a known version match."""
        if not cve:
            return 0.0

        cve_upper = cve.upper()
        info = _CVE_VERSION_MAP.get(cve_upper)
        if not info:
            return 0.20  # Unknown CVE — low baseline

        # Check product match
        if info.get("product") and product:
            if info["product"].lower() not in product.lower():
                return 0.15  # Product mismatch

        # Check version match
        known_versions = info.get("versions", [])
        if known_versions and version:
            for kv in known_versions:
                if kv in version:
                    return info.get("base_probability", 0.70)
            return info.get("base_probability", 0.50) * 0.6  # Version mismatch penalty

        return info.get("base_probability", 0.50)

    def _check_history(
        self,
        exploit_name: str,
        _service: str,
        _target: str,
    ) -> float | None:
        """Check historical success rate from evolution memory."""
        if not self._evolution:
            return None

        try:
            records = self._evolution.get_recent_actions(limit=50)
            relevant = [
                r
                for r in records
                if (hasattr(r, "tool") and exploit_name.lower() in str(r.tool).lower())
                or (hasattr(r, "action") and exploit_name.lower() in str(getattr(r, "action", "")).lower())
            ]
            if not relevant:
                return None

            successes = sum(1 for r in relevant if hasattr(r, "outcome") and r.outcome == "success")
            return successes / len(relevant)
        except (AttributeError, TypeError, ZeroDivisionError):
            logger.debug("Historical success rate lookup failed", exc_info=True)
            return None

    def _check_service_heuristics(
        self,
        exploit_name: str,
        service: str,
        findings: list[str],
    ) -> float:
        """Check service-specific exploit heuristics."""
        service_lower = service.lower()
        exploits = _SERVICE_EXPLOIT_MAP.get(service_lower, [])

        for exploit_info in exploits:
            if exploit_info["exploit"].lower() in exploit_name.lower():
                base = exploit_info["base_prob"]
                # Boost if specific indicators found
                required_indicators = exploit_info.get("if_found", [])
                if required_indicators:
                    findings_text = " ".join(findings).lower()
                    matches = sum(1 for ind in required_indicators if ind.lower() in findings_text)
                    if matches > 0:
                        boost = min(0.3, 0.15 * matches)
                        base += boost
                return min(1.0, base)

        return 0.0

    def _check_profile(self, target_profile: Any, service: str) -> float:
        """Check target profile completeness for confidence boost."""
        if not target_profile:
            return 0.0

        boost = 0.0
        services = getattr(target_profile, "services", {})
        if services:
            boost += 0.1  # Has service data
        total_findings = getattr(target_profile, "total_findings", 0)
        if total_findings > 5:
            boost += 0.1  # Rich findings
        if total_findings > 15:
            boost += 0.1  # Very rich findings

        # Check specific service has data
        for svc in services.values():
            if hasattr(svc, "service") and service.lower() in str(svc.service).lower():
                if hasattr(svc, "tools_reported") and len(svc.tools_reported) >= 2:
                    boost += 0.15  # Multiple tools confirmed this service
                break

        return min(0.5, boost)

    def _check_defenses(self) -> float:
        """Calculate defense penalty from adversarial adapter."""
        if not self._adversarial:
            return 0.0

        if not self._adversarial.is_defended():
            return 0.0

        # Penalty based on stealth level
        level = self._adversarial.get_stealth_level()
        penalties = {
            0: 0.0,  # NORMAL
            1: 0.10,  # LOW
            2: 0.20,  # MEDIUM
            3: 0.35,  # HIGH
            4: 0.50,  # PARANOID
        }
        return penalties.get(level.value, 0.0)

    def _calc_confidence(self, factors: list[str]) -> str:
        """Calculate confidence level based on available evidence."""
        if len(factors) >= 4:
            return "high"
        if len(factors) >= 2:
            return "medium"
        return "low"

    def _suggest_alternatives(
        self,
        service: str,
        current_exploit: str,
        _findings: list[str],
    ) -> list[str]:
        """Suggest alternative exploits when primary has low probability."""
        alternatives: list[str] = []
        service_lower = service.lower()
        exploits = _SERVICE_EXPLOIT_MAP.get(service_lower, [])

        for exploit_info in exploits:
            name = exploit_info["exploit"]
            if name.lower() != current_exploit.lower():
                alternatives.append(name)

        return alternatives[:3]
