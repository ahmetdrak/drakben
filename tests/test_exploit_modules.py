# tests/test_exploit_modules.py
"""
DRAKBEN — Exploit Module Expansion Tests.

Tests for the new exploit sub-modules:
  - injection.py (SQL, NoSQL, LDAP, Command injection)
  - auth_bypass.py (JWT, session, default creds, privesc)
  - header_security.py (headers, CORS, CSP, clickjacking)
  - file_inclusion.py (LFI, RFI, upload bypass, log poisoning)
"""

import base64
import json

# ═══════════════════════════════════════════════════════════
# Injection Module Tests
# ═══════════════════════════════════════════════════════════

class TestDBMSDetection:
    """Test DBMS fingerprinting from error messages."""

    def test_detect_mysql(self) -> None:
        from modules.exploit.injection import detect_dbms_from_error
        assert detect_dbms_from_error("You have an error in your SQL syntax near ''") == "mysql"

    def test_detect_postgresql(self) -> None:
        from modules.exploit.injection import detect_dbms_from_error
        assert detect_dbms_from_error("ERROR: unterminated quoted string at pg_query") == "postgresql"

    def test_detect_mssql(self) -> None:
        from modules.exploit.injection import detect_dbms_from_error
        assert detect_dbms_from_error("Microsoft OLE DB Provider for SQL Server") == "mssql"

    def test_detect_oracle(self) -> None:
        from modules.exploit.injection import detect_dbms_from_error
        assert detect_dbms_from_error("ORA-01756: quoted string not properly terminated") == "oracle"

    def test_detect_sqlite(self) -> None:
        from modules.exploit.injection import detect_dbms_from_error
        assert detect_dbms_from_error("sqlite3.OperationalError: near") == "sqlite"

    def test_detect_unknown(self) -> None:
        from modules.exploit.injection import detect_dbms_from_error
        assert detect_dbms_from_error("Normal web page content") is None


class TestErrorPayloadGeneration:
    """Test SQL injection payload generation."""

    def test_generates_payloads(self) -> None:
        from modules.exploit.injection import generate_error_payloads
        payloads = generate_error_payloads("1")
        assert len(payloads) >= 8
        assert all("payload" in p and "technique" in p for p in payloads)

    def test_payloads_contain_injection_chars(self) -> None:
        from modules.exploit.injection import generate_error_payloads
        payloads = generate_error_payloads("test")
        payload_texts = [p["payload"] for p in payloads]
        assert any("'" in p for p in payload_texts)
        assert any("OR" in p for p in payload_texts)

    def test_custom_param_value(self) -> None:
        from modules.exploit.injection import generate_error_payloads
        payloads = generate_error_payloads("custom_val")
        assert all(p["payload"].startswith("custom_val") for p in payloads)


class TestUnionProbes:
    """Test UNION-based column detection."""

    def test_generates_correct_count(self) -> None:
        from modules.exploit.injection import generate_union_probes
        probes = generate_union_probes(5)
        assert len(probes) == 5

    def test_increasing_null_counts(self) -> None:
        from modules.exploit.injection import generate_union_probes
        probes = generate_union_probes(3)
        assert probes[0].count("NULL") == 1
        assert probes[1].count("NULL") == 2
        assert probes[2].count("NULL") == 3

    def test_default_max_columns(self) -> None:
        from modules.exploit.injection import generate_union_probes
        probes = generate_union_probes()
        assert len(probes) == 10


class TestNoSQLPayloads:
    """Test NoSQL injection payload structure."""

    def test_nosql_payloads_exist(self) -> None:
        from modules.exploit.injection import _NOSQL_PAYLOADS
        assert len(_NOSQL_PAYLOADS) >= 5
        assert all("payload" in p and "technique" in p for p in _NOSQL_PAYLOADS)


class TestCommandInjection:
    """Test command injection payload structure."""

    def test_cmd_payloads_exist(self) -> None:
        from modules.exploit.injection import _CMD_PAYLOADS
        assert len(_CMD_PAYLOADS) >= 6
        assert all("payload" in p and "technique" in p for p in _CMD_PAYLOADS)

    def test_cmd_indicators_are_regex(self) -> None:
        import re

        from modules.exploit.injection import _CMD_INDICATORS
        for pattern in _CMD_INDICATORS:
            re.compile(pattern)  # Should not raise


class TestInjectParam:
    """Test URL parameter injection utility."""

    def test_inject_without_query(self) -> None:
        from modules.exploit.injection import _inject_param
        result = _inject_param("http://target.com/page", "id", "1' OR 1=1")
        assert "?" in result
        assert "id=" in result

    def test_inject_with_existing_query(self) -> None:
        from modules.exploit.injection import _inject_param
        result = _inject_param("http://target.com/page?a=1", "id", "test")
        assert "&id=" in result


# ═══════════════════════════════════════════════════════════
# Auth Bypass Module Tests
# ═══════════════════════════════════════════════════════════

class TestJWTAnalyzer:
    """Test JWT token analysis and manipulation."""

    @staticmethod
    def _make_jwt(header: dict, payload: dict, sig: str = "test_sig") -> str:
        """Helper to create a test JWT."""
        h = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b"=").decode()
        p = base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b"=").decode()
        return f"{h}.{p}.{sig}"

    def test_decode_valid_jwt(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "HS256", "typ": "JWT"}, {"sub": "1", "admin": False})
        result = JWTAnalyzer.decode_jwt(token)
        assert result["header"]["alg"] == "HS256"
        assert result["payload"]["sub"] == "1"
        assert result["algorithm"] == "HS256"

    def test_decode_invalid_jwt(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        result = JWTAnalyzer.decode_jwt("not.a.valid.jwt.token")
        assert "error" in result

    def test_none_algorithm_attack(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "HS256"}, {"admin": True})
        modified = JWTAnalyzer.craft_none_algorithm(token)
        decoded = JWTAnalyzer.decode_jwt(modified)
        assert decoded["header"]["alg"] == "none"

    def test_algorithm_confusion(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "RS256"}, {"admin": True})
        modified = JWTAnalyzer.craft_algorithm_confusion(token)
        assert "tampered_sig" in modified

    def test_modify_claims(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "HS256"}, {"role": "user"})
        modified = JWTAnalyzer.modify_claims(token, {"role": "admin"})
        decoded = JWTAnalyzer.decode_jwt(modified)
        assert decoded["payload"]["role"] == "admin"

    def test_check_weaknesses_none_alg(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "none"}, {"sub": "1"})
        weaknesses = JWTAnalyzer.check_common_weaknesses(token)
        assert any(w["severity"] == "CRITICAL" for w in weaknesses)

    def test_check_weaknesses_no_expiration(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "HS256"}, {"sub": "1"})
        weaknesses = JWTAnalyzer.check_common_weaknesses(token)
        assert any("exp" in w.get("issue", "") for w in weaknesses)

    def test_check_weaknesses_sensitive_data(self) -> None:
        from modules.exploit.auth_bypass import JWTAnalyzer
        token = self._make_jwt({"alg": "HS256"}, {"sub": "1", "password": "secret123"})
        weaknesses = JWTAnalyzer.check_common_weaknesses(token)
        assert any("password" in w.get("issue", "").lower() for w in weaknesses)


class TestDefaultCredentials:
    """Test default credential list structure."""

    def test_credentials_exist(self) -> None:
        from modules.exploit.auth_bypass import DEFAULT_CREDENTIALS
        assert len(DEFAULT_CREDENTIALS) >= 15
        assert all("username" in c and "password" in c for c in DEFAULT_CREDENTIALS)

    def test_common_defaults_included(self) -> None:
        from modules.exploit.auth_bypass import DEFAULT_CREDENTIALS
        usernames = {c["username"] for c in DEFAULT_CREDENTIALS}
        assert "admin" in usernames
        assert "root" in usernames


class TestPrivEscPaths:
    """Test privilege escalation path list."""

    def test_paths_exist(self) -> None:
        from modules.exploit.auth_bypass import _IDOR_ESCALATION_PATHS
        assert len(_IDOR_ESCALATION_PATHS) >= 10
        assert any("/admin" in p for p in _IDOR_ESCALATION_PATHS)


class TestPathRiskAssessment:
    """Test risk assessment function."""

    def test_admin_is_high_risk(self) -> None:
        from modules.exploit.auth_bypass import _assess_path_risk
        assert _assess_path_risk("/admin") == "HIGH"

    def test_console_is_high_risk(self) -> None:
        from modules.exploit.auth_bypass import _assess_path_risk
        assert _assess_path_risk("/console") == "HIGH"

    def test_swagger_is_medium_risk(self) -> None:
        from modules.exploit.auth_bypass import _assess_path_risk
        assert _assess_path_risk("/swagger-ui.html") == "MEDIUM"

    def test_unknown_is_low_risk(self) -> None:
        from modules.exploit.auth_bypass import _assess_path_risk
        assert _assess_path_risk("/custom-page") == "LOW"


# ═══════════════════════════════════════════════════════════
# Header Security Module Tests
# ═══════════════════════════════════════════════════════════

class TestCSPAnalysis:
    """Test Content-Security-Policy analysis."""

    def test_empty_csp(self) -> None:
        from modules.exploit.header_security import analyze_csp
        result = analyze_csp("")
        assert result["score"] == 0
        assert len(result["weaknesses"]) > 0

    def test_csp_unsafe_inline(self) -> None:
        from modules.exploit.header_security import analyze_csp
        result = analyze_csp("script-src 'self' 'unsafe-inline'")
        assert any(w["severity"] == "HIGH" for w in result["weaknesses"])

    def test_csp_unsafe_eval(self) -> None:
        from modules.exploit.header_security import analyze_csp
        result = analyze_csp("script-src 'self' 'unsafe-eval'")
        assert any("eval" in w.get("issue", "").lower() for w in result["weaknesses"])

    def test_csp_wildcard(self) -> None:
        from modules.exploit.header_security import analyze_csp
        result = analyze_csp("default-src *")
        assert any(w["severity"] == "HIGH" for w in result["weaknesses"])

    def test_good_csp(self) -> None:
        from modules.exploit.header_security import analyze_csp
        result = analyze_csp("default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self'")
        assert result["score"] >= 80

    def test_csp_returns_directives(self) -> None:
        from modules.exploit.header_security import analyze_csp
        result = analyze_csp("default-src 'self'; script-src 'self' cdn.example.com")
        assert "default-src" in result["directives"]
        assert "script-src" in result["directives"]


class TestGrading:
    """Test score-to-grade conversion."""

    def test_grade_a(self) -> None:
        from modules.exploit.header_security import _grade_from_score
        assert _grade_from_score(95) == "A"

    def test_grade_b(self) -> None:
        from modules.exploit.header_security import _grade_from_score
        assert _grade_from_score(80) == "B"

    def test_grade_f(self) -> None:
        from modules.exploit.header_security import _grade_from_score
        assert _grade_from_score(20) == "F"


class TestCORSOrigins:
    """Test CORS test origins."""

    def test_cors_origins_exist(self) -> None:
        from modules.exploit.header_security import _CORS_TEST_ORIGINS
        assert len(_CORS_TEST_ORIGINS) >= 4
        assert "https://evil.com" in _CORS_TEST_ORIGINS
        assert "null" in _CORS_TEST_ORIGINS


class TestSecurityHeadersList:
    """Test security headers definition."""

    def test_headers_defined(self) -> None:
        from modules.exploit.header_security import _SECURITY_HEADERS
        assert len(_SECURITY_HEADERS) >= 6
        assert "Strict-Transport-Security" in _SECURITY_HEADERS
        assert "Content-Security-Policy" in _SECURITY_HEADERS

    def test_headers_have_severity(self) -> None:
        from modules.exploit.header_security import _SECURITY_HEADERS
        for name, meta in _SECURITY_HEADERS.items():
            assert "severity" in meta, f"Missing severity for {name}"
            assert "recommendation" in meta, f"Missing recommendation for {name}"


# ═══════════════════════════════════════════════════════════
# File Inclusion Module Tests
# ═══════════════════════════════════════════════════════════

class TestFileContentDetection:
    """Test file content indicator detection."""

    def test_detect_passwd(self) -> None:
        from modules.exploit.file_inclusion import _detect_file_content
        assert _detect_file_content("root:x:0:0:root:/root:/bin/bash") is not None

    def test_detect_shadow(self) -> None:
        from modules.exploit.file_inclusion import _detect_file_content
        assert _detect_file_content("root:$6$salt$hash:19000:0:99999:7:::") is not None

    def test_detect_winini(self) -> None:
        from modules.exploit.file_inclusion import _detect_file_content
        assert _detect_file_content("[fonts]\nCourier New") is not None

    def test_no_detection_normal_page(self) -> None:
        from modules.exploit.file_inclusion import _detect_file_content
        assert _detect_file_content("<html>Normal page</html>") is None


class TestRFIIndicators:
    """Test RFI indicator detection."""

    def test_detect_include_error(self) -> None:
        from modules.exploit.file_inclusion import _detect_rfi_indicators
        assert _detect_rfi_indicators("Warning: include(http://evil.com): failed to open stream")

    def test_detect_fopen_error(self) -> None:
        from modules.exploit.file_inclusion import _detect_rfi_indicators
        assert _detect_rfi_indicators("Warning: fopen(): URL file-access is disabled")

    def test_no_detection_normal(self) -> None:
        from modules.exploit.file_inclusion import _detect_rfi_indicators
        assert not _detect_rfi_indicators("<html>Welcome</html>")


class TestLogContentDetection:
    """Test log file content detection."""

    def test_detect_access_log(self) -> None:
        from modules.exploit.file_inclusion import _is_log_content
        assert _is_log_content('192.168.1.1 - - GET /index.html HTTP/1.1 200 Mozilla/5.0')

    def test_no_log_in_normal_page(self) -> None:
        from modules.exploit.file_inclusion import _is_log_content
        assert not _is_log_content("<html><body>Hello</body></html>")


class TestUploadPayloads:
    """Test file upload bypass payload generation."""

    def test_generates_payloads(self) -> None:
        from modules.exploit.file_inclusion import generate_upload_payloads
        payloads = generate_upload_payloads()
        assert len(payloads) >= 6
        assert all("filename" in p and "technique" in p for p in payloads)

    def test_diverse_techniques(self) -> None:
        from modules.exploit.file_inclusion import generate_upload_payloads
        techniques = {p["technique"] for p in generate_upload_payloads()}
        assert "double_extension" in techniques
        assert "magic_bytes" in techniques


class TestTraversalPayloads:
    """Test path traversal payload quality."""

    def test_payloads_exist(self) -> None:
        from modules.exploit.file_inclusion import _TRAVERSAL_PAYLOADS
        assert len(_TRAVERSAL_PAYLOADS) >= 8

    def test_includes_encoding_variants(self) -> None:
        from modules.exploit.file_inclusion import _TRAVERSAL_PAYLOADS
        encoded_payloads = [p for p in _TRAVERSAL_PAYLOADS if "%" in p]
        assert len(encoded_payloads) >= 3

    def test_includes_windows_paths(self) -> None:
        from modules.exploit.file_inclusion import _TRAVERSAL_PAYLOADS
        win_payloads = [p for p in _TRAVERSAL_PAYLOADS if "windows" in p.lower() or "\\" in p]
        assert len(win_payloads) >= 1
